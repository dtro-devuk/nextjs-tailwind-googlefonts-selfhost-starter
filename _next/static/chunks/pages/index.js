_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/index"],{

/***/ "./components/Avatar.js":
/*!******************************!*\
  !*** ./components/Avatar.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-tailwind-googlefonts-selfhost-starter\\components\\Avatar.js",
    _this = undefined;

/**
 * Profile Avatar as SVG
 * @description Main Site Avatar for profile
 * @author dtro-devuk @github:dtro-devuk.io
 */
var Avatar = function Avatar(_ref) {
  var className = _ref.className;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("svg", {
    version: "1.1",
    id: "svg3169",
    className: className,
    fill: "none",
    viewBox: "0 0 540.84509 539.49298",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
      id: "title3742",
      children: "dtro-devuk avatar "
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("metadata", {
      id: "metadata3175"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("defs", {
      id: "defs3173"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("image", {
      width: "540.84509",
      height: "539.49298",
      preserveAspectRatio: "none",
      href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGPCAYAAAByP4aCAAAAAXNSR0IArs4c6QAAAARnQU1BAACx\r jwv8YQUAAAAJcEhZcwAACusAAArrAYKLDVoAAADbaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8\r P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pg0KPHg6\r eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+DQogIDxyZGY6UkRGIHhtbG5zOnJkZj0i\r aHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgLz4NCjwveDp4bXBt\r ZXRhPg0KPD94cGFja2V0IGVuZD0iciI/PiMHdFEAAP6+SURBVHhe7L0HwG1XVSe+vt77672/l04q\r CQGBAAFBHUUHRkfFjn0cy98ZHUWxjH10HNGx90HUEUZFBNIgBNJIfcl7yev1e+Xrvf/Xb6212yn3\r u997iQGS37377NX2Pvuee85eZ5ezT83S3FNLFGFpaYmeeuo5euvb30v95wZMmkUtUQ0HQ02NEYKE\r YWR5RpqAEfMRLWSJjumQTSwHmC/UGV2m06/SMZLyRrSQGVvmS49Hzt7ojL1nc/YA81lRLBB14JcW\r 52lurJ+JBZNkUFNHDZ0b+O+st2zi1DEk4wIUCMW0OBeF6UpNihWVz7MyRHbVJskYXmKyAlSd0wuA\r 5LLOYxm1Q97sUhJWmSay42qoBCUKLy7f1xJ0heoCoYhS+dLiAs2OXARhEocl2rC+gx558G9o/frV\r Jnt5IHgBw/nzA/Seb/tJjgdNUoRwIaSVePYCKeBzlXGWt0jsnC6mgbiSTuUSRGS0h8lzOqWRn0qc\r HIAww7soKR+APLLlMkYyj3jEIlPSEfpxrFcamHZpBE6vAt2Fz8EQ9BURpU2tRWHBRAIwLgRSf38+\r l8jAgok8nCAohOKNBs3XpBayiHQhoRdJ8IiFWt70k1rkBEn+UcgbZsK/JYr2H4Wi8kvImKUsh/ST\r tzAkYt64kCiyCDp/LjErQfRAsImlQcQbhKyeISWWPGEjAoNjvMBY3vi8XkERcg5kcXFJnMdi+S2A\r wB9bQdEBzsjcn+YRM6CNlyircwgnlcqdzmgvcnIg0jnaQ/MqzC8pr+kkMtojLhMQ6SWP1FZlxpqt\r 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\r AABJRU5ErkJggg==\r ",
      id: "image3179"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 5
  }, _this);
};

_c = Avatar;
/* harmony default export */ __webpack_exports__["default"] = (Avatar);

var _c;

$RefreshReg$(_c, "Avatar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Container.js":
/*!*********************************!*\
  !*** ./components/Container.js ***!
  \*********************************/
/*! exports provided: siteTitle, description, profileName, licenseInfo, codeLinkUrl, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siteTitle", function() { return siteTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "description", function() { return description; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profileName", function() { return profileName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "licenseInfo", function() { return licenseInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "codeLinkUrl", function() { return codeLinkUrl; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Head */ "./components/Head.js");
/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Header */ "./components/Header.js");
/* harmony import */ var _components_Footer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/Footer */ "./components/Footer.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-tailwind-googlefonts-selfhost-starter\\components\\Container.js",
    _this = undefined;

/**
 * Container
 * @description Main Container for the App
 * @author dtro-devuk @github:dtro-devuk.io
 */



 // const version = require('@/package.json');



var siteTitle = 'Nextjs 10, Tailwind CSS 2.0+ and Google Fonts Self-Hosting Demo';
var description = 'A simple demo to show how to use self-hosted Google fonts. "font-dispay:swap" is used to stop FOUT and FOIT. Try refreshing the page, there is no signs of either of these.';
var profileName = 'dtro-devuk';
var licenseInfo = 'It is important to always read the license for every font that you use. All of the Google fonts used here use the SIL Open Font License, v1.1. Some fonts use the Apache 2 license. The Ubuntu fonts use the Ubuntu Font License v1.0.';
var codeLinkUrl = 'https://github.com/dtro-devuk/nextjs-tailwind-googlefonts-selfhost-starter';

var Container = function Container(_ref) {
  var children = _ref.children;
  var versionInfo = _package_json__WEBPACK_IMPORTED_MODULE_5__["version"];
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    id: "container",
    className: "bg-gray-300",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Head__WEBPACK_IMPORTED_MODULE_2__["default"], {
      title: siteTitle,
      description: description
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Header__WEBPACK_IMPORTED_MODULE_3__["default"], {
      caption: siteTitle,
      author: profileName,
      description: description,
      licenseInfo: licenseInfo,
      codeLinkUrl: codeLinkUrl
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("main", {
      id: "main-content",
      role: "main",
      "aria-label": "main content area for the page",
      className: "flex-1 p-3 overflow-y-hidden justify-center\r mx-2 sm:my-12 sm:text-sm\r md:mx-8 \r leading-relaxed\r bg-white",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Footer__WEBPACK_IMPORTED_MODULE_4__["default"], {
      caption: siteTitle,
      author: profileName,
      versionInfo: versionInfo,
      licenseInfo: licenseInfo
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 50,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 29,
    columnNumber: 5
  }, _this);
};

_c = Container;
/* harmony default export */ __webpack_exports__["default"] = (Container);
Container.propTypes = {
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node.isRequired
};

var _c;

$RefreshReg$(_c, "Container");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Footer.js":
/*!******************************!*\
  !*** ./components/Footer.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-tailwind-googlefonts-selfhost-starter\\components\\Footer.js",
    _this = undefined;

/**
 * Site Footer Component
 * @description footer elements to be included here
 * @author dtro-devuk @github:dtro-devuk.io
 */


var Footer = function Footer(_ref) {
  var caption = _ref.caption,
      versionInfo = _ref.versionInfo,
      author = _ref.author,
      licenseInfo = _ref.licenseInfo;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("footer", {
    id: "main-footer",
    role: "contentinfo",
    "aria-label": "main footer content info",
    className: "w-full p-3\r flex flex-col items-center text-center \r bg-gray-800 ",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "text-white font-sans",
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "bg-gray-300 w-full font-sans font-normal text-center p-2",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: " text-gray-800",
          children: licenseInfo
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 20,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 19,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "text-white text-sm md:text-1xl lg:text-2xl p-3",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: " text-md md:text-2xl lg:text-3xl p-3",
          children: caption
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 24,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          children: ["Copyright ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
            dangerouslySetInnerHTML: {
              __html: '&copy;'
            }
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 26,
            columnNumber: 23
          }, _this), ' ', /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
            href: "https://www.github.com/dtro-devuk",
            className: "font-semibold\r text-yellow-600\r hover:text-yellow-200",
            target: "_blank",
            rel: "noopener noreferrer",
            children: author
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 27,
            columnNumber: 13
          }, _this), ' ', "2021"]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 25,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "p-2 text-yellow-600",
          children: ["Version: ", versionInfo]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 39,
          columnNumber: 11
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 23,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 7
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, _this);
};

_c = Footer;
/* harmony default export */ __webpack_exports__["default"] = (Footer);
Footer.propTypes = {
  caption: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  versionInfo: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  licenseInfo: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Footer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/GitHubCodeLink.js":
/*!**************************************!*\
  !*** ./components/GitHubCodeLink.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-tailwind-googlefonts-selfhost-starter\\components\\GitHubCodeLink.js",
    _this = undefined;

/**
 * Link to associated Github code
 * @description footer elements to be included here
 * @author dtro-devuk @github:dtro-devuk.io
 */



var GitHubCodeLink = function GitHubCodeLink(_ref) {
  var codeLinkUrl = _ref.codeLinkUrl,
      inNewTab = _ref.inNewTab,
      caption = _ref.caption;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
    href: codeLinkUrl,
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
      className: "lg:inline-flex lg:w-auto w-full px-3 py-2 rounded text-sm md:text-lg\n                     text-yellow-500 hover:text-white active:text-yellow-600 focus:outline-none\"\n                    transform ".concat('hover:scale-x-90 transition ease-in-out duration-500'),
      target: inNewTab ? '_blank' : '_self',
      rel: "noopener noreferrer",
      children: caption || '[see code...]'
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 7
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, _this);
};

_c = GitHubCodeLink;
GitHubCodeLink.propTypes = {
  codeLinkUrl: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  inNewTab: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool.isRequired,
  caption: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string
};
/* harmony default export */ __webpack_exports__["default"] = (GitHubCodeLink);

var _c;

$RefreshReg$(_c, "GitHubCodeLink");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Head.js":
/*!****************************!*\
  !*** ./components/Head.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-tailwind-googlefonts-selfhost-starter\\components\\Head.js",
    _this = undefined;

/**
 * Head
 * @description Site Head modifications
 * @author dtro-devuk @github:dtro-devuk.io
 */




var Head = function Head(_ref) {
  var title = _ref.title,
      description = _ref.description;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_3___default.a, {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      charSet: "UTF-8"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
      children: title
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      name: "description",
      content: description
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("meta", {
      name: "viewport",
      content: "width=device-width, initial-scale=1 shrink-to-fit=no, user-scalable=0"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, _this);
};

_c = Head;
/* harmony default export */ __webpack_exports__["default"] = (Head);
Head.propTypes = {
  title: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired,
  description: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/Header.js":
/*!******************************!*\
  !*** ./components/Header.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _components_Avatar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Avatar */ "./components/Avatar.js");
/* harmony import */ var _components_GitHubCodeLink__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/GitHubCodeLink */ "./components/GitHubCodeLink.js");


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-tailwind-googlefonts-selfhost-starter\\components\\Header.js",
    _this = undefined;

/**
 * Header Component
 * @description Site Header including the Navigation menu
 * @author dtro-devuk @github:dtro-devuk.io
 */





var Header = function Header(_ref) {
  var caption = _ref.caption,
      author = _ref.author,
      description = _ref.description,
      codeLinkUrl = _ref.codeLinkUrl;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("header", {
    id: "header",
    role: "banner",
    className: "sticky-header\r flex flex-col items-center text-center\r bg-gray-800",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "p-3 font-black font-Oswald-VariableFont\r text-lg md:text-3xl lg:text-4xl\r text-white",
      children: caption
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "md:p-2",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
        href: "/",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "inline-flex items-center w-auto cursor-pointer focus:outline-none",
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Avatar__WEBPACK_IMPORTED_MODULE_3__["default"], {
            className: "h-12 w-12 rounded-full md:mr-2 md:h-20 md:w-20\r border-4 border-white-200 \r transform hover:scale-125 hover:bg-opacity-50 transition ease-out duration-500"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 30,
            columnNumber: 13
          }, _this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 29,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 28,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
        href: "/",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "inline-flex items-center w-auto cursor-pointer focus:outline-none",
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
            className: "p-3 font-bold italic\r font-Grandstander-VariableFont\r text-xl md:text-3xl lg:text-4xl\r transform hover:scale-x-90 transition ease-in-out duration-500\r text-blue-400",
            children: author || ''
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 41,
            columnNumber: 13
          }, _this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 40,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_GitHubCodeLink__WEBPACK_IMPORTED_MODULE_4__["default"], {
      caption: 'see the code on GitHub',
      codeLinkUrl: codeLinkUrl,
      inNewTab: true
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 54,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "hidden bg-gray-500 w-full",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("section", {
        "aria-label": "Demo description",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h2", {
          className: "p-3 font-normal text-white italic font-serif text-center",
          children: description || ''
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 61,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 60,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 59,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 13,
    columnNumber: 5
  }, _this);
};

_c = Header;
/* harmony default export */ __webpack_exports__["default"] = (Header);
Header.propTypes = {
  caption: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  author: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  description: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  codeLinkUrl: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired
};

var _c;

$RefreshReg$(_c, "Header");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/LicenseBanner.js":
/*!*************************************!*\
  !*** ./components/LicenseBanner.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);


var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-tailwind-googlefonts-selfhost-starter\\components\\LicenseBanner.js",
    _this = undefined;

/**
 *Home Button
 * @description Return to the Home Page
 * @author dtro-devuk @github:dtro-devuk.io
 */


var LicenseBanner = function LicenseBanner(_ref) {
  var licenseInfo = _ref.licenseInfo;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    id: "licensing-info",
    "aria-label": "google Fonts licensing info",
    className: "bg-gray-500 w-full p-3",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "sm:text-sm",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "bg-gray-300 font-sans font-normal text-center p-3",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h2", {
          className: "font-bold text-gray-700 text-center uppercase leading-loose p-3",
          children: "Google Font Licensing"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 18,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "text-gray-800 font-serif font-bold p-3",
          children: licenseInfo
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 21,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "text-gray-800 font-serif text-center",
          children: "An `OFL.txt` file detailing the license should be stored alongside the fonts, when self-hosted and in your GitHub Repo"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 22,
          columnNumber: 11
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 17,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 11,
    columnNumber: 5
  }, _this);
};

_c = LicenseBanner;
LicenseBanner.propTypes = {
  licenseInfo: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (LicenseBanner);

var _c;

$RefreshReg$(_c, "LicenseBanner");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./lib/hooks.js":
/*!**********************!*\
  !*** ./lib/hooks.js ***!
  \**********************/
/*! exports provided: useGoogleFontLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useGoogleFontLoader", function() { return useGoogleFontLoader; });
/**
 * A simple hook to Load self-hosted Google Fonts famalies
 *
 * We are use Font Face Observer npm package to load the
 *
 * @see : https://github.com/bramstein/fontfaceobserver
 *
 */
var FontFaceObserver = __webpack_require__(/*! fontfaceobserver */ "./node_modules/fontfaceobserver/fontfaceobserver.standalone.js");

var useGoogleFontLoader = function useGoogleFontLoader() {
  var debug = true;
  var baseFontOne = !debug ? '/nextjs-tailwind-googlefonts-selfhost-starter/static/fonts/google/grandstander/Grandstander-VariableFont_wght.ttf' : '/static/fonts/google/grandstander/Grandstander-VariableFont_wght.ttf';
  var baseFontTwo = !debug ? '/nextjs-tailwind-googlefonts-selfhost-starter/static/fonts/google/oswald/Oswald-VariableFont_wght.ttf' : '/static/fonts/google/oswald/Oswald-VariableFont_wght.ttf';
  var linkOne = document.createElement('link');
  linkOne.href = baseFontOne;
  linkOne.rel = 'preload';
  linkOne.as = 'font';
  linkOne.type = 'font/ttf';
  linkOne.crossOrigin = 'anonymous';
  document.head.appendChild(linkOne);
  var linkTwo = document.createElement('link');
  linkTwo.href = baseFontTwo;
  linkTwo.rel = 'preload';
  linkTwo.as = 'font';
  linkTwo.type = 'font/ttf';
  linkTwo.crossOrigin = 'anonymous';
  document.head.appendChild(linkTwo);
  LoadTheFonts(); // const font = new FontFaceObserver('Grandstander Variable');
  // font
  //   .load()
  //   .then(() => {
  //     console.log('Font has loaded.');
  //     document.documentElement.classList.add('Grandstander Variable');
  //   })
  //   .catch(() => {
  //     console.log('Font Sans failed to load.');
  //   });
  // const fontData = {
  //   'Grandstander Variable': {},
  //   'Oswald Variable': {},
  //   'Merriweather Sans': {},
  //   // Etc.
  // };
  // const fontGrandstanderV = getGrandstanderPath(debug);
  // const fontOswaldV = getOswaldPath(debug);
  // addFontPreloadLink(fontGrandstanderV);
  // addFontPreloadLink(fontOswaldV);
  // document.head.appendChild(link);
  // loadAllFonts(fontData);
  // const grandstanderV = 'Grandstander-VariableFont_wght.ttf';
  // const oswaldV = 'Oswald-VariableFont_wght.ttf';
  // console.log(debug);
  // console.log(allfontsCss);
};

var getGrandstanderPath = function getGrandstanderPath(debug) {
  var fontV = 'Grandstander-VariableFont_wght.ttf';
  var pathTo = !debug ? '/nextjs-tailwind-googlefonts-selfhost-starter/static/fonts/google/grandstander/' + fontV : '/static/fonts/google/grandstander/' + fontV;
  return pathTo;
};

var getOswaldPath = function getOswaldPath(debug) {
  var fontV = 'Oswald-VariableFont_wght.ttf';
  var pathTo = !debug ? '/nextjs-tailwind-googlefonts-selfhost-starter/static/fonts/google/oswald/' + fontV : '/static/fonts/google/oswald/' + fontV;
  return pathTo;
};

var LoadTheFonts = function LoadTheFonts() {
  var one = new FontFaceObserver('Grandstander Variable');
  var two = new FontFaceObserver('Oswald Variable');
  var three = new FontFaceObserver('Merriweather Sans');
  Promise.all([one.load(), two.load(), three.load()]).then(function () {
    console.log('The critical fonts are have loaded');
  })["catch"](function (err) {
    console.warn('Some critical font are not available:', err);
  });
}; // const loadAllFonts = (fontData) => {
//   let observers = [];
//   Object.keys(fontData).forEach((family) => {
//     const data = fontData[family];
//     const obs = new FontFaceObserver(family, data);
//     observers.push(obs.load());
//   });
//   Promise.all(observers)
//     .then((fonts) => {
//       (<fonts className="foreach"></fonts>)((font) => {
//         console.log(font.family + ' loaded');
//         // Map the result of the Promise back to our existing data,
//         // to get the other properties we need.
//         console.log(fontData[font.family]);
//       });
//     })
//     .catch((err) => {
//       console.warn('Some critical font are not available:', err);
//     });
// };


_c = LoadTheFonts;

var addFontPreloadLink = function addFontPreloadLink(fontLink) {
  var flink = document.createElement('link');
  flink.href = fontLink;
  flink.rel = 'preload';
  flink.as = 'font';
  flink.type = 'font/ttf';
  flink.crossOrigin = 'anonymous';
  document.head.appendChild(flink);
  console.log("Font preloaded: ".concat(fontLink));
};

var _c;

$RefreshReg$(_c, "LoadTheFonts");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/fontfaceobserver/fontfaceobserver.standalone.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fontfaceobserver/fontfaceobserver.standalone.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Font Face Observer v2.1.0 - © Bram Stein. License: BSD-3-Clause */(function(){function l(a,b){document.addEventListener?a.addEventListener("scroll",b,!1):a.attachEvent("scroll",b)}function m(a){document.body?a():document.addEventListener?document.addEventListener("DOMContentLoaded",function c(){document.removeEventListener("DOMContentLoaded",c);a()}):document.attachEvent("onreadystatechange",function k(){if("interactive"==document.readyState||"complete"==document.readyState)document.detachEvent("onreadystatechange",k),a()})};function t(a){this.a=document.createElement("div");this.a.setAttribute("aria-hidden","true");this.a.appendChild(document.createTextNode(a));this.b=document.createElement("span");this.c=document.createElement("span");this.h=document.createElement("span");this.f=document.createElement("span");this.g=-1;this.b.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";this.c.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
this.f.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";this.h.style.cssText="display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";this.b.appendChild(this.h);this.c.appendChild(this.f);this.a.appendChild(this.b);this.a.appendChild(this.c)}
function u(a,b){a.a.style.cssText="max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:"+b+";"}function z(a){var b=a.a.offsetWidth,c=b+100;a.f.style.width=c+"px";a.c.scrollLeft=c;a.b.scrollLeft=a.b.scrollWidth+100;return a.g!==b?(a.g=b,!0):!1}function A(a,b){function c(){var a=k;z(a)&&a.a.parentNode&&b(a.g)}var k=a;l(a.b,c);l(a.c,c);z(a)};function B(a,b){var c=b||{};this.family=a;this.style=c.style||"normal";this.weight=c.weight||"normal";this.stretch=c.stretch||"normal"}var C=null,D=null,E=null,F=null;function G(){if(null===D)if(J()&&/Apple/.test(window.navigator.vendor)){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent);D=!!a&&603>parseInt(a[1],10)}else D=!1;return D}function J(){null===F&&(F=!!document.fonts);return F}
function K(){if(null===E){var a=document.createElement("div");try{a.style.font="condensed 100px sans-serif"}catch(b){}E=""!==a.style.font}return E}function L(a,b){return[a.style,a.weight,K()?a.stretch:"","100px",b].join(" ")}
B.prototype.load=function(a,b){var c=this,k=a||"BESbswy",r=0,n=b||3E3,H=(new Date).getTime();return new Promise(function(a,b){if(J()&&!G()){var M=new Promise(function(a,b){function e(){(new Date).getTime()-H>=n?b(Error(""+n+"ms timeout exceeded")):document.fonts.load(L(c,'"'+c.family+'"'),k).then(function(c){1<=c.length?a():setTimeout(e,25)},b)}e()}),N=new Promise(function(a,c){r=setTimeout(function(){c(Error(""+n+"ms timeout exceeded"))},n)});Promise.race([N,M]).then(function(){clearTimeout(r);a(c)},
b)}else m(function(){function v(){var b;if(b=-1!=f&&-1!=g||-1!=f&&-1!=h||-1!=g&&-1!=h)(b=f!=g&&f!=h&&g!=h)||(null===C&&(b=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent),C=!!b&&(536>parseInt(b[1],10)||536===parseInt(b[1],10)&&11>=parseInt(b[2],10))),b=C&&(f==w&&g==w&&h==w||f==x&&g==x&&h==x||f==y&&g==y&&h==y)),b=!b;b&&(d.parentNode&&d.parentNode.removeChild(d),clearTimeout(r),a(c))}function I(){if((new Date).getTime()-H>=n)d.parentNode&&d.parentNode.removeChild(d),b(Error(""+
n+"ms timeout exceeded"));else{var a=document.hidden;if(!0===a||void 0===a)f=e.a.offsetWidth,g=p.a.offsetWidth,h=q.a.offsetWidth,v();r=setTimeout(I,50)}}var e=new t(k),p=new t(k),q=new t(k),f=-1,g=-1,h=-1,w=-1,x=-1,y=-1,d=document.createElement("div");d.dir="ltr";u(e,L(c,"sans-serif"));u(p,L(c,"serif"));u(q,L(c,"monospace"));d.appendChild(e.a);d.appendChild(p.a);d.appendChild(q.a);document.body.appendChild(d);w=e.a.offsetWidth;x=p.a.offsetWidth;y=q.a.offsetWidth;I();A(e,function(a){f=a;v()});u(e,
L(c,'"'+c.family+'",sans-serif'));A(p,function(a){g=a;v()});u(p,L(c,'"'+c.family+'",serif'));A(q,function(a){h=a;v()});u(q,L(c,'"'+c.family+'",monospace'))})})}; true?module.exports=B:(undefined);}());


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-tailwind-googlefonts-selfhost-starter%5Cpages%5Cindex.js!./":
/*!*******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-tailwind-googlefonts-selfhost-starter%5Cpages%5Cindex.js ***!
  \*******************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


      (window.__NEXT_P = window.__NEXT_P || []).push([
        "/",
        function () {
          return __webpack_require__(/*! ./pages/index.js */ "./pages/index.js");
        }
      ]);
    

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./node_modules/next/dist/client/use-intersection.js");

var prefetched = {};

function prefetch(router, href, as, options) {
  if ( false || !router) return;
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options)["catch"](function (err) {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  });
  var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character

  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;
}

function isModifiedEvent(event) {
  var target = event.currentTarget.target;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  var nodeName = e.currentTarget.nodeName;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browser’s default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow: shallow,
    locale: locale,
    scroll: scroll
  }).then(function (success) {
    if (!success) return;

    if (scroll) {
      // FIXME: proper route announcing at Router level, not Link:
      document.body.focus();
    }
  });
}

function Link(props) {
  _s();

  if (true) {
    var createPropError = function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + (true ? "\nOpen your browser's console to view the Component stack trace." : undefined));
    }; // TypeScript trick for type-guarding:


    var requiredPropsGuard = {
      href: true
    };
    var requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(function (key) {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // TypeScript trick for type-guarding:

    var optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    var optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(function (key) {
      var valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key: key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key: key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    var hasWarned = _react["default"].useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  var p = props.prefetch !== false;
  var router = (0, _router2.useRouter)();
  var pathname = router && router.pathname || '/';

  var _react$default$useMem = _react["default"].useMemo(function () {
    var _ref = (0, _router.resolveHref)(pathname, props.href, true),
        _ref2 = _slicedToArray(_ref, 2),
        resolvedHref = _ref2[0],
        resolvedAs = _ref2[1];

    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]),
      href = _react$default$useMem.href,
      as = _react$default$useMem.as;

  var children = props.children,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll,
      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react["default"].createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  var child = _react.Children.only(children);

  var childRef = child && typeof child === 'object' && child.ref;

  var _ref3 = (0, _useIntersection.useIntersection)({
    rootMargin: '200px'
  }),
      _ref4 = _slicedToArray(_ref3, 2),
      setIntersectionRef = _ref4[0],
      isVisible = _ref4[1];

  var setRef = _react["default"].useCallback(function (el) {
    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {
        childRef.current = el;
      }
    }
  }, [childRef, setIntersectionRef]);

  (0, _react.useEffect)(function () {
    var shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];

    if (shouldPrefetch && !isPrefetched) {
      prefetch(router, href, as, {
        locale: curLocale
      });
    }
  }, [as, href, isVisible, locale, p, router]);
  var childProps = {
    ref: setRef,
    onClick: function onClick(e) {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  childProps.onMouseEnter = function (e) {
    if (!(0, _router.isLocalURL)(href)) return;

    if (child.props && typeof child.props.onMouseEnter === 'function') {
      child.props.onMouseEnter(e);
    }

    prefetch(router, href, as, {
      priority: true
    });
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    var localeDomain = (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);
    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react["default"].cloneElement(child, childProps);
}

_s(Link, "7cX92ILFgstKFyzTMH+g73G4t5k=");

_c = Link;
var _default = Link;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

var _default = requestIdleCallback;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports["default"] = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js")); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


var MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  var entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  var resolver;
  var prom = new Promise(function (resolve) {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(function (value) {
    return resolver(value), value;
  }) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

var canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise(function (res, rej) {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

var ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise(function (resolve, reject) {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = function () {
      return reject(markAssetError(new Error("Failed to load script: ".concat(src))));
    }; // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
}

function idleTimeout(ms, err) {
  return new Promise(function (_resolve, reject) {
    return (0, _requestIdleCallback["default"])(function () {
      return setTimeout(function () {
        return reject(err);
      }, ms);
    });
  });
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  var onBuildManifest = new Promise(function (resolve) {
    // Mandatory because this is not concurrent safe:
    var cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = function () {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return Promise.race([onBuildManifest, idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')))]);
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute["default"])(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(function (manifest) {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    var allFiles = manifest[route].map(function (entry) {
      return assetPrefix + '/_next/' + encodeURI(entry);
    });
    return {
      scripts: allFiles.filter(function (v) {
        return v.endsWith('.js');
      }),
      css: allFiles.filter(function (v) {
        return v.endsWith('.css');
      })
    };
  });
}

function createRouteLoader(assetPrefix) {
  var entrypoints = new Map();
  var loadedScripts = new Map();
  var styleSheets = new Map();
  var routes = new Map();

  function maybeExecuteScript(src) {
    var prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    var prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(function (res) {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(function (text) {
        return {
          href: href,
          content: text
        };
      });
    })["catch"](function (err) {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint: function whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },
    onEntrypoint: function onEntrypoint(route, execute) {
      Promise.resolve(execute).then(function (fn) {
        return fn();
      }).then(function (exports) {
        return {
          component: exports && exports["default"] || exports,
          exports: exports
        };
      }, function (err) {
        return {
          error: err
        };
      }).then(function (input) {
        var old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },
    loadRoute: function loadRoute(route) {
      var _this = this;

      return withFuture(route, routes, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _yield$getFilesForRou, scripts, css, _yield$Promise$all, _yield$Promise$all2, styles, entrypoint, res;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return getFilesForRoute(assetPrefix, route);

              case 3:
                _yield$getFilesForRou = _context.sent;
                scripts = _yield$getFilesForRou.scripts;
                css = _yield$getFilesForRou.css;
                _context.next = 8;
                return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);

              case 8:
                _yield$Promise$all = _context.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                styles = _yield$Promise$all2[1];
                _context.next = 13;
                return Promise.race([_this.whenEntrypoint(route), idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route))))]);

              case 13:
                entrypoint = _context.sent;
                res = Object.assign({
                  styles: styles
                }, entrypoint);
                return _context.abrupt("return", 'error' in entrypoint ? entrypoint : res);

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 18]]);
      })));
    },
    prefetch: function prefetch(route) {
      var _this2 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(function (output) {
        return Promise.all(canPrefetch ? output.scripts.map(function (script) {
          return prefetchViaDom(script, 'script');
        }) : []);
      }).then(function () {
        (0, _requestIdleCallback["default"])(function () {
          return _this2.loadRoute(route);
        });
      })["catch"]( // swallow prefetch errors
      function () {});
    }
  };
}

var _default = createRouteLoader;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js"));

var hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection(_ref) {
  var rootMargin = _ref.rootMargin,
      disabled = _ref.disabled;
  var isDisabled = disabled || !hasIntersectionObserver;
  var unobserve = (0, _react.useRef)();

  var _ref2 = (0, _react.useState)(false),
      _ref3 = _slicedToArray(_ref2, 2),
      visible = _ref3[0],
      setVisible = _ref3[1];

  var setRef = (0, _react.useCallback)(function (el) {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, function (isVisible) {
        return isVisible && setVisible(isVisible);
      }, {
        rootMargin: rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react.useEffect)(function () {
    if (!hasIntersectionObserver) {
      if (!visible) (0, _requestIdleCallback["default"])(function () {
        return setVisible(true);
      });
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  var _createObserver = createObserver(options),
      id = _createObserver.id,
      observer = _createObserver.observer,
      elements = _createObserver.elements;

  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements["delete"](element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers["delete"](id);
    }
  };
}

var observers = new Map();

function createObserver(options) {
  var id = options.rootMargin || '';
  var instance = observers.get(id);

  if (instance) {
    return instance;
  }

  var elements = new Map();
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      var callback = elements.get(entry.target);
      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id: id,
    observer: observer,
    elements: elements
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var AmpStateContext = /*#__PURE__*/_react["default"].createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isInAmpMode() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ampFirst = _ref.ampFirst,
      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,
      _ref$hybrid = _ref.hybrid,
      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,
      _ref$hasQuery = _ref.hasQuery,
      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;

  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react["default"].useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = /*#__PURE__*/_react["default"].createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead() {
  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var head = [/*#__PURE__*/_react["default"].createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react["default"].createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react["default"].Fragment) {
    return list.concat(_react["default"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

var METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  var keys = new Set();
  var tags = new Set();
  var metaTypes = new Set();
  var metaCategories = {};
  return function (h) {
    var isUnique = true;
    var hasKey = false;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      hasKey = true;
      var key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new Set();

            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce(function (list, headElement) {
    var headElementChildren = _react["default"].Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {
    var key = c.key || i;

    if (false) { var newProps; }

    return /*#__PURE__*/_react["default"].cloneElement(c, {
      key: key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head(_ref) {
  var children = _ref.children;
  var ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  var headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react["default"].createElement(_sideEffect["default"], {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
} // TODO: Remove in the next major release


_c = Head;

Head.rewind = function () {};

var _default = Head;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  var detectedLocale; // first item will be empty string from splitting at first char

  var pathnameParts = pathname.split('/');
  (locales || []).some(function (locale) {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname: pathname,
    detectedLocale: detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.getDomainLocale = getDomainLocale;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports["default"] = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var detectDomainLocale;

if (false) {}

var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(pathNoQueryHash(path) === '/' ? path.substring(1) : path) : path;
}

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) { var detectedDomain; }

  return false;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function pathNoQueryHash(path) {
  var queryIndex = path.indexOf('?');
  var hashIndex = path.indexOf('#');

  if (queryIndex > -1 || hashIndex > -1) {
    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);
  }

  return path;
}

function hasBasePath(path) {
  path = pathNoQueryHash(path);
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  path = path.slice(basePath.length);
  if (!path.startsWith('/')) path = "/".concat(path);
  return path;
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just
    // path delimiter escaped since they are being inserted
    // into the URL and we expect URL encoded segments
    // when parsing dynamic route params
    function (segment) {
      return encodeURIComponent(segment);
    }).join('/') : encodeURIComponent(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base = new URL(currentPath, 'http://n');
  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function stripOrigin(url) {
  var origin = (0, _utils.getLocationOrigin)();
  return url.startsWith(origin) ? url.substring(origin.length) : url;
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  var _resolveHref = resolveHref(router.pathname, url, true),
      _resolveHref2 = _slicedToArray(_resolveHref, 2),
      resolvedHref = _resolveHref2[0],
      resolvedAs = _resolveHref2[1];

  var origin = (0, _utils.getLocationOrigin)();
  var hrefHadOrigin = resolvedHref.startsWith(origin);
  var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
  resolvedHref = stripOrigin(resolvedHref);
  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
  var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);
  var preparedAs = as ? stripOrigin(resolveHref(router.pathname, as)) : resolvedAs || resolvedHref;
  return {
    url: preparedUrl,
    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)
  };
}

var manualScrollRestoration =  false && false;
var SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        return res.json().then(function (data) {
          if (data.notFound) {
            return {
              notFound: SSG_DATA_NOT_FOUND
            };
          }

          throw new Error("Failed to load static props");
        });
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale,
        domainLocales = _ref.domainLocales;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;
    this.domainLocales = void 0;
    this.isReady = void 0;
    this._idx = 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var forcedScroll;
      var url = state.url,
          as = state.as,
          options = state.options,
          idx = state.idx;

      if (false) { var v; }

      _this._idx = idx;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }), forcedScroll);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        initial: true,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    var autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;

    this.asPath = autoExportDynamic ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;
    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search);

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale: locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) {}
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (false) {}

      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options, forcedScroll) {
        var _this2 = this;

        var _options$scroll, localeChange, parsedAs, localePathResult, didNavigate, _this$locales, detectedDomain, asNoBasePath, _options$shallow, shallow, routeProps, cleanedAs, parsed, _parsed, pathname, query, pages, rewrites, _yield, route, resolvedAs, potentialHref, _parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, routeInfo, _routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, appComp;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                // for static pages with query params in the URL we delay
                // marking the router ready until after the query is updated
                if (options._h) {
                  this.isReady = true;
                } // Default to scroll reset behavior unless explicitly specified to be
                // `false`! This makes the behavior between using `Router#push` and a
                // `<Link />` consistent.


                options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);
                localeChange = options.locale !== this.locale;

                if (true) {
                  _context.next = 18;
                  break;
                }

                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;

                if (typeof options.locale === 'undefined') {
                  options.locale = this.locale;
                }

                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(hasBasePath(as) ? delBasePath(as) : as);
                localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(parsedAs.pathname, this.locales);

                if (localePathResult.detectedLocale) {
                  this.locale = localePathResult.detectedLocale;
                  parsedAs.pathname = addBasePath(parsedAs.pathname);
                  as = (0, _utils.formatWithValidation)(parsedAs);
                  url = addBasePath((0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);
                }

                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale); // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                if (!didNavigate) {
                  _context.next = 18;
                  break;
                }

                return _context.abrupt("return", new Promise(function () {}));

              case 18:
                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow;
                routeProps = {
                  shallow: shallow
                };

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute, routeProps);
                }

                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 34;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route], null);
                Router.events.emit('hashChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 34:
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed = parsed, pathname = _parsed.pathname, query = _parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages
                // get their query parameters to allow ensuring they can be parsed properly
                // when rewritten to

                _context.prev = 36;
                _context.next = 39;
                return this.pageLoader.getPageList();

              case 39:
                pages = _context.sent;
                _context.next = 42;
                return (0, _routeLoader.getClientBuildManifest)();

              case 42:
                _yield = _context.sent;
                rewrites = _yield.__rewrites;
                _context.next = 50;
                break;

              case 46:
                _context.prev = 46;
                _context.t0 = _context["catch"](36);
                // If we fail to resolve the page list or client-build manifest, we must
                // do a server-side transition:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 50:
                parsed = this._resolveHref(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1


                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url

                if (!this.urlIsNew(cleanedAs) && !localeChange) {
                  method = 'replaceState';
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly

                resolvedAs = as;

                if ( true && as.startsWith('/')) {
                  resolvedAs = (0, _resolveRewrites["default"])(addBasePath(addLocale(delBasePath((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname), this.locale)), pages, rewrites, query, function (p) {
                    return _this2._resolveHref({
                      pathname: p
                    }, pages).pathname;
                  }, this.locales);

                  if (resolvedAs !== as) {
                    potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
                      pathname: (0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(resolvedAs) ? delBasePath(resolvedAs) : resolvedAs, this.locales).pathname
                    }), pages, false).pathname); // if this directly matches a page we need to update the href to
                    // allow the correct page chunk to be loaded

                    if (pages.includes(potentialHref)) {
                      route = potentialHref;
                      pathname = potentialHref;
                      parsed.pathname = pathname;
                      url = (0, _utils.formatWithValidation)(parsed);
                    }
                  }
                }

                if (isLocalURL(as)) {
                  _context.next = 62;
                  break;
                }

                if (false) {}

                throw new Error("Invalid href: \"".concat(url, "\" and as: \"").concat(as, "\", received relative href and external as") + "\nSee more info: https://err.sh/next.js/invalid-relative-url-external-as");

              case 60:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 62:
                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 78;
                  break;
                }

                _parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = _parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 77;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 75;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 75:
                _context.next = 78;
                break;

              case 77:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, _parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 78:
                Router.events.emit('routeChangeStart', as, routeProps);
                _context.prev = 79;
                _context.next = 82;
                return this.getRouteInfo(route, pathname, query, addBasePath(addLocale(resolvedAs, this.locale)), routeProps);

              case 82:
                routeInfo = _context.sent;
                _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props)) {
                  _context.next = 108;
                  break;
                }

                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 95;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 93;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

                this._resolveHref(parsedHref, pages, false);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 93;
                  break;
                }

                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;
                return _context.abrupt("return", this.change(method, newUrl, newAs, options));

              case 93:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 95:
                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {
                  _context.next = 108;
                  break;
                }

                _context.prev = 96;
                _context.next = 99;
                return this.fetchComponent('/404');

              case 99:
                notFoundRoute = '/404';
                _context.next = 105;
                break;

              case 102:
                _context.prev = 102;
                _context.t1 = _context["catch"](96);
                notFoundRoute = '/_error';

              case 105:
                _context.next = 107;
                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, {
                  shallow: false
                });

              case 107:
                routeInfo = _context.sent;

              case 108:
                Router.events.emit('beforeHistoryChange', as, routeProps);
                this.changeState(method, url, as, options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                }

                _context.next = 113;
                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (options.scroll ? {
                  x: 0,
                  y: 0
                } : null))["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 113:
                if (!error) {
                  _context.next = 116;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);
                throw error;

              case 116:
                if (false) {}

                Router.events.emit('routeChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 121:
                _context.prev = 121;
                _context.t2 = _context["catch"](79);

                if (!_context.t2.cancelled) {
                  _context.next = 125;
                  break;
                }

                return _context.abrupt("return", false);

              case 125:
                throw _context.t2;

              case 126:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[36, 46], [79, 121], [96, 102]]);
      }));

      function change(_x, _x2, _x3, _x4, _x5) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true,
          idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, routeProps, loadErrorFail) {
        var Component, styleSheets, props, _yield$this$fetchComp, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!((0, _routeLoader.isAssetError)(err) || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;

                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 14;
                  break;
                }

                ;
                _context2.next = 11;
                return this.fetchComponent('/_error');

              case 11:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;

              case 14:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: err,
                  error: err
                };

                if (routeInfo.props) {
                  _context2.next = 26;
                  break;
                }

                _context2.prev = 16;
                _context2.next = 19;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 19:
                routeInfo.props = _context2.sent;
                _context2.next = 26;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](16);
                console.error('Error in error page `getInitialProps`: ', _context2.t0);
                routeInfo.props = {};

              case 26:
                return _context2.abrupt("return", routeInfo);

              case 29:
                _context2.prev = 29;
                _context2.t1 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t1, pathname, query, as, routeProps, true));

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 29], [16, 22]]);
      }));

      function handleRouteInfoError(_x6, _x7, _x8, _x9, _x10, _x11) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as, routeProps) {
        var _this3 = this;

        var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, _require, isValidElementType, dataHref, props;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                existingRouteInfo = this.components[route];

                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", existingRouteInfo);

              case 4:
                cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;

                if (!cachedRouteInfo) {
                  _context3.next = 9;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 12;
                break;

              case 9:
                _context3.next = 11;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 11:
                _context3.t0 = _context3.sent;

              case 12:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 18;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 18:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), delBasePath(as), __N_SSG, this.locale);
                }

                _context3.next = 21;
                return this._getData(function () {
                  return __N_SSG ? _this3._getStaticData(dataHref) : __N_SSP ? _this3._getServerData(dataHref) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as
                  });
                });

              case 21:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 27:
                _context3.prev = 27;
                _context3.t1 = _context3["catch"](0);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as, routeProps));

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 27]]);
      }));

      function getRouteInfo(_x12, _x13, _x14, _x15, _x16) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data, resetScroll) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data, resetScroll);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
  }, {
    key: "_resolveHref",
    value: function _resolveHref(parsedHref, pages) {
      var applyBasePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var pathname = parsedHref.pathname;
      var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

      if (cleanPathname === '/404' || cleanPathname === '/_error') {
        return parsedHref;
      } // handle resolving href for dynamic routes


      if (!pages.includes(cleanPathname)) {
        // eslint-disable-next-line array-callback-return
        pages.some(function (page) {
          if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
            parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
            return true;
          }
        });
      }

      parsedHref.pathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(parsedHref.pathname);
      return parsedHref;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var _this4 = this;

        var asPath,
            options,
            parsed,
            _parsed2,
            pathname,
            parsedAs,
            localePathResult,
            pages,
            route,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed2 = parsed, pathname = _parsed2.pathname;

                if (false) {}

                _context4.next = 7;
                return this.pageLoader.getPageList();

              case 7:
                pages = _context4.sent;
                parsed = this._resolveHref(parsed, pages, false);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // Prefetch is not supported in development mode because it would trigger on-demand-entries


                if (false) {}

                return _context4.abrupt("return");

              case 12:
                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _context4.next = 15;
                return Promise.all([this.pageLoader._isSsg(url).then(function (isSsg) {
                  return isSsg ? _this4._getStaticData(_this4.pageLoader.getDataHref(url, asPath, true, typeof options.locale !== 'undefined' ? options.locale : _this4.locale)) : false;
                }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x17) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x18) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this6 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this6.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      return fetchNextData(dataHref, this.isSsr);
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as, routeProps) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data, resetScroll) {
      return this.sub(data, this.components['/_app'].Component, resetScroll);
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  var globalBase = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
  var resolvedBase = base ? new URL(base, globalBase) : globalBase;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin;

  if (origin !== globalBase.origin) {
    throw new Error("invariant: invalid relative URL, router received ".concat(url));
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.pathToRegexp = exports["default"] = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

var customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = function _default() {
  var customRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (path) {
    var keys = [];
    var matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    var matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return function (pathname, params) {
      var res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        var _iterator = _createForOfIteratorHelper(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;

            // unnamed params should be removed as they
            // are not allowed to be used in the destination
            if (typeof key.name === 'number') {
              delete res.params[key.name];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports.compileNonPath = compileNonPath;
exports["default"] = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function compileNonPath(value, params) {
  if (!value.includes(':')) {
    return value;
  }

  for (var _i = 0, _Object$keys = Object.keys(params); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (value.includes(":".concat(key))) {
      value = value.replace(new RegExp(":".concat(key, "\\*"), 'g'), ":".concat(key, "--ESCAPED_PARAM_ASTERISKS")).replace(new RegExp(":".concat(key, "\\?"), 'g'), ":".concat(key, "--ESCAPED_PARAM_QUESTION")).replace(new RegExp(":".concat(key, "\\+"), 'g'), ":".concat(key, "--ESCAPED_PARAM_PLUS")).replace(new RegExp(":".concat(key, "(?!\\w)"), 'g'), "--ESCAPED_PARAM_COLON".concat(key));
    }
  }

  value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, '\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled
  // correctly

  return pathToRegexp.compile("/".concat(value), {
    validate: false
  })(params).substr(1);
}

function prepareDestination(destination, params, query, appendParamsToQuery) {
  var parsedDestination = {}; // clone query so we don't modify the original

  query = Object.assign({}, query);
  var hadLocale = query.__nextLocale;
  delete query.__nextLocale;
  delete query.__nextDefaultLocale;

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    var _URL = new URL(destination),
        pathname = _URL.pathname,
        searchParams = _URL.searchParams,
        hash = _URL.hash,
        hostname = _URL.hostname,
        port = _URL.port,
        protocol = _URL.protocol,
        search = _URL.search,
        href = _URL.href;

    parsedDestination = {
      pathname: pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash: hash,
      protocol: protocol,
      hostname: hostname,
      port: port,
      search: search,
      href: href
    };
  }

  var destQuery = parsedDestination.query;
  var destPath = "".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');
  var destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  var destPathParams = destPathParamKeys.map(function (key) {
    return key.name;
  });
  var destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  var newUrl; // update any params in query values

  for (var _i2 = 0, _Object$entries = Object.entries(destQuery); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        strOrArray = _Object$entries$_i[1];

    var value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = compileNonPath(value, params);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  var paramKeys = Object.keys(params); // remove internal param for i18n

  if (hadLocale) {
    paramKeys = paramKeys.filter(function (name) {
      return name !== 'nextInternalLocale';
    });
  }

  if (appendParamsToQuery && !paramKeys.some(function (key) {
    return destPathParams.includes(key);
  })) {
    var _iterator = _createForOfIteratorHelper(paramKeys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;

        if (!(_key in destQuery)) {
          destQuery[_key] = params[_key];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  try {
    newUrl = destinationCompiler(params);

    var _newUrl$split = newUrl.split('#'),
        _newUrl$split2 = _slicedToArray(_newUrl$split, 2),
        _pathname = _newUrl$split2[0],
        _hash = _newUrl$split2[1];

    parsedDestination.pathname = _pathname;
    parsedDestination.hash = "".concat(_hash ? '#' : '').concat(_hash || '');
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match");
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl: newUrl,
    parsedDestination: parsedDestination
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports["default"] = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var customRouteMatcher = (0, _pathMatch["default"])(true);

function resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {
  if (!pages.includes((0, _normalizeLocalePath.normalizeLocalePath)(asPath, locales).pathname)) {
    var _iterator = _createForOfIteratorHelper(rewrites),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var rewrite = _step.value;
        var matcher = customRouteMatcher(rewrite.source);
        var params = matcher(asPath);

        if (params) {
          if (!rewrite.destination) {
            // this is a proxied rewrite which isn't handled on the client
            break;
          }

          var destRes = (0, _prepareDestination["default"])(rewrite.destination, params, query, true);
          asPath = destRes.parsedDestination.pathname;
          Object.assign(query, destRes.parsedDestination.query);
          var fsPathname = (0, _normalizeLocalePath.normalizeLocalePath)((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath), locales).pathname;

          if (pages.includes(fsPathname)) {
            asPath = fsPathname; // check if we now match a page as this means we are done
            // resolving the rewrites

            break;
          } // check if we match a dynamic-route, if so we break the rewrites chain


          var resolvedHref = resolveHref(fsPathname);

          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            asPath = fsPathname;
            break;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return asPath;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _assertThisInitialized = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

exports.__esModule = true;
exports["default"] = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var isServer = false;

var _default = /*#__PURE__*/function (_react$Component) {
  _inherits(_default, _react$Component);

  var _super = _createSuper(_default);

  function _default(props) {
    var _this;

    _classCallCheck(this, _default);

    _this = _super.call(this, props);
    _this._hasHeadManager = void 0;

    _this.emitChange = function () {
      if (_this._hasHeadManager) {
        _this.props.headManager.updateHead(_this.props.reduceComponentsToState(_toConsumableArray(_this.props.headManager.mountedInstances), _this.props));
      }
    };

    _this._hasHeadManager = _this.props.headManager && _this.props.headManager.mountedInstances;

    if (isServer && _this._hasHeadManager) {
      _this.props.headManager.mountedInstances.add(_assertThisInitialized(_this));

      _this.emitChange();
    }

    return _this;
  }

  _createClass(_default, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances.add(this);
      }

      this.emitChange();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.emitChange();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances["delete"](this);
      }

      this.emitChange();
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return _default;
}(_react.Component);

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) != null && _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/next-server/lib/head */ "./node_modules/next/dist/next-server/lib/head.js")


/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: homepage, name, description, version, private, author, repository, license, scripts, prettier, dependencies, devDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"homepage\":\"https://dtro-devuk.github.io/nextjs-tailwind-googlefonts-selfhost-starter/\",\"name\":\"nextjs-tailwind-googlefonts-selfhost\",\"description\":\"Nextjs v10 and tailwind css v2.0 starter template, with google fonts self-hosted and optimised.\",\"version\":\"0.1.0\",\"private\":false,\"author\":{\"name\":\"dtro-devuk\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/dtro-devuk/nextjs-tailwind-googlefonts-selfhost-starter\"},\"license\":\"MIT\",\"scripts\":{\"dev\":\"next dev\",\"build\":\"next build\",\"start\":\"next start\",\"deploy-local\":\"next build && next export\",\"deploy-localws\":\"next build && next export && npx serve out\",\"deploy-gp\":\"touch out/.nojekyll && git add -f out/ && git commit -m \\\"Deploy gh-pages\\\" && git subtree push --prefix out origin gh-pages\"},\"prettier\":{\"arrowParens\":\"always\",\"singleQuote\":true,\"tabWidth\":2,\"printWidth\":100,\"trailingComma\":\"es5\",\"useTabs\":false,\"semi\":true,\"bracketSpacing\":true},\"dependencies\":{\"next\":\"10.0.5\",\"next-compose-plugins\":\"^2.2.0\",\"react\":\"17.0.1\",\"react-dom\":\"17.0.1\",\"tailwindcss\":\"^2.0.2\"},\"devDependencies\":{\"autoprefixer\":\"^10.2.3\",\"file-loader\":\"^6.2.0\",\"fontfaceobserver\":\"^2.1.0\",\"postcss\":\"^8.2.4\",\"postcss-flexbugs-fixes\":\"^5.0.2\",\"postcss-preset-env\":\"^6.7.0\",\"prettier\":\"^2.2.1\",\"prop-types\":\"^15.7.2\",\"rimraf\":\"^3.0.2\",\"tailwindcss\":\"^2.0.2\"}}");

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_hooks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/hooks.js */ "./lib/hooks.js");
/* harmony import */ var _components_Container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Container */ "./components/Container.js");
/* harmony import */ var _components_LicenseBanner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/LicenseBanner */ "./components/LicenseBanner.js");



var _jsxFileName = "D:\\WorkArea\\GitHub\\nextjs-tailwind-googlefonts-selfhost-starter\\pages\\index.js",
    _this = undefined,
    _s = $RefreshSig$();







var Home = function Home() {
  _s();

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])(false),
      isMounted = _useState[0],
      setIsMounted = _useState[1];

  var googleLicenseInfo = _components_Container__WEBPACK_IMPORTED_MODULE_3__["licenseInfo"];

  if (isMounted) {
    Object(_lib_hooks_js__WEBPACK_IMPORTED_MODULE_2__["useGoogleFontLoader"])();
  }

  Object(react__WEBPACK_IMPORTED_MODULE_1__["useEffect"])(function () {
    setIsMounted(true); // Set to true when the component is mounted
  }, []);
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Container__WEBPACK_IMPORTED_MODULE_3__["default"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_LicenseBanner__WEBPACK_IMPORTED_MODULE_4__["default"], {
        licenseInfo: googleLicenseInfo
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 23,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h1", {
        role: "heading",
        "aria-level": "1",
        className: " p-3 text-center text-red-900 font-black text-xl",
        children: "The Sample Fonts follow..."
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 24,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("hr", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h2", {
        role: "heading",
        "aria-level": "2",
        className: " p-3 text-center text-blue-900 font-bold",
        children: "Sans Examples"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 33,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        className: "font-sans font-normal p-3 text-center text-gray-900",
        children: "Font Sans Serif - Oswald (400)"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 36,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        className: "font-sans font-bold p-3 text-center text-gray-900",
        children: "Font Sans Serif - Oswald (700)"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        className: "font-serif font-normal p-3 text-center text-gray-900",
        children: "Font Sans - Merriweather Regular (400)"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 42,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        className: "font-serif font-bold p-3 text-center text-gray-900",
        children: "Font Sans - Merriweather Bold (700)"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 45,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("hr", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 48,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h2", {
        role: "heading",
        "aria-level": "2",
        className: "font-sans p-3 text-center text-blue-900 text-xl",
        children: "Variable Fonts"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 50,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h3", {
        role: "heading",
        "aria-level": "3",
        className: "italic font-Grandstander-VariableFont p-3 text-center text-blue-900 font-bold",
        children: "Grandstander Fonts 100-900"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 58,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "text-center",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-thin",
          children: "Grandstander V 100"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 66,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 67,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-extra light",
          children: "Grandstander V 200"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 68,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 69,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-light",
          children: "Grandstander V 300"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 70,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 71,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-normal",
          children: "Grandstander V 400"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 72,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 73,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-medium",
          children: "Grandstander V 500"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 74,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 75,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-semibold",
          children: "Grandstander V 600"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 76,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 77,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-bold",
          children: "Grandstander V 700"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 78,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 79,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-extrabold",
          children: "Grandstander V 800"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 80,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 81,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-Grandstander-VariableFont font-black",
          children: "Grandstander V 900"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 82,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 83,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h3", {
          role: "heading",
          "aria-level": "3",
          className: "font-sans p-3 text-center text-blue-900 font-bold",
          children: "Oswald Fonts 100-900"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 85,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-thin",
          children: "Oswald V 100"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 93,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 94,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-extra light",
          children: "Oswald V 200"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 95,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 96,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-light",
          children: "Oswald V 300"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 97,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 98,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-normal",
          children: "Oswald V 400"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 99,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 100,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-medium",
          children: "Oswald V 500"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 101,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 102,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-semibold",
          children: "Oswald V 600"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 103,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 104,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-bold",
          children: "Oswald V 700"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 105,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 106,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-extrabold",
          children: "Oswald V 800"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 107,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 108,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
          className: "font-sans font-black",
          children: "Oswald V 900"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 109,
          columnNumber: 11
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 110,
          columnNumber: 11
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 65,
        columnNumber: 9
      }, _this)]
    }, void 0, true)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 21,
    columnNumber: 5
  }, _this);
};

_s(Home, "g5X36j+IHZGm+dck8vkt26+pFOY=", false, function () {
  return [_lib_hooks_js__WEBPACK_IMPORTED_MODULE_2__["useGoogleFontLoader"]];
});

_c = Home;
/* harmony default export */ __webpack_exports__["default"] = (Home);

var _c;

$RefreshReg$(_c, "Home");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CWorkArea%5CGitHub%5Cnextjs-tailwind-googlefonts-selfhost-starter%5Cpages%5Cindex.js!./","webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BdmF0YXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ29udGFpbmVyLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9HaXRIdWJDb2RlTGluay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9IZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0hlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9MaWNlbnNlQmFubmVyLmpzIiwid2VicGFjazovL19OX0UvLi9saWIvaG9va3MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY29uc3RydWN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZm9udGZhY2VvYnNlcnZlci9mb250ZmFjZW9ic2VydmVyLnN0YW5kYWxvbmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9saW5rLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvdXNlLWludGVyc2VjdGlvbi50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9taXR0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1tYXRjaC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcHJlcGFyZS1kZXN0aW5hdGlvbi50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3NpZGUtZWZmZWN0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9zZXJ2ZXIvZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC5qcyJdLCJuYW1lcyI6WyJBdmF0YXIiLCJjbGFzc05hbWUiLCJzaXRlVGl0bGUiLCJkZXNjcmlwdGlvbiIsInByb2ZpbGVOYW1lIiwibGljZW5zZUluZm8iLCJjb2RlTGlua1VybCIsIkNvbnRhaW5lciIsImNoaWxkcmVuIiwidmVyc2lvbkluZm8iLCJ2ZXJzaW9uIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwibm9kZSIsImlzUmVxdWlyZWQiLCJGb290ZXIiLCJjYXB0aW9uIiwiYXV0aG9yIiwiX19odG1sIiwic3RyaW5nIiwiR2l0SHViQ29kZUxpbmsiLCJpbk5ld1RhYiIsImJvb2wiLCJIZWFkIiwidGl0bGUiLCJIZWFkZXIiLCJMaWNlbnNlQmFubmVyIiwiRm9udEZhY2VPYnNlcnZlciIsInJlcXVpcmUiLCJ1c2VHb29nbGVGb250TG9hZGVyIiwiZGVidWciLCJiYXNlRm9udE9uZSIsImJhc2VGb250VHdvIiwibGlua09uZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJyZWwiLCJhcyIsInR5cGUiLCJjcm9zc09yaWdpbiIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImxpbmtUd28iLCJMb2FkVGhlRm9udHMiLCJnZXRHcmFuZHN0YW5kZXJQYXRoIiwiZm9udFYiLCJwYXRoVG8iLCJnZXRPc3dhbGRQYXRoIiwib25lIiwidHdvIiwidGhyZWUiLCJQcm9taXNlIiwiYWxsIiwibG9hZCIsInRoZW4iLCJjb25zb2xlIiwibG9nIiwiZXJyIiwid2FybiIsImFkZEZvbnRQcmVsb2FkTGluayIsImZvbnRMaW5rIiwiZmxpbmsiLCJwcmVmZXRjaGVkIiwicm91dGVyIiwiY3VyTG9jYWxlIiwib3B0aW9ucyIsImV2ZW50IiwidGFyZ2V0IiwiZSIsIm5vZGVOYW1lIiwiaXNNb2RpZmllZEV2ZW50Iiwic2Nyb2xsIiwicmVwbGFjZSIsInNoYWxsb3ciLCJsb2NhbGUiLCJzdWNjZXNzIiwiYXJncyIsImtleSIsImV4cGVjdGVkIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsInByb3BzIiwiY3JlYXRlUHJvcEVycm9yIiwiYWN0dWFsIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInBhc3NIcmVmIiwicHJlZmV0Y2giLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsIlJlYWN0IiwicCIsInBhdGhuYW1lIiwicmVzb2x2ZWRBcyIsImNoaWxkIiwiQ2hpbGRyZW4iLCJjaGlsZFJlZiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJlbCIsInNldEludGVyc2VjdGlvblJlZiIsInNob3VsZFByZWZldGNoIiwiaXNWaXNpYmxlIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsInJlZiIsIm9uQ2xpY2siLCJsaW5rQ2xpY2tlZCIsInByaW9yaXR5IiwibG9jYWxlRG9tYWluIiwiTGluayIsInBhdGgiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInByb2Nlc3MiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsInN0YXJ0IiwiRGF0ZSIsInNldFRpbWVvdXQiLCJjYiIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIk1TX01BWF9JRExFX0RFTEFZIiwiZW50cnkiLCJtYXAiLCJwcm9tIiwicmVzb2x2ZSIsInJlc29sdmVyIiwiZnV0dXJlIiwiZ2VuZXJhdG9yIiwidmFsdWUiLCJsaW5rIiwid2luZG93IiwiY2FuUHJlZmV0Y2giLCJoYXNQcmVmZXRjaCIsInJlcyIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJzY3JpcHQiLCJyZWplY3QiLCJtYXJrQXNzZXRFcnJvciIsIm9uQnVpbGRNYW5pZmVzdCIsImlkbGVUaW1lb3V0Iiwic2NyaXB0cyIsImFzc2V0UHJlZml4IiwiZW5jb2RlVVJJIiwiY3NzIiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsIm1hbmlmZXN0Iiwicm91dGUiLCJhbGxGaWxlcyIsInYiLCJlbnRyeXBvaW50cyIsImxvYWRlZFNjcmlwdHMiLCJzdHlsZVNoZWV0cyIsInJvdXRlcyIsImFwcGVuZFNjcmlwdCIsImZldGNoIiwidGV4dCIsImNvbnRlbnQiLCJ3aGVuRW50cnlwb2ludCIsIndpdGhGdXR1cmUiLCJvbkVudHJ5cG9pbnQiLCJmbiIsImV4cG9ydHMiLCJjb21wb25lbnQiLCJlcnJvciIsImlucHV0Iiwib2xkIiwibG9hZFJvdXRlIiwiZ2V0RmlsZXNGb3JSb3V0ZSIsImVudHJ5cG9pbnQiLCJzdHlsZXMiLCJjbiIsIm5hdmlnYXRvciIsIm91dHB1dCIsInByZWZldGNoVmlhRG9tIiwiY3JlYXRlUm91dGVMb2FkZXIiLCJzaW5nbGV0b25Sb3V0ZXIiLCJyZWFkeUNhbGxiYWNrcyIsInJlYWR5IiwidXJsUHJvcGVydHlGaWVsZHMiLCJyb3V0ZXJFdmVudHMiLCJjb3JlTWV0aG9kRmllbGRzIiwiZ2V0IiwiUm91dGVyIiwiZmllbGQiLCJnZXRSb3V0ZXIiLCJldmVudEZpZWxkIiwiX3NpbmdsZXRvblJvdXRlciIsIm1lc3NhZ2UiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVyIiwiX3JvdXRlciIsImluc3RhbmNlIiwiQXJyYXkiLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsImlzRGlzYWJsZWQiLCJkaXNhYmxlZCIsInVub2JzZXJ2ZSIsIm9ic2VydmUiLCJzZXRWaXNpYmxlIiwiY3JlYXRlT2JzZXJ2ZXIiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiaWQiLCJlbnRyaWVzIiwiY2FsbGJhY2siLCJDb21wb3NlZENvbXBvbmVudCIsImdldEluaXRpYWxQcm9wcyIsIldpdGhSb3V0ZXJXcmFwcGVyIiwibmFtZSIsIkFtcFN0YXRlQ29udGV4dCIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiLCJpc0luQW1wTW9kZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsImluQW1wTW9kZSIsImxpc3QiLCJmcmFnbWVudExpc3QiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5IiwiaSIsImxlbiIsIm1ldGF0eXBlIiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwiaGVhZEVsZW1lbnRzIiwiaGVhZEVsZW1lbnRDaGlsZHJlbiIsImhlYWRFbGVtZW50IiwiZGVmYXVsdEhlYWQiLCJ1bmlxdWUiLCJjIiwiYW1wU3RhdGUiLCJoZWFkTWFuYWdlciIsInBhdGhuYW1lUGFydHMiLCJsb2NhbGVzIiwiZGV0ZWN0ZWRMb2NhbGUiLCJvbiIsIm9mZiIsImVtaXQiLCJoYW5kbGVyIiwiYmFzZVBhdGgiLCJjYW5jZWxsZWQiLCJwcmVmaXgiLCJwYXRoTm9RdWVyeUhhc2giLCJxdWVyeUluZGV4IiwiaGFzaEluZGV4IiwiYWRkUGF0aFByZWZpeCIsInVybCIsImxvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJoYXNCYXNlUGF0aCIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwiYXNQYXRobmFtZSIsInBhcmFtcyIsInBhcmFtIiwicmVwbGFjZWQiLCJyZXBlYXQiLCJvcHRpb25hbCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXN1bHQiLCJmaWx0ZXJlZFF1ZXJ5IiwicXVlcnkiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJpc0xvY2FsVVJMIiwicmVzb2x2ZUFzIiwiZmluYWxVcmwiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJoYXNoIiwib21pdFBhcm1zRnJvbVF1ZXJ5IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIiwicmVzb2x2ZUhyZWYiLCJocmVmSGFkT3JpZ2luIiwiYXNIYWRPcmlnaW4iLCJzdHJpcE9yaWdpbiIsInByZXBhcmVkVXJsIiwiYWRkQmFzZVBhdGgiLCJwcmVwYXJlZEFzIiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJjcmVkZW50aWFscyIsImF0dGVtcHRzIiwiZmV0Y2hSZXRyeSIsImRhdGEiLCJub3RGb3VuZCIsImlzU2VydmVyUmVuZGVyIiwiY29uc3RydWN0b3IiLCJhc1BhdGgiLCJjb21wb25lbnRzIiwic2RjIiwic3ViIiwiY2xjIiwicGFnZUxvYWRlciIsIl9icHMiLCJldmVudHMiLCJfd3JhcEFwcCIsImlzU3NyIiwiaXNGYWxsYmFjayIsIl9pbkZsaWdodFJvdXRlIiwiX3NoYWxsb3ciLCJkZWZhdWx0TG9jYWxlIiwiZG9tYWluTG9jYWxlcyIsImlzUmVhZHkiLCJfaWR4Iiwic3RhdGUiLCJDb21wb25lbnQiLCJpbml0aWFsIiwiX19OX1NTRyIsImluaXRpYWxQcm9wcyIsIl9fTl9TU1AiLCJhdXRvRXhwb3J0RHluYW1pYyIsInJlbG9hZCIsInByZXBhcmVVcmxBcyIsImxvY2FsZUNoYW5nZSIsInBhcnNlZEFzIiwiZGVsQmFzZVBhdGgiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGlkTmF2aWdhdGUiLCJkZXRlY3RlZERvbWFpbiIsImRldGVjdERvbWFpbkxvY2FsZSIsIlNUIiwicGVyZm9ybWFuY2UiLCJyb3V0ZVByb3BzIiwiYWRkTG9jYWxlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwicGFyc2VkIiwicGFnZXMiLCJfX3Jld3JpdGVzIiwibWV0aG9kIiwicG90ZW50aWFsSHJlZiIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwic2hvdWxkSW50ZXJwb2xhdGUiLCJtaXNzaW5nUGFyYW1zIiwicm91dGVJbmZvIiwiZGVzdGluYXRpb24iLCJwYXJzZWRIcmVmIiwibm90Rm91bmRSb3V0ZSIsImFwcENvbXAiLCJmb3JjZWRTY3JvbGwiLCJ4IiwieSIsIl9fTiIsImlkeCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJwYWdlIiwiZXhpc3RpbmdSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJkYXRhSHJlZiIsIm9ubHlBSGFzaENoYW5nZSIsIm5ld0hhc2giLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwic2Nyb2xsVG9IYXNoIiwiaWRFbCIsIm5hbWVFbCIsInVybElzTmV3IiwiX3Jlc29sdmVIcmVmIiwiYXBwbHlCYXNlUGF0aCIsImNsZWFuUGF0aG5hbWUiLCJpc1NzZyIsImNhbmNlbCIsImNvbXBvbmVudFJlc3VsdCIsIl9nZXRTdGF0aWNEYXRhIiwiZmV0Y2hOZXh0RGF0YSIsIl9nZXRTZXJ2ZXJEYXRhIiwiQXBwVHJlZSIsImN0eCIsImFib3J0Q29tcG9uZW50TG9hZCIsIm5vdGlmeSIsInNsYXNoZWRQcm90b2NvbHMiLCJwcm90b2NvbCIsInVybE9iaiIsImhvc3QiLCJhdXRoIiwiaG9zdG5hbWUiLCJTdHJpbmciLCJxdWVyeXN0cmluZyIsInNlYXJjaCIsImV4dCIsIlRFU1RfUk9VVEUiLCJnbG9iYWxCYXNlIiwicmVzb2x2ZWRCYXNlIiwibWF0Y2hlck9wdGlvbnMiLCJzZW5zaXRpdmUiLCJkZWxpbWl0ZXIiLCJjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zIiwic3RyaWN0IiwiY3VzdG9tUm91dGUiLCJtYXRjaGVyUmVnZXgiLCJwYXRoVG9SZWdleHAiLCJtYXRjaGVyIiwidmFsaWRhdGUiLCJwYXJzZWREZXN0aW5hdGlvbiIsImhhZExvY2FsZSIsInBvcnQiLCJkZXN0UXVlcnkiLCJkZXN0UGF0aCIsImRlc3RQYXRoUGFyYW1LZXlzIiwiZGVzdFBhdGhQYXJhbXMiLCJkZXN0aW5hdGlvbkNvbXBpbGVyIiwic3RyT3JBcnJheSIsImNvbXBpbGVOb25QYXRoIiwicGFyYW1LZXlzIiwiYXBwZW5kUGFyYW1zVG9RdWVyeSIsIm5ld1VybCIsInNlYXJjaFBhcmFtcyIsImlzTmFOIiwiaXRlbSIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJzZWFyY2hQYXJhbXNMaXN0IiwiY3VzdG9tUm91dGVNYXRjaGVyIiwicmV3cml0ZSIsImRlc3RSZXMiLCJmc1BhdGhuYW1lIiwicmUiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzbHVnTmFtZSIsImciLCJncm91cHMiLCJtIiwic3RyIiwic2VnbWVudHMiLCJub3JtYWxpemVkUm91dGUiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwicGFyc2VQYXJhbWV0ZXIiLCJwb3MiLCJlc2NhcGVSZWdleCIsImlzU2VydmVyIiwiX2hhc0hlYWRNYW5hZ2VyIiwiZW1pdENoYW5nZSIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW5kZXIiLCJ1c2VkIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJBcHAiLCJnZXREaXNwbGF5TmFtZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJwYWdlUHJvcHMiLCJpc1Jlc1NlbnQiLCJ1cmxPYmplY3RLZXlzIiwiU1AiLCJIb21lIiwidXNlU3RhdGUiLCJpc01vdW50ZWQiLCJzZXRJc01vdW50ZWQiLCJnb29nbGVMaWNlbnNlSW5mbyIsInVzZUVmZmVjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxJQUFNQSxNQUFNLEdBQUcsU0FBVEEsTUFBUyxPQUFtQjtBQUFBLE1BQWhCQyxTQUFnQixRQUFoQkEsU0FBZ0I7QUFDaEMsc0JBQ0U7QUFDRSxXQUFPLEVBQUMsS0FEVjtBQUVFLE1BQUUsRUFBQyxTQUZMO0FBR0UsYUFBUyxFQUFFQSxTQUhiO0FBSUUsUUFBSSxFQUFDLE1BSlA7QUFLRSxXQUFPLEVBQUMseUJBTFY7QUFBQSw0QkFPRTtBQUFPLFFBQUUsRUFBQyxXQUFWO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBUEYsZUFRRTtBQUFVLFFBQUUsRUFBQztBQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFSRixlQVNFO0FBQU0sUUFBRSxFQUFDO0FBQVQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQVRGLGVBVUU7QUFDRSxXQUFLLEVBQUMsV0FEUjtBQUVFLFlBQU0sRUFBQyxXQUZUO0FBR0UseUJBQW1CLEVBQUMsTUFIdEI7QUFJRSxVQUFJLEVBQUMsNG1yUEFKUDtBQXFuR0UsUUFBRSxFQUFDO0FBcm5HTDtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBVkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBREY7QUFvb0dELENBcm9HRDs7S0FBTUQsTTtBQXVvR1NBLHFFQUFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3b0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Q0FHQTs7QUFDQTtBQUNBO0FBRU8sSUFBTUUsU0FBUyxHQUFHLGlFQUFsQjtBQUNBLElBQU1DLFdBQVcsR0FDdEIsNktBREs7QUFFQSxJQUFNQyxXQUFXLEdBQUcsWUFBcEI7QUFDQSxJQUFNQyxXQUFXLEdBQ3RCLHdPQURLO0FBRUEsSUFBTUMsV0FBVyxHQUN0Qiw0RUFESzs7QUFHUCxJQUFNQyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxPQUFrQjtBQUFBLE1BQWZDLFFBQWUsUUFBZkEsUUFBZTtBQUNsQyxNQUFNQyxXQUFXLEdBQUdDLHFEQUFwQjtBQUVBLHNCQUNFO0FBQUssTUFBRSxFQUFDLFdBQVI7QUFBb0IsYUFBUyxFQUFDLGFBQTlCO0FBQUEsNEJBQ0UscUVBQUMsd0RBQUQ7QUFBTSxXQUFLLEVBQUVSLFNBQWI7QUFBd0IsaUJBQVcsRUFBRUM7QUFBckM7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQURGLGVBRUUscUVBQUMsMERBQUQ7QUFDRSxhQUFPLEVBQUVELFNBRFg7QUFFRSxZQUFNLEVBQUVFLFdBRlY7QUFHRSxpQkFBVyxFQUFFRCxXQUhmO0FBSUUsaUJBQVcsRUFBRUUsV0FKZjtBQUtFLGlCQUFXLEVBQUVDO0FBTGY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUZGLGVBU0U7QUFDRSxRQUFFLEVBQUMsY0FETDtBQUVFLFVBQUksRUFBQyxNQUZQO0FBR0Usb0JBQVcsZ0NBSGI7QUFJRSxlQUFTLEVBQUMsZ0hBSlo7QUFBQSxnQkFVR0U7QUFWSDtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBVEYsZUFxQkUscUVBQUMsMERBQUQ7QUFDRSxhQUFPLEVBQUVOLFNBRFg7QUFFRSxZQUFNLEVBQUVFLFdBRlY7QUFHRSxpQkFBVyxFQUFFSyxXQUhmO0FBSUUsaUJBQVcsRUFBRUo7QUFKZjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBckJGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBOEJELENBakNEOztLQUFNRSxTO0FBbUNTQSx3RUFBZjtBQUVBQSxTQUFTLENBQUNJLFNBQVYsR0FBc0I7QUFDcEJILFVBQVEsRUFBRUksaURBQVMsQ0FBQ0MsSUFBVixDQUFlQztBQURMLENBQXRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBTUMsTUFBTSxHQUFHLFNBQVRBLE1BQVMsT0FBbUQ7QUFBQSxNQUFoREMsT0FBZ0QsUUFBaERBLE9BQWdEO0FBQUEsTUFBdkNQLFdBQXVDLFFBQXZDQSxXQUF1QztBQUFBLE1BQTFCUSxNQUEwQixRQUExQkEsTUFBMEI7QUFBQSxNQUFsQlosV0FBa0IsUUFBbEJBLFdBQWtCO0FBQ2hFLHNCQUNFO0FBQ0UsTUFBRSxFQUFDLGFBREw7QUFFRSxRQUFJLEVBQUMsYUFGUDtBQUdFLGtCQUFXLDBCQUhiO0FBSUUsYUFBUyxFQUFDLHFFQUpaO0FBQUEsMkJBUUU7QUFBSyxlQUFTLEVBQUMsc0JBQWY7QUFBQSw4QkFDRTtBQUFLLGlCQUFTLEVBQUMsMERBQWY7QUFBQSwrQkFDRTtBQUFHLG1CQUFTLEVBQUMsZ0JBQWI7QUFBQSxvQkFBK0JBO0FBQS9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBREYsZUFLRTtBQUFLLGlCQUFTLEVBQUMsZ0RBQWY7QUFBQSxnQ0FDRTtBQUFHLG1CQUFTLEVBQUMsc0NBQWI7QUFBQSxvQkFBcURXO0FBQXJEO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBREYsZUFFRTtBQUFBLGdEQUNZO0FBQU0sbUNBQXVCLEVBQUU7QUFBRUUsb0JBQU0sRUFBRTtBQUFWO0FBQS9CO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBRFosRUFDeUUsR0FEekUsZUFFRTtBQUNFLGdCQUFJLEVBQUMsbUNBRFA7QUFFRSxxQkFBUyxFQUFDLHlEQUZaO0FBS0Usa0JBQU0sRUFBQyxRQUxUO0FBTUUsZUFBRyxFQUFDLHFCQU5OO0FBQUEsc0JBUUdEO0FBUkg7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFGRixFQVdPLEdBWFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUZGLGVBZ0JFO0FBQUcsbUJBQVMsRUFBQyxxQkFBYjtBQUFBLGtDQUE2Q1IsV0FBN0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQWhCRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFMRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFSRjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBREY7QUFtQ0QsQ0FwQ0Q7O0tBQU1NLE07QUFzQ1NBLHFFQUFmO0FBRUFBLE1BQU0sQ0FBQ0osU0FBUCxHQUFtQjtBQUNqQkssU0FBTyxFQUFFSixpREFBUyxDQUFDTyxNQUFWLENBQWlCTCxVQURUO0FBRWpCTCxhQUFXLEVBQUVHLGlEQUFTLENBQUNPLE1BQVYsQ0FBaUJMLFVBRmI7QUFHakJULGFBQVcsRUFBRU8saURBQVMsQ0FBQ08sTUFBVixDQUFpQkw7QUFIYixDQUFuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQSxJQUFNTSxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLE9BQXdDO0FBQUEsTUFBckNkLFdBQXFDLFFBQXJDQSxXQUFxQztBQUFBLE1BQXhCZSxRQUF3QixRQUF4QkEsUUFBd0I7QUFBQSxNQUFkTCxPQUFjLFFBQWRBLE9BQWM7QUFDN0Qsc0JBQ0UscUVBQUMsZ0RBQUQ7QUFBTSxRQUFJLEVBQUVWLFdBQVo7QUFBQSwyQkFDRTtBQUNFLGVBQVMsbU5BRWUsc0RBRmYsQ0FEWDtBQUlFLFlBQU0sRUFBRWUsUUFBUSxHQUFHLFFBQUgsR0FBYyxPQUpoQztBQUtFLFNBQUcsRUFBQyxxQkFMTjtBQUFBLGdCQU9HTCxPQUFPLElBQUk7QUFQZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBYUQsQ0FkRDs7S0FBTUksYztBQWdCTkEsY0FBYyxDQUFDVCxTQUFmLEdBQTJCO0FBQ3pCTCxhQUFXLEVBQUVNLGlEQUFTLENBQUNPLE1BQVYsQ0FBaUJMLFVBREw7QUFFekJPLFVBQVEsRUFBRVQsaURBQVMsQ0FBQ1UsSUFBVixDQUFlUixVQUZBO0FBR3pCRSxTQUFPLEVBQUVKLGlEQUFTLENBQUNPO0FBSE0sQ0FBM0I7QUFNZUMsNkVBQWY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQU1HLElBQUksR0FBRyxTQUFQQSxJQUFPLE9BQTRCO0FBQUEsTUFBekJDLEtBQXlCLFFBQXpCQSxLQUF5QjtBQUFBLE1BQWxCckIsV0FBa0IsUUFBbEJBLFdBQWtCO0FBQ3ZDLHNCQUNFLHFFQUFDLGdEQUFEO0FBQUEsNEJBQ0U7QUFBTSxhQUFPLEVBQUM7QUFBZDtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBREYsZUFFRTtBQUFBLGdCQUFRcUI7QUFBUjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBRkYsZUFHRTtBQUFNLFVBQUksRUFBQyxhQUFYO0FBQXlCLGFBQU8sRUFBRXJCO0FBQWxDO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFIRixlQUlFO0FBQ0UsVUFBSSxFQUFDLFVBRFA7QUFFRSxhQUFPLEVBQUM7QUFGVjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBSkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBREY7QUFXRCxDQVpEOztLQUFNb0IsSTtBQWNTQSxtRUFBZjtBQUVBQSxJQUFJLENBQUNaLFNBQUwsR0FBaUI7QUFDZmEsT0FBSyxFQUFFWixpREFBUyxDQUFDTyxNQUFWLENBQWlCTCxVQURUO0FBRWZYLGFBQVcsRUFBRVMsaURBQVMsQ0FBQ08sTUFBVixDQUFpQkw7QUFGZixDQUFqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFNVyxNQUFNLEdBQUcsU0FBVEEsTUFBUyxPQUFtRDtBQUFBLE1BQWhEVCxPQUFnRCxRQUFoREEsT0FBZ0Q7QUFBQSxNQUF2Q0MsTUFBdUMsUUFBdkNBLE1BQXVDO0FBQUEsTUFBL0JkLFdBQStCLFFBQS9CQSxXQUErQjtBQUFBLE1BQWxCRyxXQUFrQixRQUFsQkEsV0FBa0I7QUFDaEUsc0JBQ0U7QUFDRSxNQUFFLEVBQUMsUUFETDtBQUVFLFFBQUksRUFBQyxRQUZQO0FBR0UsYUFBUyxFQUFDLHNFQUhaO0FBQUEsNEJBT0U7QUFDRSxlQUFTLEVBQUMsd0ZBRFo7QUFBQSxnQkFLR1U7QUFMSDtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBUEYsZUFjRTtBQUFLLGVBQVMsRUFBQyxRQUFmO0FBQUEsNkJBQ0UscUVBQUMsZ0RBQUQ7QUFBTSxZQUFJLEVBQUMsR0FBWDtBQUFBLCtCQUNFO0FBQUcsbUJBQVMsRUFBQyxtRUFBYjtBQUFBLGlDQUNFLHFFQUFDLDBEQUFEO0FBQ0UscUJBQVMsRUFBQztBQURaO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFkRixlQXlCRTtBQUFBLDZCQUNFLHFFQUFDLGdEQUFEO0FBQU0sWUFBSSxFQUFDLEdBQVg7QUFBQSwrQkFDRTtBQUFHLG1CQUFTLEVBQUMsbUVBQWI7QUFBQSxpQ0FDRTtBQUNFLHFCQUFTLEVBQUMsMEtBRFo7QUFBQSxzQkFPR0MsTUFBTSxJQUFJO0FBUGI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQXpCRixlQXlDRSxxRUFBQyxrRUFBRDtBQUNFLGFBQU8sRUFBRSx3QkFEWDtBQUVFLGlCQUFXLEVBQUVYLFdBRmY7QUFHRSxjQUFRLEVBQUU7QUFIWjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBekNGLGVBOENFO0FBQUssZUFBUyxFQUFDLDJCQUFmO0FBQUEsNkJBQ0U7QUFBUyxzQkFBVyxrQkFBcEI7QUFBQSwrQkFDRTtBQUFJLG1CQUFTLEVBQUMsMERBQWQ7QUFBQSxvQkFDR0gsV0FBVyxJQUFJO0FBRGxCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQTlDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERjtBQXdERCxDQXpERDs7S0FBTXNCLE07QUEyRFNBLHFFQUFmO0FBRUFBLE1BQU0sQ0FBQ2QsU0FBUCxHQUFtQjtBQUNqQkssU0FBTyxFQUFFSixpREFBUyxDQUFDTyxNQUFWLENBQWlCTCxVQURUO0FBRWpCRyxRQUFNLEVBQUVMLGlEQUFTLENBQUNPLE1BRkQ7QUFHakJoQixhQUFXLEVBQUVTLGlEQUFTLENBQUNPLE1BSE47QUFJakJiLGFBQVcsRUFBRU0saURBQVMsQ0FBQ08sTUFBVixDQUFpQkw7QUFKYixDQUFuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBLElBQU1ZLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsT0FBcUI7QUFBQSxNQUFsQnJCLFdBQWtCLFFBQWxCQSxXQUFrQjtBQUN6QyxzQkFDRTtBQUNFLE1BQUUsRUFBQyxnQkFETDtBQUVFLGtCQUFXLDZCQUZiO0FBR0UsYUFBUyxFQUFDLHdCQUhaO0FBQUEsMkJBS0U7QUFBSyxlQUFTLEVBQUMsWUFBZjtBQUFBLDZCQUNFO0FBQUssaUJBQVMsRUFBQyxtREFBZjtBQUFBLGdDQUNFO0FBQUksbUJBQVMsRUFBQyxpRUFBZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFERixlQUlFO0FBQUcsbUJBQVMsRUFBQyx3Q0FBYjtBQUFBLG9CQUF1REE7QUFBdkQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFKRixlQUtFO0FBQUcsbUJBQVMsRUFBQyxzQ0FBYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFMRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTEY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBb0JELENBckJEOztLQUFNcUIsYTtBQXVCTkEsYUFBYSxDQUFDZixTQUFkLEdBQTBCO0FBQ3hCTixhQUFXLEVBQUVPLGlEQUFTLENBQUNPLE1BQVYsQ0FBaUJMO0FBRE4sQ0FBMUI7QUFJZVksNEVBQWY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQyxnQkFBZ0IsR0FBR0MsbUJBQU8sQ0FBQyx3RkFBRCxDQUFoQzs7QUFFTyxJQUFNQyxtQkFBbUIsR0FBRyxTQUF0QkEsbUJBQXNCLEdBQU07QUFDdkMsTUFBTUMsS0FBSyxPQUFYO0FBRUEsTUFBTUMsV0FBVyxHQUFHLENBQUNELEtBQUQsR0FDaEIsbUhBRGdCLEdBRWhCLHNFQUZKO0FBSUEsTUFBTUUsV0FBVyxHQUFHLENBQUNGLEtBQUQsR0FDaEIsdUdBRGdCLEdBRWhCLDBEQUZKO0FBSUEsTUFBTUcsT0FBTyxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBaEI7QUFDQUYsU0FBTyxDQUFDRyxJQUFSLEdBQWVMLFdBQWY7QUFDQUUsU0FBTyxDQUFDSSxHQUFSLEdBQWMsU0FBZDtBQUNBSixTQUFPLENBQUNLLEVBQVIsR0FBYSxNQUFiO0FBQ0FMLFNBQU8sQ0FBQ00sSUFBUixHQUFlLFVBQWY7QUFDQU4sU0FBTyxDQUFDTyxXQUFSLEdBQXNCLFdBQXRCO0FBRUFOLFVBQVEsQ0FBQ08sSUFBVCxDQUFjQyxXQUFkLENBQTBCVCxPQUExQjtBQUVBLE1BQU1VLE9BQU8sR0FBR1QsUUFBUSxDQUFDQyxhQUFULENBQXVCLE1BQXZCLENBQWhCO0FBQ0FRLFNBQU8sQ0FBQ1AsSUFBUixHQUFlSixXQUFmO0FBQ0FXLFNBQU8sQ0FBQ04sR0FBUixHQUFjLFNBQWQ7QUFDQU0sU0FBTyxDQUFDTCxFQUFSLEdBQWEsTUFBYjtBQUNBSyxTQUFPLENBQUNKLElBQVIsR0FBZSxVQUFmO0FBQ0FJLFNBQU8sQ0FBQ0gsV0FBUixHQUFzQixXQUF0QjtBQUVBTixVQUFRLENBQUNPLElBQVQsQ0FBY0MsV0FBZCxDQUEwQkMsT0FBMUI7QUFFQUMsY0FBWSxHQTdCMkIsQ0ErQnZDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDRCxDQWpFTTs7QUFtRVAsSUFBTUMsbUJBQW1CLEdBQUcsU0FBdEJBLG1CQUFzQixDQUFDZixLQUFELEVBQVc7QUFDckMsTUFBTWdCLEtBQUssR0FBRyxvQ0FBZDtBQUNBLE1BQU1DLE1BQU0sR0FBRyxDQUFDakIsS0FBRCxHQUNYLG9GQUFvRmdCLEtBRHpFLEdBRVgsdUNBQXVDQSxLQUYzQztBQUdBLFNBQU9DLE1BQVA7QUFDRCxDQU5EOztBQVFBLElBQU1DLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsQ0FBQ2xCLEtBQUQsRUFBVztBQUMvQixNQUFNZ0IsS0FBSyxHQUFHLDhCQUFkO0FBQ0EsTUFBTUMsTUFBTSxHQUFHLENBQUNqQixLQUFELEdBQ1gsOEVBQThFZ0IsS0FEbkUsR0FFWCxpQ0FBaUNBLEtBRnJDO0FBR0EsU0FBT0MsTUFBUDtBQUNELENBTkQ7O0FBUUEsSUFBTUgsWUFBWSxHQUFHLFNBQWZBLFlBQWUsR0FBTTtBQUN6QixNQUFJSyxHQUFHLEdBQUcsSUFBSXRCLGdCQUFKLENBQXFCLHVCQUFyQixDQUFWO0FBQ0EsTUFBSXVCLEdBQUcsR0FBRyxJQUFJdkIsZ0JBQUosQ0FBcUIsaUJBQXJCLENBQVY7QUFDQSxNQUFJd0IsS0FBSyxHQUFHLElBQUl4QixnQkFBSixDQUFxQixtQkFBckIsQ0FBWjtBQUVBeUIsU0FBTyxDQUFDQyxHQUFSLENBQVksQ0FBQ0osR0FBRyxDQUFDSyxJQUFKLEVBQUQsRUFBYUosR0FBRyxDQUFDSSxJQUFKLEVBQWIsRUFBeUJILEtBQUssQ0FBQ0csSUFBTixFQUF6QixDQUFaLEVBQ0dDLElBREgsQ0FDUSxZQUFNO0FBQ1ZDLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLG9DQUFaO0FBQ0QsR0FISCxXQUlTLFVBQUNDLEdBQUQsRUFBUztBQUNkRixXQUFPLENBQUNHLElBQVIsQ0FBYSx1Q0FBYixFQUFzREQsR0FBdEQ7QUFDRCxHQU5IO0FBT0QsQ0FaRCxDLENBY0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0tBbkNNZCxZOztBQXFDTixJQUFNZ0Isa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixDQUFDQyxRQUFELEVBQWM7QUFDdkMsTUFBSUMsS0FBSyxHQUFHNUIsUUFBUSxDQUFDQyxhQUFULENBQXVCLE1BQXZCLENBQVo7QUFDQTJCLE9BQUssQ0FBQzFCLElBQU4sR0FBYXlCLFFBQWI7QUFDQUMsT0FBSyxDQUFDekIsR0FBTixHQUFZLFNBQVo7QUFDQXlCLE9BQUssQ0FBQ3hCLEVBQU4sR0FBVyxNQUFYO0FBQ0F3QixPQUFLLENBQUN2QixJQUFOLEdBQWEsVUFBYjtBQUNBdUIsT0FBSyxDQUFDdEIsV0FBTixHQUFvQixXQUFwQjtBQUVBTixVQUFRLENBQUNPLElBQVQsQ0FBY0MsV0FBZCxDQUEwQm9CLEtBQTFCO0FBRUFOLFNBQU8sQ0FBQ0MsR0FBUiwyQkFBK0JJLFFBQS9CO0FBQ0QsQ0FYRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbElBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7Ozs7Ozs7QUNKQSx1QkFBdUIsbUJBQU8sQ0FBQyxxRkFBb0I7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQSxvQzs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1DOzs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7OztBQ05BLHFCQUFxQixtQkFBTyxDQUFDLGlGQUFrQjs7QUFFL0MsK0JBQStCLG1CQUFPLENBQUMscUdBQTRCOztBQUVuRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEI7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCOzs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7Ozs7Ozs7QUNQQSxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBa0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLDJCOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDOzs7Ozs7Ozs7OztBQ05BLGNBQWMsbUJBQU8sQ0FBQyxzRkFBK0I7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMkM7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBOztBQUVBLGtDOzs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUM7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTs7QUFFQSxrQzs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7Ozs7Ozs7O0FDSkEsY0FBYyxtQkFBTyxDQUFDLHNGQUErQjs7QUFFckQsNEJBQTRCLG1CQUFPLENBQUMsK0ZBQXlCOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQzs7Ozs7Ozs7Ozs7QUNUQSxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBa0I7O0FBRS9DLDJCQUEyQixtQkFBTyxDQUFDLDZGQUF3Qjs7QUFFM0QsaUNBQWlDLG1CQUFPLENBQUMseUdBQThCOztBQUV2RSxzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBbUI7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQSxnQzs7Ozs7Ozs7Ozs7QUNaQSx3QkFBd0IsbUJBQU8sQ0FBQyx1RkFBcUI7O0FBRXJELHNCQUFzQixtQkFBTyxDQUFDLG1GQUFtQjs7QUFFakQsaUNBQWlDLG1CQUFPLENBQUMseUdBQThCOztBQUV2RSx3QkFBd0IsbUJBQU8sQ0FBQyx1RkFBcUI7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQSxvQzs7Ozs7Ozs7Ozs7QUNaQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUI7Ozs7Ozs7Ozs7O0FDaEJBLHVCQUF1QixtQkFBTyxDQUFDLHFGQUFvQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Qzs7Ozs7Ozs7Ozs7QUNYQSxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBcUI7Ozs7Ozs7Ozs7OztBQ0E5QyxpRkFBaUYsZ0JBQWdCLHNGQUFzRixjQUFjLHNHQUFzRyxtREFBbUQsSUFBSSx5REFBeUQsd0hBQXdILEdBQUcsY0FBYyxxQ0FBcUMsMENBQTBDLCtDQUErQyxzQ0FBc0Msc0NBQXNDLHNDQUFzQyxzQ0FBc0MsVUFBVSxxQ0FBcUMscUJBQXFCLGtCQUFrQixZQUFZLFdBQVcsZ0JBQWdCLGVBQWUsRUFBRSxxQ0FBcUMscUJBQXFCLGtCQUFrQixZQUFZLFdBQVcsZ0JBQWdCLGVBQWU7QUFDMWtDLHFDQUFxQyxxQkFBcUIsa0JBQWtCLFlBQVksV0FBVyxnQkFBZ0IsZUFBZSxFQUFFLDJDQUEyQyxXQUFXLFlBQVksZUFBZSxlQUFlLEVBQUUsMkJBQTJCLDJCQUEyQiwyQkFBMkI7QUFDdlQsZ0JBQWdCLGtDQUFrQyxlQUFlLGdCQUFnQixxQkFBcUIsZ0JBQWdCLGtCQUFrQixXQUFXLFNBQVMsVUFBVSxXQUFXLG1CQUFtQixvQkFBb0IsV0FBVyxFQUFFLGNBQWMsOEJBQThCLHVCQUF1QixpQkFBaUIsbUNBQW1DLDZCQUE2QixnQkFBZ0IsYUFBYSxRQUFRLDZCQUE2QixRQUFRLFNBQVMsU0FBUyxNQUFNLGdCQUFnQixZQUFZLGNBQWMsNkJBQTZCLCtCQUErQixpQ0FBaUMsZ0NBQWdDLGFBQWEsMkRBQTJELDJGQUEyRiw2QkFBNkIsVUFBVSxTQUFTLGFBQWEsK0JBQStCO0FBQ2o0QixhQUFhLGFBQWEsb0NBQW9DLElBQUksMENBQTBDLFVBQVUsb0JBQW9CLFNBQVMsZ0JBQWdCO0FBQ25LLCtCQUErQiw4REFBOEQsaUNBQWlDLGNBQWMsZ0NBQWdDLGFBQWEsNkhBQTZILGlDQUFpQyxJQUFJLElBQUksOEJBQThCLHdCQUF3QixxQ0FBcUMsSUFBSSxFQUFFLG9DQUFvQyxnQkFBZ0IsS0FBSztBQUN6ZixHQUFHLGtCQUFrQixhQUFhLE1BQU0sMlNBQTJTLG9FQUFvRSxhQUFhO0FBQ3BhLDBCQUEwQixLQUFLLHNCQUFzQixnRkFBZ0Ysb0JBQW9CLG1HQUFtRyxZQUFZLHVCQUF1QixrQkFBa0Isc0JBQXNCLG1CQUFtQixtQkFBbUIsbUJBQW1CLDZCQUE2QixrQkFBa0Isa0JBQWtCLGtCQUFrQixJQUFJLGdCQUFnQixJQUFJLElBQUksRUFBRTtBQUNqZixrQ0FBa0MsZ0JBQWdCLElBQUksSUFBSSxFQUFFLGlDQUFpQyxnQkFBZ0IsSUFBSSxJQUFJLEVBQUUscUNBQXFDLEVBQUUsR0FBRyxLQUF3QixtQkFBbUIsU0FBaUYsR0FBRzs7Ozs7Ozs7Ozs7OztBQ1BuUixzQ0FBc0Msc0JBQXNCO0FBQ3pFLHlDOzs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwQ0FBcUY7QUFDOUc7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7O0FBRUE7O0FBU0E7O0FBQ0E7O0FBdUJBLElBQU1FLFVBQTJDLEdBQWpEOztBQUVBLDZDQUtRO0FBQ04sTUFBSSxVQUFpQyxDQUFyQyxRQUE4QztBQUM5QyxNQUFJLENBQUMsd0JBQUwsSUFBSyxDQUFMLEVBQXVCLE9BRmpCLENBR047QUFDQTtBQUNBO0FBQ0E7O0FBQ0FDLFFBQU0sQ0FBTkEscUNBQTBDTixhQUFELEVBQVM7QUFDaEQsY0FBMkM7QUFDekM7QUFDQTtBQUVIO0FBTERNO0FBTUEsTUFBTUMsU0FBUyxHQUNiQyxPQUFPLElBQUksT0FBT0EsT0FBTyxDQUFkLFdBQVhBLGNBQ0lBLE9BQU8sQ0FEWEEsU0FFSUYsTUFBTSxJQUFJQSxNQUFNLENBSHRCLE9BYk0sQ0FrQk47O0FBQ0FELFlBQVUsQ0FBQzNCLElBQUksR0FBSkEsWUFBbUI2QixTQUFTLEdBQUcsTUFBSCxZQUF2Q0YsRUFBVzNCLENBQUQsQ0FBVjJCO0FBR0Y7O0FBQUEsZ0NBQTJEO0FBQUEsTUFDbkQsTUFEbUQsR0FDdENJLEtBQUssQ0FBeEIsYUFEeUQsQ0FDbkQsTUFEbUQ7QUFFekQsU0FDR0MsTUFBTSxJQUFJQSxNQUFNLEtBQWpCLE9BQUNBLElBQ0RELEtBQUssQ0FETCxPQUFDQyxJQUVERCxLQUFLLENBRkwsT0FBQ0MsSUFHREQsS0FBSyxDQUhMLFFBQUNDLElBSURELEtBQUssQ0FKTCxNQUFDQyxJQUllO0FBQ2ZELE9BQUssQ0FBTEEsZUFBcUJBLEtBQUssQ0FBTEEsc0JBTnhCO0FBVUY7O0FBQUEsNEVBU1E7QUFBQSxNQUNBLFFBREEsR0FDZUUsQ0FBQyxDQUF0QixhQURNLENBQ0EsUUFEQTs7QUFHTixNQUFJQyxRQUFRLEtBQVJBLFFBQXFCQyxlQUFlLENBQWZBLENBQWUsQ0FBZkEsSUFBc0IsQ0FBQyx3QkFBaEQsSUFBZ0QsQ0FBNUNELENBQUosRUFBbUU7QUFDakU7QUFDQTtBQUdGRDs7QUFBQUEsR0FBQyxDQUFEQSxpQkFSTSxDQVVOOztBQUNBLE1BQUlHLE1BQU0sSUFBVixNQUFvQjtBQUNsQkEsVUFBTSxHQUFHbEMsRUFBRSxDQUFGQSxlQUFUa0M7QUFHRixHQWZNLENBZU47OztBQUNBUixRQUFNLENBQUNTLE9BQU8sZUFBZFQsTUFBTSxDQUFOQSxXQUErQztBQUM3Q1UsV0FENkMsRUFDN0NBLE9BRDZDO0FBRTdDQyxVQUY2QyxFQUU3Q0EsTUFGNkM7QUFHN0NILFVBSEZSLEVBR0VRO0FBSDZDLEdBQS9DUixPQUlTWSxpQkFBRCxFQUFzQjtBQUM1QixRQUFJLENBQUosU0FBYzs7QUFDZCxnQkFBWTtBQUNWO0FBQ0ExQyxjQUFRLENBQVJBO0FBRUg7QUFWRDhCO0FBYUY7O0FBQUEscUJBQXlEO0FBQUE7O0FBQ3ZELFlBQTJDO0FBQUEsUUFDekMsZUFEeUMsR0FDekMsK0JBSUc7QUFDRCxhQUFPLFVBQ0osc0NBQStCYSxJQUFJLENBQUNDLEdBQXBDLHlCQUF1REQsSUFBSSxDQUFDRSxRQUE1RCxvQ0FBaUdGLElBQUksQ0FBdEcsTUFBQyxtQkFDRSw0RUFGTCxTQUNHLENBREksQ0FBUDtBQVFGLEtBZHlDLEVBY3pDOzs7QUFDQSxRQUFNRyxrQkFBbUQsR0FBRztBQUMxRDVDLFVBQUksRUFETjtBQUE0RCxLQUE1RDtBQUdBLFFBQU02QyxhQUFrQyxHQUFHQyxNQUFNLENBQU5BLEtBQTNDLGtCQUEyQ0EsQ0FBM0M7QUFHQSxpQkFBYSxDQUFiLFFBQXVCSixhQUFELEVBQTRCO0FBQ2hELFVBQUlBLEdBQUcsS0FBUCxRQUFvQjtBQUNsQixZQUNFSyxLQUFLLENBQUxBLEdBQUssQ0FBTEEsWUFDQyxPQUFPQSxLQUFLLENBQVosR0FBWSxDQUFaLGlCQUFrQyxPQUFPQSxLQUFLLENBQVosR0FBWSxDQUFaLEtBRnJDLFVBR0U7QUFDQSxnQkFBTUMsZUFBZSxDQUFDO0FBQ3BCTixlQURvQixFQUNwQkEsR0FEb0I7QUFFcEJDLG9CQUFRLEVBRlk7QUFHcEJNLGtCQUFNLEVBQUVGLEtBQUssQ0FBTEEsR0FBSyxDQUFMQSxxQkFBK0IsT0FBT0EsS0FBSyxDQUhyRCxHQUdxRDtBQUgvQixXQUFELENBQXJCO0FBTUg7QUFYRCxhQVdPO0FBQ0w7QUFDQTtBQUNBLFlBQU1HLENBQVEsR0FBZDtBQUVIO0FBakJELE9BckJ5QyxDQXdDekM7O0FBQ0EsUUFBTUMsa0JBQW1ELEdBQUc7QUFDMURqRCxRQUFFLEVBRHdEO0FBRTFEbUMsYUFBTyxFQUZtRDtBQUcxREQsWUFBTSxFQUhvRDtBQUkxREUsYUFBTyxFQUptRDtBQUsxRGMsY0FBUSxFQUxrRDtBQU0xREMsY0FBUSxFQU5rRDtBQU8xRGQsWUFBTSxFQVBSO0FBQTRELEtBQTVEO0FBU0EsUUFBTWUsYUFBa0MsR0FBR1IsTUFBTSxDQUFOQSxLQUEzQyxrQkFBMkNBLENBQTNDO0FBR0EsaUJBQWEsQ0FBYixRQUF1QkosYUFBRCxFQUE0QjtBQUNoRCxVQUFNYSxPQUFPLEdBQUcsT0FBT1IsS0FBSyxDQUE1QixHQUE0QixDQUE1Qjs7QUFFQSxVQUFJTCxHQUFHLEtBQVAsTUFBa0I7QUFDaEIsWUFBSUssS0FBSyxDQUFMQSxHQUFLLENBQUxBLElBQWNRLE9BQU8sS0FBckJSLFlBQXNDUSxPQUFPLEtBQWpELFVBQWdFO0FBQzlELGdCQUFNUCxlQUFlLENBQUM7QUFDcEJOLGVBRG9CLEVBQ3BCQSxHQURvQjtBQUVwQkMsb0JBQVEsRUFGWTtBQUdwQk0sa0JBQU0sRUFIUjtBQUFzQixXQUFELENBQXJCO0FBTUg7QUFSRCxhQVFPLElBQUlQLEdBQUcsS0FBUCxVQUFzQjtBQUMzQixZQUFJSyxLQUFLLENBQUxBLEdBQUssQ0FBTEEsSUFBY1EsT0FBTyxLQUF6QixVQUF3QztBQUN0QyxnQkFBTVAsZUFBZSxDQUFDO0FBQ3BCTixlQURvQixFQUNwQkEsR0FEb0I7QUFFcEJDLG9CQUFRLEVBRlk7QUFHcEJNLGtCQUFNLEVBSFI7QUFBc0IsV0FBRCxDQUFyQjtBQU1IO0FBUk0sYUFRQSxJQUNMUCxHQUFHLEtBQUhBLGFBQ0FBLEdBQUcsS0FESEEsWUFFQUEsR0FBRyxLQUZIQSxhQUdBQSxHQUFHLEtBSEhBLGNBSUFBLEdBQUcsS0FMRSxZQU1MO0FBQ0EsWUFBSUssS0FBSyxDQUFMQSxHQUFLLENBQUxBLFlBQXNCUSxPQUFPLEtBQWpDLFdBQWlEO0FBQy9DLGdCQUFNUCxlQUFlLENBQUM7QUFDcEJOLGVBRG9CLEVBQ3BCQSxHQURvQjtBQUVwQkMsb0JBQVEsRUFGWTtBQUdwQk0sa0JBQU0sRUFIUjtBQUFzQixXQUFELENBQXJCO0FBTUg7QUFkTSxhQWNBO0FBQ0w7QUFDQTtBQUNBLFlBQU1DLENBQVEsR0FBZDtBQUVIO0FBdENELE9BckR5QyxDQTZGekM7QUFDQTs7QUFDQSxRQUFNTSxTQUFTLEdBQUdDLHlCQUFsQixLQUFrQkEsQ0FBbEI7O0FBQ0EsUUFBSVYsS0FBSyxDQUFMQSxZQUFrQixDQUFDUyxTQUFTLENBQWhDLFNBQTBDO0FBQ3hDQSxlQUFTLENBQVRBO0FBQ0FwQyxhQUFPLENBQVBBO0FBSUg7QUFDRDs7QUFBQSxNQUFNc0MsQ0FBQyxHQUFHWCxLQUFLLENBQUxBLGFBQVY7QUFFQSxNQUFNbkIsTUFBTSxHQUFHLGFBQWYsU0FBZSxHQUFmO0FBQ0EsTUFBTStCLFFBQVEsR0FBSS9CLE1BQU0sSUFBSUEsTUFBTSxDQUFqQixRQUFDQSxJQUFsQjs7QUEzR3VELDhCQTZHbEM2QiwwQkFBYyxZQUFNO0FBQUEsZUFDSixtQ0FBc0JWLEtBQUssQ0FBM0IsTUFBbkMsSUFBbUMsQ0FESTtBQUFBO0FBQUEsUUFDakMsWUFEaUM7QUFBQSxRQUNqQyxVQURpQzs7QUFFdkMsV0FBTztBQUNML0MsVUFBSSxFQURDO0FBRUxFLFFBQUUsRUFBRTZDLEtBQUssQ0FBTEEsS0FDQSxtQ0FBc0JBLEtBQUssQ0FEM0JBLEVBQ0EsQ0FEQUEsR0FFQWEsVUFBVSxJQUpoQjtBQUFPLEtBQVA7QUFGbUJILEtBUWxCLFdBQVdWLEtBQUssQ0FBaEIsTUFBdUJBLEtBQUssQ0FSL0IsRUFRRyxDQVJrQlUsQ0E3R2tDO0FBQUEsTUE2R2pELElBN0dpRCx5QkE2R2pELElBN0dpRDtBQUFBLE1BNkdqRCxFQTdHaUQseUJBNkdqRCxFQTdHaUQ7O0FBQUEsTUF1SG5ELFFBdkhtRCxHQXVIdkQsS0F2SHVELENBdUhuRCxRQXZIbUQ7QUFBQSxNQXVIbkQsT0F2SG1ELEdBdUh2RCxLQXZIdUQsQ0F1SG5ELE9BdkhtRDtBQUFBLE1BdUhuRCxPQXZIbUQsR0F1SHZELEtBdkh1RCxDQXVIbkQsT0F2SG1EO0FBQUEsTUF1SG5ELE1BdkhtRCxHQXVIdkQsS0F2SHVELENBdUhuRCxNQXZIbUQ7QUFBQSxNQXVIbkQsTUF2SG1ELEdBdUh2RCxLQXZIdUQsQ0F1SG5ELE1BdkhtRCxFQXlIdkQ7O0FBQ0EsTUFBSSxvQkFBSixVQUFrQztBQUNoQ3JGLFlBQVEsZ0JBQUcsMkNBQVhBLFFBQVcsQ0FBWEE7QUFHRixHQTlIdUQsQ0E4SHZEOzs7QUFDQSxNQUFNeUYsS0FBVSxHQUFHQyxxQkFBbkIsUUFBbUJBLENBQW5COztBQUNBLE1BQU1DLFFBQWEsR0FBR0YsS0FBSyxJQUFJLGlCQUFUQSxZQUFzQ0EsS0FBSyxDQUFqRTs7QUFoSXVELGNBa0lmLHNDQUFnQjtBQUN0REcsY0FBVSxFQURaO0FBQXdELEdBQWhCLENBbEllO0FBQUE7QUFBQSxNQWtJakQsa0JBbElpRDtBQUFBLE1Ba0lqRCxTQWxJaUQ7O0FBcUl2RCxNQUFNQyxNQUFNLEdBQUdSLDhCQUNaUyxZQUFELEVBQWlCO0FBQ2ZDLHNCQUFrQixDQUFsQkEsRUFBa0IsQ0FBbEJBOztBQUNBLGtCQUFjO0FBQ1osVUFBSSxvQkFBSixZQUFvQ0osUUFBUSxDQUE1QyxFQUE0QyxDQUFSQSxDQUFwQyxLQUNLLElBQUksb0JBQUosVUFBa0M7QUFDckNBLGdCQUFRLENBQVJBO0FBRUg7QUFDRjtBQVRZTixLQVViLFdBVkYsa0JBVUUsQ0FWYUEsQ0FBZjs7QUFZQSx3QkFBVSxZQUFNO0FBQ2QsUUFBTVcsY0FBYyxHQUFHQyxTQUFTLElBQVRBLEtBQWtCLHdCQUF6QyxJQUF5QyxDQUF6QztBQUNBLFFBQU14QyxTQUFTLEdBQ2IseUNBQXlDRCxNQUFNLElBQUlBLE1BQU0sQ0FEM0Q7QUFFQSxRQUFNMEMsWUFBWSxHQUNoQjNDLFVBQVUsQ0FBQzNCLElBQUksR0FBSkEsWUFBbUI2QixTQUFTLEdBQUcsTUFBSCxZQUR6QyxFQUNhN0IsQ0FBRCxDQURaOztBQUVBLFFBQUlvRSxjQUFjLElBQUksQ0FBdEIsY0FBcUM7QUFDbkNmLGNBQVEsbUJBQW1CO0FBQ3pCZCxjQUFNLEVBRFJjO0FBQTJCLE9BQW5CLENBQVJBO0FBSUg7QUFYRCxLQVdHLGlDQVhILE1BV0csQ0FYSDtBQWFBLE1BQU1rQixVQUtMLEdBQUc7QUFDRkMsT0FBRyxFQUREO0FBRUZDLFdBQU8sRUFBR3hDLGtCQUFELEVBQXlCO0FBQ2hDLFVBQUk0QixLQUFLLENBQUxBLFNBQWUsT0FBT0EsS0FBSyxDQUFMQSxNQUFQLFlBQW5CLFlBQThEO0FBQzVEQSxhQUFLLENBQUxBO0FBRUY7O0FBQUEsVUFBSSxDQUFDNUIsQ0FBQyxDQUFOLGtCQUF5QjtBQUN2QnlDLG1CQUFXLGdEQUFYQSxNQUFXLENBQVhBO0FBRUg7QUFkSDtBQUtJLEdBTEo7O0FBaUJBSCxZQUFVLENBQVZBLGVBQTJCdEMsV0FBRCxFQUF5QjtBQUNqRCxRQUFJLENBQUMsd0JBQUwsSUFBSyxDQUFMLEVBQXVCOztBQUN2QixRQUFJNEIsS0FBSyxDQUFMQSxTQUFlLE9BQU9BLEtBQUssQ0FBTEEsTUFBUCxpQkFBbkIsWUFBbUU7QUFDakVBLFdBQUssQ0FBTEE7QUFFRlI7O0FBQUFBLFlBQVEsbUJBQW1CO0FBQUVzQixjQUFRLEVBQXJDdEI7QUFBMkIsS0FBbkIsQ0FBUkE7QUFMRmtCLElBL0t1RCxDQXVMdkQ7QUFDQTs7O0FBQ0EsTUFBSXhCLEtBQUssQ0FBTEEsWUFBbUJjLEtBQUssQ0FBTEEsZ0JBQXNCLEVBQUUsVUFBVUEsS0FBSyxDQUE5RCxLQUE2QyxDQUE3QyxFQUF3RTtBQUN0RSxRQUFNaEMsU0FBUyxHQUNiLHlDQUF5Q0QsTUFBTSxJQUFJQSxNQUFNLENBRDNEO0FBR0EsUUFBTWdELFlBQVksR0FBRyw0Q0FHbkJoRCxNQUFNLElBQUlBLE1BQU0sQ0FIRyxTQUluQkEsTUFBTSxJQUFJQSxNQUFNLENBSmxCLGFBQXFCLENBQXJCO0FBT0EyQyxjQUFVLENBQVZBLE9BQ0VLLFlBQVksSUFDWix5QkFBWSxzQ0FBeUJoRCxNQUFNLElBQUlBLE1BQU0sQ0FGdkQyQyxhQUVjLENBQVosQ0FGRkE7QUFLRjs7QUFBQSxzQkFBT2Qsc0NBQVAsVUFBT0EsQ0FBUDs7O0dBek1GLEk7O0tBQUEsSTtlQTRNZW9CLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5VGY7QUFDQTtBQUNBOztBQUNPLHVDQUF1RDtBQUM1RCxTQUFPQyxJQUFJLENBQUpBLGlCQUFzQkEsSUFBSSxLQUExQkEsTUFBcUNBLElBQUksQ0FBSkEsU0FBYyxDQUFuREEsQ0FBcUNBLENBQXJDQSxHQUFQO0FBR0Y7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sSUFBTUMsMEJBQTBCLEdBQUdDLFNBQ3JDRixTQURxQ0UsR0FBbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ09QLElBQU1DLG1CQUFtQixHQUN0QiwrQkFBK0JDLElBQUksQ0FBcEMsbUJBQUMsSUFDRCxjQUVrQjtBQUNoQixNQUFJQyxLQUFLLEdBQUdDLElBQUksQ0FBaEIsR0FBWUEsRUFBWjtBQUNBLFNBQU9DLFVBQVUsQ0FBQyxZQUFZO0FBQzVCQyxNQUFFLENBQUM7QUFDREMsZ0JBQVUsRUFEVDtBQUVEQyxtQkFBYSxFQUFFLHlCQUFZO0FBQ3pCLGVBQU9DLElBQUksQ0FBSkEsT0FBWSxNQUFNTCxJQUFJLENBQUpBLFFBQXpCLEtBQW1CLENBQVpLLENBQVA7QUFISkg7QUFBRyxLQUFELENBQUZBO0FBRGUsS0FBakIsQ0FBaUIsQ0FBakI7QUFOSjs7ZUFnQmVMLG1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDZjs7QUFDQSxrSyxDQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFNUyxpQkFBaUIsR0FBdkI7O0FBbUNBLHlDQUljO0FBQ1osTUFBSUMsS0FBZ0MsR0FBR0MsR0FBRyxDQUFIQSxJQUF2QyxHQUF1Q0EsQ0FBdkM7O0FBQ0EsYUFBVztBQUNULFFBQUksWUFBSixPQUF1QjtBQUNyQixhQUFPRCxLQUFLLENBQVo7QUFFRjs7QUFBQSxXQUFPM0UsT0FBTyxDQUFQQSxRQUFQLEtBQU9BLENBQVA7QUFFRjs7QUFBQTtBQUNBLE1BQU02RSxJQUFnQixHQUFHLFlBQWdCQyxpQkFBRCxFQUFhO0FBQ25EQyxZQUFRLEdBQVJBO0FBREYsR0FBeUIsQ0FBekI7QUFHQUgsS0FBRyxDQUFIQSxTQUFjRCxLQUFLLEdBQUc7QUFBRUcsV0FBTyxFQUFUO0FBQXNCRSxVQUFNLEVBQWxESjtBQUFzQixHQUF0QkE7QUFDQSxTQUFPSyxTQUFTLEdBQ1o7QUFDQUEsV0FBUyxHQUFUQSxLQUFrQkMsZUFBRDtBQUFBLFdBQVlILFFBQVEsQ0FBUkEsS0FBUSxDQUFSQSxFQUZqQixLQUVLO0FBQUEsR0FBakJFLENBRlksR0FBaEI7QUFhRjs7QUFBQSwyQkFBc0Q7QUFDcEQsTUFBSTtBQUNGRSxRQUFJLEdBQUdyRyxRQUFRLENBQVJBLGNBQVBxRyxNQUFPckcsQ0FBUHFHO0FBQ0EsV0FDRTtBQUNBO0FBQ0MsT0FBQyxDQUFDQyxNQUFNLENBQVIsd0JBQWlDLENBQUMsQ0FBRXRHLFFBQUQsQ0FBcEMsWUFBQyxJQUNEcUcsSUFBSSxDQUFKQSxpQkFKRixVQUlFQTtBQUpGO0FBTUEsR0FSRixDQVFFLGdCQUFNO0FBQ047QUFFSDtBQUVEOztBQUFBLElBQU1FLFdBQW9CLEdBQUdDLFdBQTdCOztBQUVBLHdDQUlnQjtBQUNkLFNBQU8sWUFBWSxvQkFBYztBQUMvQixRQUFJeEcsUUFBUSxDQUFSQSx1REFBSixJQUFJQSxTQUFKLEVBQXFFO0FBQ25FLGFBQU95RyxHQUFQO0FBR0ZKOztBQUFBQSxRQUFJLEdBQUdyRyxRQUFRLENBQVJBLGNBQVBxRyxNQUFPckcsQ0FBUHFHLENBTCtCLENBTy9COztBQUNBLFlBQVFBLElBQUksQ0FBSkE7QUFDUkEsUUFBSSxDQUFKQTtBQUNBQSxRQUFJLENBQUpBLGNBQW9CbkIsU0FBcEJtQjtBQUNBQSxRQUFJLENBQUpBO0FBQ0FBLFFBQUksQ0FBSkEsY0FaK0IsQ0FjL0I7O0FBQ0FBLFFBQUksQ0FBSkE7QUFFQXJHLFlBQVEsQ0FBUkE7QUFqQkYsR0FBTyxDQUFQO0FBcUJGOztBQUFBLElBQU0wRyxnQkFBZ0IsR0FBR0MsTUFBTSxDQUEvQixrQkFBK0IsQ0FBL0IsQyxDQUNBOztBQUNPLDZCQUEyQztBQUNoRCxTQUFPM0QsTUFBTSxDQUFOQSxzQ0FBUCxFQUFPQSxDQUFQO0FBR0s7O0FBQUEsMkJBQXdEO0FBQzdELFNBQU94QixHQUFHLElBQUlrRixnQkFBZ0IsSUFBOUI7QUFHRjs7QUFBQSxtQ0FHb0I7QUFDbEIsU0FBTyxZQUFZLDJCQUFxQjtBQUN0Q0UsVUFBTSxHQUFHNUcsUUFBUSxDQUFSQSxjQUFUNEcsUUFBUzVHLENBQVQ0RyxDQURzQyxDQUd0QztBQUNBO0FBQ0E7O0FBQ0FBLFVBQU0sQ0FBTkE7O0FBQ0FBLFVBQU0sQ0FBTkEsVUFBaUI7QUFBQSxhQUNmQyxNQUFNLENBQUNDLGNBQWMsQ0FBQywyQ0FEeEJGLEdBQ3dCLEVBQUQsQ0FBZixDQURTO0FBQUEsS0FBakJBLENBUHNDLENBVXRDO0FBQ0E7OztBQUNBQSxVQUFNLENBQU5BLGNBQXFCMUIsU0FBckIwQixDQVpzQyxDQWN0QztBQUNBOztBQUNBQSxVQUFNLENBQU5BO0FBQ0E1RyxZQUFRLENBQVJBO0FBakJGLEdBQU8sQ0FBUDtBQXFCRjs7QUFBQSw4QkFBNEQ7QUFDMUQsU0FBTyxZQUFZO0FBQUEsV0FDakIscUNBQW9CO0FBQUEsYUFBTXVGLFVBQVUsQ0FBQztBQUFBLGVBQU1zQixNQUFNLENBQWIsR0FBYSxDQUFaO0FBQUEsT0FBRCxFQUR0QyxFQUNzQyxDQUFoQjtBQUFBLEtBQXBCLENBRGlCO0FBQUEsR0FBWixDQUFQO0FBS0YsQyxDQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sa0NBQWdFO0FBQ3JFLE1BQUl6QixJQUFJLENBQVIsa0JBQTJCO0FBQ3pCLFdBQU9sRSxPQUFPLENBQVBBLFFBQWdCa0UsSUFBSSxDQUEzQixnQkFBT2xFLENBQVA7QUFHRjs7QUFBQSxNQUFNNkYsZUFBNkMsR0FBRyxZQUVuRGYsaUJBQUQsRUFBYTtBQUNiO0FBQ0EsUUFBTVIsRUFBRSxHQUFHSixJQUFJLENBQWY7O0FBQ0FBLFFBQUksQ0FBSkEsc0JBQTJCLFlBQU07QUFDL0JZLGFBQU8sQ0FBQ1osSUFBSSxDQUFaWSxnQkFBTyxDQUFQQTtBQUNBUixRQUFFLElBQUlBLEVBQU5BO0FBRkZKO0FBTEYsR0FBc0QsQ0FBdEQ7QUFVQSxTQUFPbEUsT0FBTyxDQUFQQSxLQUFhLGtCQUVsQjhGLFdBQVcsb0JBRVRGLGNBQWMsQ0FBQyxVQUpuQixzQ0FJbUIsQ0FBRCxDQUZMLENBRk8sQ0FBYjVGLENBQVA7QUFhRjs7QUFBQSw4Q0FHdUI7QUFDckIsWUFBNEM7QUFDMUMsV0FBTyxPQUFPLENBQVAsUUFBZ0I7QUFDckIrRixhQUFPLEVBQUUsQ0FDUEMsV0FBVyxHQUFYQSwrQkFFRUMsU0FBUyxDQUFDLDhDQUpPLEtBSVAsQ0FBRCxDQUhKLENBRFk7QUFNckI7QUFDQUMsU0FBRyxFQVBMO0FBQXVCLEtBQWhCLENBQVA7QUFVRjs7QUFBQSxTQUFPQyxzQkFBc0IsR0FBdEJBLEtBQStCQyxrQkFBRCxFQUFjO0FBQ2pELFFBQUksRUFBRUMsS0FBSyxJQUFYLFFBQUksQ0FBSixFQUEwQjtBQUN4QixZQUFNVCxjQUFjLENBQUMsNENBQXJCLEtBQXFCLEVBQUQsQ0FBcEI7QUFFRjs7QUFBQSxRQUFNVSxRQUFRLEdBQUdGLFFBQVEsQ0FBUkEsS0FBUSxDQUFSQSxLQUNkekIsZUFBRDtBQUFBLGFBQVdxQixXQUFXLEdBQVhBLFlBQTBCQyxTQUFTLENBRGhELEtBQ2dELENBQTlDO0FBQUEsS0FEZUcsQ0FBakI7QUFHQSxXQUFPO0FBQ0xMLGFBQU8sRUFBRU8sUUFBUSxDQUFSQSxPQUFpQkMsV0FBRDtBQUFBLGVBQU9BLENBQUMsQ0FBREEsU0FEM0IsS0FDMkJBLENBQVA7QUFBQSxPQUFoQkQsQ0FESjtBQUVMSixTQUFHLEVBQUVJLFFBQVEsQ0FBUkEsT0FBaUJDLFdBQUQ7QUFBQSxlQUFPQSxDQUFDLENBQURBLFNBRjlCLE1BRThCQSxDQUFQO0FBQUEsT0FBaEJEO0FBRkEsS0FBUDtBQVBGLEdBQU9ILENBQVA7QUFjRjs7QUFBQSx3Q0FBNkQ7QUFDM0QsTUFBTUssV0FHTCxHQUFHLElBSEosR0FHSSxFQUhKO0FBSUEsTUFBTUMsYUFBNEMsR0FBRyxJQUFyRCxHQUFxRCxFQUFyRDtBQUNBLE1BQU1DLFdBQWtELEdBQUcsSUFBM0QsR0FBMkQsRUFBM0Q7QUFDQSxNQUFNQyxNQUdMLEdBQUcsSUFISixHQUdJLEVBSEo7O0FBS0EsbUNBQTJEO0FBQ3pELFFBQUk5QixJQUFrQyxHQUFHNEIsYUFBYSxDQUFiQSxJQUF6QyxHQUF5Q0EsQ0FBekM7O0FBQ0EsY0FBVTtBQUNSO0FBR0YsS0FOeUQsQ0FNekQ7OztBQUNBLFFBQUkzSCxRQUFRLENBQVJBLHNDQUFKLEdBQUlBLFNBQUosRUFBcUQ7QUFDbkQsYUFBT2tCLE9BQU8sQ0FBZCxPQUFPQSxFQUFQO0FBR0Z5Rzs7QUFBQUEsaUJBQWEsQ0FBYkEsU0FBd0I1QixJQUFJLEdBQUcrQixZQUFZLENBQTNDSCxHQUEyQyxDQUEzQ0E7QUFDQTtBQUdGOztBQUFBLGlDQUFpRTtBQUMvRCxRQUFJNUIsSUFBMEMsR0FBRzZCLFdBQVcsQ0FBWEEsSUFBakQsSUFBaURBLENBQWpEOztBQUNBLGNBQVU7QUFDUjtBQUdGQTs7QUFBQUEsZUFBVyxDQUFYQSxVQUVHN0IsSUFBSSxHQUFHZ0MsS0FBSyxDQUFMQSxJQUFLLENBQUxBLE1BQ0N0QixhQUFELEVBQVM7QUFDYixVQUFJLENBQUNBLEdBQUcsQ0FBUixJQUFhO0FBQ1gsY0FBTSwrQ0FBTixJQUFNLEVBQU47QUFFRjs7QUFBQSxhQUFPQSxHQUFHLENBQUhBLFlBQWlCdUIsY0FBRDtBQUFBLGVBQVc7QUFBRTlILGNBQUksRUFBTjtBQUFjK0gsaUJBQU8sRUFBdkQ7QUFBa0MsU0FBWDtBQUFBLE9BQWhCeEIsQ0FBUDtBQUxJc0IsZ0JBT0V2RyxhQUFELEVBQVM7QUFDZCxZQUFNc0YsY0FBYyxDQUFwQixHQUFvQixDQUFwQjtBQVZOYyxLQUVVRyxDQUZWSDtBQWFBO0FBR0Y7O0FBQUEsU0FBTztBQUNMTSxrQkFESywwQkFDUyxLQURULEVBQ3lCO0FBQzVCLGFBQU9DLFVBQVUsUUFBakIsV0FBaUIsQ0FBakI7QUFGRztBQUlMQyxnQkFKSyx3QkFJTyxLQUpQLEVBSU8sT0FKUCxFQUkrQztBQUNsRGxILGFBQU8sQ0FBUEEsc0JBQ1NtSCxZQUFEO0FBQUEsZUFBUUEsRUFEaEJuSCxFQUNRO0FBQUEsT0FEUkEsT0FHS29ILGlCQUFEO0FBQUEsZUFBbUI7QUFDakJDLG1CQUFTLEVBQUdELE9BQU8sSUFBSUEsT0FBWixXQUFDQSxJQURLO0FBRWpCQSxpQkFBTyxFQUxicEg7QUFHdUIsU0FBbkI7QUFBQSxPQUhKQSxFQU9LTSxhQUFEO0FBQUEsZUFBVTtBQUFFZ0gsZUFBSyxFQVByQnRIO0FBT2MsU0FBVjtBQUFBLE9BUEpBLE9BU1N1SCxlQUFELEVBQTRCO0FBQ2hDLFlBQU1DLEdBQUcsR0FBR2hCLFdBQVcsQ0FBWEEsSUFBWixLQUFZQSxDQUFaO0FBQ0FBLG1CQUFXLENBQVhBO0FBQ0EsWUFBSWdCLEdBQUcsSUFBSSxhQUFYLEtBQTZCQSxHQUFHLENBQUhBO0FBWmpDeEg7QUFMRztBQW9CTHlILGFBcEJLLHFCQW9CSSxLQXBCSixFQW9Cb0I7QUFBQTs7QUFDdkIsYUFBT1IsVUFBVSxzRkFBa0M7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1QkFFaEJTLGdCQUFnQixjQUEvQyxLQUErQyxDQUZBOztBQUFBO0FBQUE7QUFFekMsdUJBRnlDLHlCQUV6QyxPQUZ5QztBQUV6QyxtQkFGeUMseUJBRXpDLEdBRnlDO0FBQUE7QUFBQSx1QkFHdEIxSCxPQUFPLENBQVBBLElBQVksQ0FDbkN3RyxXQUFXLENBQVhBLGtCQUVJeEcsT0FBTyxDQUFQQSxJQUFZK0YsT0FBTyxDQUFQQSxJQUhtQixrQkFHbkJBLENBQVovRixDQUgrQixFQUluQ0EsT0FBTyxDQUFQQSxJQUFZa0csR0FBRyxDQUFIQSxJQUpkLGVBSWNBLENBQVpsRyxDQUptQyxDQUFaQSxDQUhzQjs7QUFBQTtBQUFBO0FBQUE7QUFHekMsc0JBSHlDO0FBQUE7QUFBQSx1QkFVTEEsT0FBTyxDQUFQQSxLQUFhLENBQ3JELHFCQURxRCxLQUNyRCxDQURxRCxFQUVyRDhGLFdBQVcsb0JBRVRGLGNBQWMsQ0FDWixvREFMTixLQUtNLEVBRFksQ0FGTCxDQUYwQyxDQUFiNUYsQ0FWSzs7QUFBQTtBQVV6QzJILDBCQVZ5QztBQW1CekNwQyxtQkFuQnlDLEdBbUJqQnpELE1BQU0sQ0FBTkEsT0FHNUI7QUFBRThGLHdCQUgwQjlGLEVBRzFCOEY7QUFBRixpQkFINEI5RixFQUE5QixVQUE4QkEsQ0FuQmlCO0FBQUEsaURBdUJ4QyxxQ0FBUCxHQXZCK0M7O0FBQUE7QUFBQTtBQUFBO0FBQUEsaURBeUJ4QztBQUFFd0YsdUJBekJiO0FBeUJXLGlCQXpCd0M7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FBbEMsR0FBakI7QUFyQkc7QUFrRExqRixZQWxESyxvQkFrREcsS0FsREgsRUFrRGtDO0FBQUE7O0FBQ3JDO0FBQ0E7QUFDQTs7QUFDQSxVQUFLd0YsRUFBRSxHQUFJQyxTQUFELENBQVYsWUFBMEM7QUFDeEM7QUFDQSxZQUFJRCxFQUFFLENBQUZBLFlBQWUsVUFBVUEsRUFBRSxDQUEvQixhQUFtQixDQUFuQixFQUFnRCxPQUFPN0gsT0FBTyxDQUFkLE9BQU9BLEVBQVA7QUFFbEQ7O0FBQUEsYUFBTyxnQkFBZ0IsY0FBaEIsS0FBZ0IsQ0FBaEIsTUFDRStILGdCQUFEO0FBQUEsZUFDSi9ILE9BQU8sQ0FBUEEsSUFDRXFGLFdBQVcsR0FDUDBDLE1BQU0sQ0FBTkEsWUFBb0JyQyxnQkFBRDtBQUFBLGlCQUFZc0MsY0FBYyxTQUR0QyxRQUNzQyxDQUExQjtBQUFBLFNBQW5CRCxDQURPLEdBSFYsRUFFSC9ILENBREk7QUFBQSxPQURELE9BUUMsWUFBTTtBQUNWLDZDQUFvQjtBQUFBLGlCQUFNLGlCQUExQixLQUEwQixDQUFOO0FBQUEsU0FBcEI7QUFURyxtQkFZSDtBQUNBLGtCQUFNLENBYlYsQ0FBTyxDQUFQO0FBMURKO0FBQU8sR0FBUDs7O2VBNkVhaUksaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6VmY7O0FBQ0E7Ozs7O0FBQ0E7O0FBdUhBOzs7QUExSEE7O0FBbUJBLElBQU1DLGVBQW9DLEdBQUc7QUFDM0N0SCxRQUFNLEVBRHFDO0FBQzdCO0FBQ2R1SCxnQkFBYyxFQUY2QjtBQUczQ0MsT0FIMkMsaUJBR3RDLEVBSHNDLEVBR3JCO0FBQ3BCLFFBQUksS0FBSixRQUFpQixPQUFPOUQsRUFBUDs7QUFDakIsY0FBbUM7QUFDakM7QUFFSDtBQVJIO0FBQTZDLENBQTdDLEMsQ0FXQTs7QUFDQSxJQUFNK0QsaUJBQWlCLEdBQUcsdUhBQTFCLFNBQTBCLENBQTFCO0FBYUEsSUFBTUMsWUFBWSxHQUFHLDBHQUFyQixvQkFBcUIsQ0FBckI7QUFRQSxJQUFNQyxnQkFBZ0IsR0FBRyxrREFBekIsZ0JBQXlCLENBQXpCLEMsQ0FTQTs7QUFDQXpHLE1BQU0sQ0FBTkEsMENBQWlEO0FBQy9DMEcsS0FEK0MsaUJBQ3pDO0FBQ0osV0FBT0Msb0JBQVA7QUFGSjNHO0FBQWlELENBQWpEQTtBQU1BdUcsaUJBQWlCLENBQWpCQSxRQUEyQkssZUFBRCxFQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBNUcsUUFBTSxDQUFOQSx1Q0FBOEM7QUFDNUMwRyxPQUQ0QyxpQkFDdEM7QUFDSixVQUFNNUgsTUFBTSxHQUFHK0gsU0FBZjtBQUNBLGFBQU8vSCxNQUFNLENBQWIsS0FBYSxDQUFiO0FBSEprQjtBQUE4QyxHQUE5Q0E7QUFMRnVHO0FBYUEsZ0JBQWdCLENBQWhCLFFBQTBCSyxlQUFELEVBQW1CO0FBQzFDO0FBQ0E7O0FBQUVSLGlCQUFELE9BQUNBLEdBQWlDLFlBQW9CO0FBQ3JELFFBQU10SCxNQUFNLEdBQUcrSCxTQUFmO0FBQ0EsV0FBTy9ILE1BQU0sQ0FBYixLQUFhLENBQU5BLGFBQU0sWUFBYjtBQUZELEdBQUNzSDtBQUZKO0FBUUFJLFlBQVksQ0FBWkEsUUFBc0J2SCxlQUFELEVBQW1CO0FBQ3RDbUgsaUJBQWUsQ0FBZkEsTUFBc0IsWUFBTTtBQUMxQk8seUNBQXdCLFlBQWE7QUFDbkMsVUFBTUcsVUFBVSxlQUFRN0gsS0FBSyxDQUFMQSx1QkFBUixTQUF3Q0EsS0FBSyxDQUFMQSxVQUF4RCxDQUF3REEsQ0FBeEMsQ0FBaEI7QUFHQSxVQUFNOEgsZ0JBQWdCLEdBQXRCOztBQUNBLFVBQUlBLGdCQUFnQixDQUFwQixVQUFvQixDQUFwQixFQUFrQztBQUNoQyxZQUFJO0FBQ0ZBLDBCQUFnQixDQUFoQkEsVUFBZ0IsQ0FBaEJBLHVCQUFnQixZQUFoQkE7QUFDQSxTQUZGLENBRUUsWUFBWTtBQUNaekksaUJBQU8sQ0FBUEE7QUFDQUEsaUJBQU8sQ0FBUEEsZ0JBQWlCRSxHQUFHLENBQUN3SSxPQUFyQjFJLGVBQWlDRSxHQUFHLENBQXBDRjtBQUVIO0FBQ0Y7QUFiRHFJO0FBREZQO0FBREZJOztBQW1CQSxxQkFBNkI7QUFDM0IsTUFBSSxDQUFDSixlQUFlLENBQXBCLFFBQTZCO0FBQzNCLFFBQU1ZLE9BQU8sR0FDWCxnQ0FERjtBQUdBLFVBQU0sVUFBTixPQUFNLENBQU47QUFFRjs7QUFBQSxTQUFPWixlQUFlLENBQXRCO0FBR0YsQyxDQUFBOzs7ZUFDZUEsZSxFQUVmOzs7O0FBR08scUJBQWlDO0FBQUE7O0FBQ3RDLFNBQU96Riw2QkFBaUJzRyxlQUF4QixhQUFPdEcsQ0FBUDtBQUdGLEMsQ0FBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztHQVZPLFM7O0FBV0EsSUFBTXVHLFlBQVksR0FBRyxTQUFmQSxZQUFlLEdBQWlDO0FBQUEsb0NBQWpDLElBQWlDO0FBQWpDLFFBQWlDO0FBQUE7O0FBQzNEZCxpQkFBZSxDQUFmQSxvQkFBNkJPLFFBQUosV0FBekJQO0FBQ0FBLGlCQUFlLENBQWZBLHVCQUF3QzVELFlBQUQ7QUFBQSxXQUFRQSxFQUEvQzRELEVBQXVDO0FBQUEsR0FBdkNBO0FBQ0FBLGlCQUFlLENBQWZBO0FBRUEsU0FBT0EsZUFBZSxDQUF0QjtBQUxLLEUsQ0FRUDs7Ozs7QUFDTywwQ0FBOEQ7QUFDbkUsTUFBTWUsT0FBTyxHQUFiO0FBQ0EsTUFBTUMsUUFBUSxHQUFkOztBQUZtRSw2Q0FJbkUsaUJBSm1FO0FBQUE7O0FBQUE7QUFJbkUsd0RBQTBDO0FBQUEsVUFBMUMsUUFBMEM7O0FBQ3hDLFVBQUksT0FBT0QsT0FBTyxDQUFkLFFBQWMsQ0FBZCxLQUFKLFVBQTJDO0FBQ3pDQyxnQkFBUSxDQUFSQSxRQUFRLENBQVJBLEdBQXFCcEgsTUFBTSxDQUFOQSxPQUNuQnFILEtBQUssQ0FBTEEsUUFBY0YsT0FBTyxDQUFyQkUsUUFBcUIsQ0FBckJBLFNBRG1CckgsSUFFbkJtSCxPQUFPLENBRlRDLFFBRVMsQ0FGWXBILENBQXJCb0gsQ0FEeUMsQ0FJdkM7O0FBQ0Y7QUFHRkE7O0FBQUFBLGNBQVEsQ0FBUkEsUUFBUSxDQUFSQSxHQUFxQkQsT0FBTyxDQUE1QkMsUUFBNEIsQ0FBNUJBO0FBR0YsS0FoQm1FLENBZ0JuRTs7QUFoQm1FO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBaUJuRUEsVUFBUSxDQUFSQSxTQUFrQlQsb0JBQWxCUztBQUVBWCxrQkFBZ0IsQ0FBaEJBLFFBQTBCRyxlQUFELEVBQVc7QUFDbENRLFlBQVEsQ0FBUkEsS0FBUSxDQUFSQSxHQUFrQixZQUFvQjtBQUNwQyxhQUFPRCxPQUFPLENBQWQsS0FBYyxDQUFQQSxjQUFPLFlBQWQ7QUFERkM7QUFERlg7QUFNQTtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxS0Q7O0FBQ0E7O0FBV0EsSUFBTWEsdUJBQXVCLEdBQUcsZ0NBQWhDOztBQUVPLCtCQUdxRDtBQUFBLE1BSFQsVUFHUyxRQUhULFVBR1M7QUFBQSxNQUhyRCxRQUdxRCxRQUhyRCxRQUdxRDtBQUMxRCxNQUFNQyxVQUFtQixHQUFHQyxRQUFRLElBQUksQ0FBeEM7QUFFQSxNQUFNQyxTQUFTLEdBQUcsV0FBbEIsTUFBa0IsR0FBbEI7O0FBSDBELGNBSTVCLHFCQUE5QixLQUE4QixDQUo0QjtBQUFBO0FBQUEsTUFJcEQsT0FKb0Q7QUFBQSxNQUlwRCxVQUpvRDs7QUFNMUQsTUFBTXRHLE1BQU0sR0FBRyx3QkFDWkMsWUFBRCxFQUFrQjtBQUNoQixRQUFJcUcsU0FBUyxDQUFiLFNBQXVCO0FBQ3JCQSxlQUFTLENBQVRBO0FBQ0FBLGVBQVMsQ0FBVEE7QUFHRjs7QUFBQSxRQUFJRixVQUFVLElBQWQsU0FBMkI7O0FBRTNCLFFBQUluRyxFQUFFLElBQUlBLEVBQUUsQ0FBWixTQUFzQjtBQUNwQnFHLGVBQVMsQ0FBVEEsVUFBb0JDLE9BQU8sS0FFeEJuRyxtQkFBRDtBQUFBLGVBQWVBLFNBQVMsSUFBSW9HLFVBQVUsQ0FGYixTQUVhLENBQXRDO0FBQUEsT0FGeUIsRUFHekI7QUFBRXpHLGtCQUhKdUcsRUFHSXZHO0FBQUYsT0FIeUIsQ0FBM0J1RztBQU1IO0FBaEJZLEtBaUJiLHlCQWpCRixPQWlCRSxDQWpCYSxDQUFmO0FBb0JBLHdCQUFVLFlBQU07QUFDZCxRQUFJLENBQUoseUJBQThCO0FBQzVCLFVBQUksQ0FBSixTQUFjLHFDQUFvQjtBQUFBLGVBQU1FLFVBQVUsQ0FBcEMsSUFBb0MsQ0FBaEI7QUFBQSxPQUFwQjtBQUVqQjtBQUpELEtBSUcsQ0FKSCxPQUlHLENBSkg7QUFNQSxTQUFPLFNBQVAsT0FBTyxDQUFQO0FBR0Y7O0FBQUEsNkNBSWM7QUFBQSx3QkFDdUJDLGNBQWMsQ0FBakQsT0FBaUQsQ0FEckM7QUFBQSxNQUNOLEVBRE0sbUJBQ04sRUFETTtBQUFBLE1BQ04sUUFETSxtQkFDTixRQURNO0FBQUEsTUFDTixRQURNLG1CQUNOLFFBRE07O0FBRVpDLFVBQVEsQ0FBUkE7QUFFQUMsVUFBUSxDQUFSQTtBQUNBLFNBQU8scUJBQTJCO0FBQ2hDRDtBQUNBQyxZQUFRLENBQVJBLG1CQUZnQyxDQUloQzs7QUFDQSxRQUFJRCxRQUFRLENBQVJBLFNBQUosR0FBeUI7QUFDdkJDLGNBQVEsQ0FBUkE7QUFDQUM7QUFFSDtBQVREO0FBWUY7O0FBQUEsSUFBTUEsU0FBUyxHQUFHLElBQWxCLEdBQWtCLEVBQWxCOztBQUNBLGlDQUF3RTtBQUN0RSxNQUFNQyxFQUFFLEdBQUdoSixPQUFPLENBQVBBLGNBQVg7QUFDQSxNQUFJb0ksUUFBUSxHQUFHVyxTQUFTLENBQVRBLElBQWYsRUFBZUEsQ0FBZjs7QUFDQSxnQkFBYztBQUNaO0FBR0Y7O0FBQUEsTUFBTUYsUUFBUSxHQUFHLElBQWpCLEdBQWlCLEVBQWpCO0FBQ0EsTUFBTUMsUUFBUSxHQUFHLHlCQUEwQkcsaUJBQUQsRUFBYTtBQUNyREEsV0FBTyxDQUFQQSxRQUFpQnBGLGVBQUQsRUFBVztBQUN6QixVQUFNcUYsUUFBUSxHQUFHTCxRQUFRLENBQVJBLElBQWFoRixLQUFLLENBQW5DLE1BQWlCZ0YsQ0FBakI7QUFDQSxVQUFNdEcsU0FBUyxHQUFHc0IsS0FBSyxDQUFMQSxrQkFBd0JBLEtBQUssQ0FBTEEsb0JBQTFDOztBQUNBLFVBQUlxRixRQUFRLElBQVosV0FBMkI7QUFDekJBLGdCQUFRLENBQVJBLFNBQVEsQ0FBUkE7QUFFSDtBQU5ERDtBQURlLEtBQWpCLE9BQWlCLENBQWpCO0FBVUFGLFdBQVMsQ0FBVEEsUUFFR1gsUUFBUSxHQUFHO0FBQ1ZZLE1BRFUsRUFDVkEsRUFEVTtBQUVWRixZQUZVLEVBRVZBLFFBRlU7QUFHVkQsWUFMSkUsRUFLSUY7QUFIVSxHQUZkRTtBQVFBO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyR0Q7O0FBRUE7O0FBV2UsdUNBSytCO0FBQzVDLG9DQUFvRDtBQUNsRCx3QkFBTztBQUFtQixZQUFNLEVBQUUsWUFBM0IsU0FBMkI7QUFBM0IsT0FBUCxLQUFPLEVBQVA7QUFHRjs7QUFBQSxtQkFBaUIsQ0FBakIsa0JBQW9DSSxpQkFBaUIsQ0FBQ0MsZUFBdEQsQ0FDQTtBQURBO0FBRUVDLG1CQUFELG9CQUFDQSxHQUFpREYsaUJBQUQsQ0FBakQsbUJBQUNFOztBQUNGLFlBQTJDO0FBQ3pDLFFBQU1DLElBQUksR0FDUkgsaUJBQWlCLENBQWpCQSxlQUFpQ0EsaUJBQWlCLENBQWxEQSxRQURGO0FBRUFFLHFCQUFpQixDQUFqQkE7QUFHRjs7QUFBQTtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ1k7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQThDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBb0Q7QUFDN0U7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCLDJDQUEyQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNDQUFzQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRDtBQUNBLGlCQUFpQixtQ0FBbUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQSxvRUFBb0UsVUFBVSxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDLG9FQUFvRSxVQUFVLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaURBQWlELEVBQUU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0Msd09BQXdPLFVBQVUsRUFBRTtBQUNwUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBNkQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDclpBOzs7Ozs7QUFFTzs7QUFBQSxJQUFNRSxlQUFtQyxnQkFBRzVILGdDQUE1QyxFQUE0Q0EsQ0FBNUM7Ozs7QUFFUCxVQUEyQztBQUN6QzRILGlCQUFlLENBQWZBO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTkQ7O0FBQ0E7Ozs7OztBQUVPOztBQUFBLHVCQUlVO0FBQUEsaUZBSlYsRUFJVTtBQUFBLDJCQUhmQyxRQUdlO0FBQUEsTUFIZkEsUUFHZSw4QkFKVyxLQUlYO0FBQUEseUJBRmZDLE1BRWU7QUFBQSxNQUZmQSxNQUVlLDRCQUpXLEtBSVg7QUFBQSwyQkFEZkMsUUFDZTtBQUFBLE1BRGZBLFFBQ2UsOEJBSlcsS0FJWDs7QUFDZixTQUFPRixRQUFRLElBQUtDLE1BQU0sSUFBMUI7QUFHSzs7QUFBQSxrQkFBMkI7QUFBQTs7QUFDaEM7QUFDQSxTQUFPRSxXQUFXLENBQUNoSSw2QkFBaUI0SCxZQUFwQyxlQUFtQjVILENBQUQsQ0FBbEI7QUFDRDs7R0FITSxNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hQOzs7Ozs7QUFFTzs7QUFBQSxJQUFNaUksa0JBS1gsZ0JBQUdqSSxnQ0FMRSxFQUtGQSxDQUxFOzs7O0FBT1AsVUFBMkM7QUFDekNpSSxvQkFBa0IsQ0FBbEJBO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hEOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTU87O0FBQUEsdUJBQXVEO0FBQUEsTUFBbENDLFNBQWtDLHVFQUF2RCxLQUF1RDtBQUM1RCxNQUFNdEwsSUFBSSxHQUFHLGNBQUM7QUFBTSxXQUFPLEVBQTNCO0FBQWMsSUFBRCxDQUFiOztBQUNBLE1BQUksQ0FBSixXQUFnQjtBQUNkQSxRQUFJLENBQUpBLG1CQUFVO0FBQU0sVUFBSSxFQUFWO0FBQXNCLGFBQU8sRUFBdkNBO0FBQVUsTUFBVkE7QUFFRjs7QUFBQTtBQUdGOztBQUFBLHVDQUdrQztBQUNoQztBQUNBLE1BQUksNkJBQTZCLGlCQUFqQyxVQUE0RDtBQUMxRDtBQUVGLEdBTGdDLENBS2hDOzs7QUFDQSxNQUFJd0QsS0FBSyxDQUFMQSxTQUFlSixrQkFBbkIsVUFBbUM7QUFDakMsV0FBT21JLElBQUksQ0FBSkEsT0FDTG5JLG1DQUF1QkksS0FBSyxDQUFMQSxNQUF2QkosaUJBQ0UsdUNBR3FDO0FBQ25DLFVBQ0UscUNBQ0EseUJBRkYsVUFHRTtBQUNBO0FBRUY7O0FBQUEsYUFBT29JLFlBQVksQ0FBWkEsT0FBUCxhQUFPQSxDQUFQO0FBWEpwSSxPQURGLEVBQ0VBLENBREttSSxDQUFQO0FBa0JGOztBQUFBLFNBQU9BLElBQUksQ0FBSkEsT0FBUCxLQUFPQSxDQUFQO0FBR0Y7O0FBQUEsSUFBTUUsU0FBUyxHQUFHLGlDQUFsQixVQUFrQixDQUFsQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0Esa0JBQWtCO0FBQ2hCLE1BQU1DLElBQUksR0FBRyxJQUFiLEdBQWEsRUFBYjtBQUNBLE1BQU1DLElBQUksR0FBRyxJQUFiLEdBQWEsRUFBYjtBQUNBLE1BQU1DLFNBQVMsR0FBRyxJQUFsQixHQUFrQixFQUFsQjtBQUNBLE1BQU1DLGNBQW1ELEdBQXpEO0FBRUEsU0FBUUMsV0FBRCxFQUFnQztBQUNyQyxRQUFJQyxRQUFRLEdBQVo7QUFDQSxRQUFJQyxNQUFNLEdBQVY7O0FBRUEsUUFBSUYsQ0FBQyxDQUFEQSxPQUFTLE9BQU9BLENBQUMsQ0FBUixRQUFUQSxZQUFzQ0EsQ0FBQyxDQUFEQSxtQkFBMUMsR0FBa0U7QUFDaEVFLFlBQU0sR0FBTkE7QUFDQSxVQUFNM0osR0FBRyxHQUFHeUosQ0FBQyxDQUFEQSxVQUFZQSxDQUFDLENBQURBLG1CQUF4QixDQUFZQSxDQUFaOztBQUNBLFVBQUlKLElBQUksQ0FBSkEsSUFBSixHQUFJQSxDQUFKLEVBQW1CO0FBQ2pCSyxnQkFBUSxHQUFSQTtBQURGLGFBRU87QUFDTEwsWUFBSSxDQUFKQTtBQUVIO0FBRUQsS0FkcUMsQ0FjckM7OztBQUNBLFlBQVFJLENBQUMsQ0FBVDtBQUNFO0FBQ0E7QUFDRSxZQUFJSCxJQUFJLENBQUpBLElBQVNHLENBQUMsQ0FBZCxJQUFJSCxDQUFKLEVBQXNCO0FBQ3BCSSxrQkFBUSxHQUFSQTtBQURGLGVBRU87QUFDTEosY0FBSSxDQUFKQSxJQUFTRyxDQUFDLENBQVZIO0FBRUY7O0FBQUE7O0FBQ0Y7QUFDRSxhQUFLLElBQUlNLENBQUMsR0FBTCxHQUFXQyxHQUFHLEdBQUdULFNBQVMsQ0FBL0IsUUFBd0NRLENBQUMsR0FBekMsS0FBaURBLENBQWpELElBQXNEO0FBQ3BELGNBQU1FLFFBQVEsR0FBR1YsU0FBUyxDQUExQixDQUEwQixDQUExQjtBQUNBLGNBQUksQ0FBQ0ssQ0FBQyxDQUFEQSxxQkFBTCxRQUFLQSxDQUFMLEVBQXVDOztBQUV2QyxjQUFJSyxRQUFRLEtBQVosV0FBNEI7QUFDMUIsZ0JBQUlQLFNBQVMsQ0FBVEEsSUFBSixRQUFJQSxDQUFKLEVBQTZCO0FBQzNCRyxzQkFBUSxHQUFSQTtBQURGLG1CQUVPO0FBQ0xILHVCQUFTLENBQVRBO0FBRUg7QUFORCxpQkFNTztBQUNMLGdCQUFNUSxRQUFRLEdBQUdOLENBQUMsQ0FBREEsTUFBakIsUUFBaUJBLENBQWpCO0FBQ0EsZ0JBQU1PLFVBQVUsR0FBR1IsY0FBYyxDQUFkQSxRQUFjLENBQWRBLElBQTRCLElBQS9DLEdBQStDLEVBQS9DOztBQUNBLGdCQUFJLENBQUNNLFFBQVEsS0FBUkEsVUFBdUIsQ0FBeEIsV0FBb0NFLFVBQVUsQ0FBVkEsSUFBeEMsUUFBd0NBLENBQXhDLEVBQWtFO0FBQ2hFTixzQkFBUSxHQUFSQTtBQURGLG1CQUVPO0FBQ0xNLHdCQUFVLENBQVZBO0FBQ0FSLDRCQUFjLENBQWRBLFFBQWMsQ0FBZEE7QUFFSDtBQUNGO0FBOUJMOztBQUFBO0FBQUE7O0FBa0NBO0FBakRGO0FBcURGO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLCtDQUdFO0FBQ0EsU0FBT1MsWUFBWSxDQUFaQSxPQUVILDZCQUFvRTtBQUNsRSxRQUFNQyxtQkFBbUIsR0FBR25KLG1DQUMxQm9KLFdBQVcsQ0FBWEEsTUFERixRQUE0QnBKLENBQTVCOztBQUdBLFdBQU9tSSxJQUFJLENBQUpBLE9BQVAsbUJBQU9BLENBQVA7QUFOQ2UsdURBWUdHLFdBQVcsQ0FBQy9KLEtBQUssQ0FacEI0SixTQVljLENBWmRBLFNBYUdJLE1BYkhKLGtCQWVBLGdCQUEyQztBQUM5QyxRQUFNakssR0FBRyxHQUFHc0ssQ0FBQyxDQUFEQSxPQUFaOztBQUNBLFFBQ0VoSSxLQURGLEVBSUUsaUJBZUY7O0FBQUEsd0JBQU92QixrQ0FBc0I7QUFBRWYsU0FBL0IsRUFBK0JBO0FBQUYsS0FBdEJlLENBQVA7QUFwQ0osR0FBT2tKLENBQVA7QUF3Q0Y7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0Esb0JBQTJEO0FBQUEsTUFBM0QsUUFBMkQsUUFBM0QsUUFBMkQ7QUFDekQsTUFBTU0sUUFBUSxHQUFHLHVCQUFXNUIsWUFBNUIsZUFBaUIsQ0FBakI7QUFDQSxNQUFNNkIsV0FBVyxHQUFHLHVCQUFXeEIsb0JBQS9CLGtCQUFvQixDQUFwQjtBQUNBLHNCQUNFLGdDQUFDLFdBQUQ7QUFDRSwyQkFBdUIsRUFEekI7QUFFRSxlQUFXLEVBRmI7QUFHRSxhQUFTLEVBQUUsc0JBSGIsUUFHYTtBQUhiLEtBREYsUUFDRSxDQURGO0FBV0YsQyxDQUFBOzs7S0FkQSxJOztBQWVBdk0sSUFBSSxDQUFKQSxTQUFjLFlBQU0sQ0FBcEJBOztlQUVlQSxJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeExSLGdEQU1MO0FBQ0EscUJBREEsQ0FFQTs7QUFDQSxNQUFNZ08sYUFBYSxHQUFHeEosUUFBUSxDQUFSQSxNQUF0QixHQUFzQkEsQ0FBdEI7QUFFQyxHQUFDeUosT0FBTyxJQUFSLFNBQXNCN0ssZ0JBQUQsRUFBWTtBQUNoQyxRQUFJNEssYUFBYSxDQUFiQSxDQUFhLENBQWJBLG1CQUFtQzVLLE1BQU0sQ0FBN0MsV0FBdUNBLEVBQXZDLEVBQTZEO0FBQzNEOEssb0JBQWMsR0FBZEE7QUFDQUYsbUJBQWEsQ0FBYkE7QUFDQXhKLGNBQVEsR0FBR3dKLGFBQWEsQ0FBYkEsYUFBWHhKO0FBQ0E7QUFFRjs7QUFBQTtBQVBEO0FBVUQsU0FBTztBQUNMQSxZQURLLEVBQ0xBLFFBREs7QUFFTDBKLGtCQUZGLEVBRUVBO0FBRkssR0FBUDtBQUlEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBOztBQVVlLGdCQUE2QjtBQUMxQyxNQUFNcE0sR0FBK0IsR0FBRzZCLE1BQU0sQ0FBTkEsT0FBeEMsSUFBd0NBLENBQXhDO0FBRUEsU0FBTztBQUNMd0ssTUFESyxjQUNILElBREcsRUFDSCxPQURHLEVBQzhCO0FBQ2pDO0FBQUMsT0FBQ3JNLEdBQUcsQ0FBSEEsSUFBRyxDQUFIQSxLQUFjQSxHQUFHLENBQUhBLElBQUcsQ0FBSEEsR0FBZixFQUFDQSxDQUFEO0FBRkU7QUFLTHNNLE9BTEssZUFLRixJQUxFLEVBS0YsT0FMRSxFQUsrQjtBQUNsQyxVQUFJdE0sR0FBRyxDQUFQLElBQU8sQ0FBUCxFQUFlO0FBQ2JBLFdBQUcsQ0FBSEEsSUFBRyxDQUFIQSxRQUFpQkEsR0FBRyxDQUFIQSxJQUFHLENBQUhBLHNCQUFqQkE7QUFFSDtBQVRJO0FBV0x1TSxRQVhLLGdCQVdELElBWEMsRUFXOEI7QUFBQSx3Q0FBL0IsSUFBK0I7QUFBL0IsWUFBK0I7QUFBQTs7QUFDakM7QUFDQTtBQUFDLE9BQUN2TSxHQUFHLENBQUhBLElBQUcsQ0FBSEEsSUFBRCxnQkFBK0J3TSxpQkFBRCxFQUFzQjtBQUNuREEsZUFBTyxNQUFQQTtBQUREO0FBYkw7QUFBTyxHQUFQO0FBa0JEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdDRDs7Ozs7O0FBR087O0FBQUEsSUFBTTFELGFBQWEsZ0JBQUd0RyxnQ0FBdEIsSUFBc0JBLENBQXRCOzs7O0FBRVAsVUFBMkM7QUFDekNzRyxlQUFhLENBQWJBO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZEOztBQUtBOztBQU1BOztBQUNBOztBQUNBOztBQUNBOztBQVVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFsQ0E7QUFBQTtBQUNBOzs7QUErREE7O0FBRUEsSUFBSS9FLEtBQUosRUFBcUMsRUFLckM7O0FBQUEsSUFBTTBJLFFBQVEsR0FBSTFJLFVBQWxCOztBQUVBLGtDQUFrQztBQUNoQyxTQUFPbEMsTUFBTSxDQUFOQSxPQUFjLFVBQWRBLGlCQUFjLENBQWRBLEVBQTRDO0FBQ2pENkssYUFBUyxFQURYO0FBQW1ELEdBQTVDN0ssQ0FBUDtBQUtGOztBQUFBLHFDQUFzRDtBQUNwRCxTQUFPOEssTUFBTSxJQUFJOUksSUFBSSxDQUFKQSxXQUFWOEksR0FBVTlJLENBQVY4SSxHQUNIOUksSUFBSSxLQUFKQSxNQUNFLHdEQURGQSxNQUNFLENBREZBLGFBRUs4SSxNQUZMOUksU0FFYytJLGVBQWUsQ0FBZkEsSUFBZSxDQUFmQSxXQUFnQy9JLElBQUksQ0FBSkEsVUFBaEMrSSxDQUFnQy9JLENBQWhDK0ksR0FIWEQsSUFDSDlJLENBREc4SSxHQUFQO0FBT0s7O0FBQUEsK0RBS0w7QUFDQSxNQUFJNUksS0FBSixFQUFxQyx1QkFhckM7O0FBQUE7QUFHSzs7QUFBQSxnREFJTDtBQUNBLE1BQUlBLEtBQUosRUFBcUMsRUFRckM7O0FBQUE7QUFHSzs7QUFBQSxpQ0FBa0Q7QUFDdkQsTUFBSUEsS0FBSixFQUFxQyxFQU1yQzs7QUFBQTtBQUdGOztBQUFBLCtCQUF1QztBQUNyQyxNQUFNOEksVUFBVSxHQUFHaEosSUFBSSxDQUFKQSxRQUFuQixHQUFtQkEsQ0FBbkI7QUFDQSxNQUFNaUosU0FBUyxHQUFHakosSUFBSSxDQUFKQSxRQUFsQixHQUFrQkEsQ0FBbEI7O0FBRUEsTUFBSWdKLFVBQVUsR0FBRyxDQUFiQSxLQUFtQkMsU0FBUyxHQUFHLENBQW5DLEdBQXVDO0FBQ3JDakosUUFBSSxHQUFHQSxJQUFJLENBQUpBLGFBQWtCZ0osVUFBVSxHQUFHLENBQWJBLGlCQUF6QmhKLFNBQU9BLENBQVBBO0FBRUY7O0FBQUE7QUFHSzs7QUFBQSwyQkFBNEM7QUFDakRBLE1BQUksR0FBRytJLGVBQWUsQ0FBdEIvSSxJQUFzQixDQUF0QkE7QUFDQSxTQUFPQSxJQUFJLEtBQUpBLFlBQXFCQSxJQUFJLENBQUpBLFdBQWdCNEksUUFBUSxHQUFwRCxHQUE0QjVJLENBQTVCO0FBR0s7O0FBQUEsMkJBQTJDO0FBQ2hEO0FBQ0EsU0FBT2tKLGFBQWEsT0FBcEIsUUFBb0IsQ0FBcEI7QUFHSzs7QUFBQSwyQkFBMkM7QUFDaERsSixNQUFJLEdBQUdBLElBQUksQ0FBSkEsTUFBVzRJLFFBQVEsQ0FBMUI1SSxNQUFPQSxDQUFQQTtBQUNBLE1BQUksQ0FBQ0EsSUFBSSxDQUFKQSxXQUFMLEdBQUtBLENBQUwsRUFBMkJBLElBQUksY0FBSkEsSUFBSSxDQUFKQTtBQUMzQjtBQUdGO0FBQUE7QUFDQTtBQUNBOzs7QUFDTyx5QkFBMEM7QUFDL0MsTUFBSW1KLEdBQUcsQ0FBSEEsV0FBSixHQUFJQSxDQUFKLEVBQXlCOztBQUN6QixNQUFJO0FBQ0Y7QUFDQSxRQUFNQyxjQUFjLEdBQUcsV0FBdkIsaUJBQXVCLEdBQXZCO0FBQ0EsUUFBTUMsUUFBUSxHQUFHLGFBQWpCLGNBQWlCLENBQWpCO0FBQ0EsV0FBT0EsUUFBUSxDQUFSQSw2QkFBc0NDLFdBQVcsQ0FBQ0QsUUFBUSxDQUFqRSxRQUF3RCxDQUF4RDtBQUNBLEdBTEYsQ0FLRSxVQUFVO0FBQ1Y7QUFFSDtBQUlNOztBQUFBLGlEQUlMO0FBQ0EsTUFBSUUsaUJBQWlCLEdBQXJCO0FBRUEsTUFBTUMsWUFBWSxHQUFHLCtCQUFyQixLQUFxQixDQUFyQjtBQUNBLE1BQU1DLGFBQWEsR0FBR0QsWUFBWSxDQUFsQztBQUNBLE1BQU1FLGNBQWMsR0FDbEI7QUFDQSxHQUFDQyxVQUFVLEtBQVZBLFFBQXVCLGlEQUF2QkEsVUFBdUIsQ0FBdkJBLEdBQUQsT0FDQTtBQUNBO0FBSkY7QUFPQUosbUJBQWlCLEdBQWpCQTtBQUNBLE1BQU1LLE1BQU0sR0FBRzVMLE1BQU0sQ0FBTkEsS0FBZixhQUFlQSxDQUFmOztBQUVBLE1BQ0UsQ0FBQzRMLE1BQU0sQ0FBTkEsTUFBY0MsZUFBRCxFQUFXO0FBQ3ZCLFFBQUl6SSxLQUFLLEdBQUdzSSxjQUFjLENBQWRBLEtBQWMsQ0FBZEEsSUFBWjtBQUR1QiwrQkFFTUQsYUFBYSxDQUExQyxLQUEwQyxDQUZuQjtBQUFBLFFBRWpCLE1BRmlCLHdCQUVqQixNQUZpQjtBQUFBLFFBRWpCLFFBRmlCLHdCQUVqQixRQUZpQixFQUl2QjtBQUNBOztBQUNBLFFBQUlLLFFBQVEsY0FBT0MsTUFBTSxXQUFXLEVBQXhCLFNBQVosS0FBWSxNQUFaOztBQUNBLGtCQUFjO0FBQ1pELGNBQVEsYUFBTSxlQUFlLEVBQXJCLGNBQVJBLFFBQVEsTUFBUkE7QUFFRjs7QUFBQSxRQUFJQyxNQUFNLElBQUksQ0FBQzFFLEtBQUssQ0FBTEEsUUFBZixLQUFlQSxDQUFmLEVBQXFDakUsS0FBSyxHQUFHLENBQVJBLEtBQVEsQ0FBUkE7QUFFckMsV0FDRSxDQUFDNEksUUFBUSxJQUFJSCxLQUFLLElBQWxCLHFCQUNBO0FBQ0NOLHFCQUFpQixHQUNoQkEsaUJBQWlCLENBQWpCQSxrQkFFRVEsTUFBTSxHQUNEM0ksS0FBRCxJQUFDQSxFQUVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0M2SSxxQkFBRDtBQUFBLGFBQWFDLGtCQUFrQixDQU5uQyxPQU1tQyxDQUEvQjtBQUFBLEtBTkg5SSxFQUFELElBQUNBLENBREMsR0FDREEsQ0FEQyxHQVVGOEksa0JBQWtCLENBWnhCWCxLQVl3QixDQVp4QkEsS0FKSixHQUNFLENBREY7QUFiSixHQUNHSyxDQURILEVBaUNFO0FBQ0FMLHFCQUFpQixHQUFqQkEsR0FEQSxDQUN1QjtBQUV2QjtBQUNBO0FBRUY7O0FBQUEsU0FBTztBQUNMSyxVQURLLEVBQ0xBLE1BREs7QUFFTE8sVUFBTSxFQUZSO0FBQU8sR0FBUDtBQU1GOztBQUFBLDJDQUFxRTtBQUNuRSxNQUFNQyxhQUE2QixHQUFuQztBQUVBcE0sUUFBTSxDQUFOQSxvQkFBNEJKLGFBQUQsRUFBUztBQUNsQyxRQUFJLENBQUNnTSxNQUFNLENBQU5BLFNBQUwsR0FBS0EsQ0FBTCxFQUEyQjtBQUN6QlEsbUJBQWEsQ0FBYkEsR0FBYSxDQUFiQSxHQUFxQkMsS0FBSyxDQUExQkQsR0FBMEIsQ0FBMUJBO0FBRUg7QUFKRHBNO0FBS0E7QUFHRjtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxtREFJRztBQUNSO0FBQ0EsTUFBTXNNLElBQUksR0FBRyxxQkFBYixVQUFhLENBQWI7QUFDQSxNQUFNQyxXQUFXLEdBQ2Ysa0NBQWtDLGlDQURwQyxJQUNvQyxDQURwQyxDQUhRLENBS1I7O0FBQ0EsTUFBSSxDQUFDQyxVQUFVLENBQWYsV0FBZSxDQUFmLEVBQThCO0FBQzVCLFdBQVFDLFNBQVMsR0FBRyxDQUFILFdBQUcsQ0FBSCxHQUFqQjtBQUVGOztBQUFBLE1BQUk7QUFDRixRQUFNQyxRQUFRLEdBQUcscUJBQWpCLElBQWlCLENBQWpCO0FBQ0FBLFlBQVEsQ0FBUkEsV0FBb0Isd0RBQTJCQSxRQUFRLENBQXZEQSxRQUFvQixDQUFwQkE7QUFDQSxRQUFJQyxjQUFjLEdBQWxCOztBQUVBLFFBQ0UsK0JBQWVELFFBQVEsQ0FBdkIsYUFDQUEsUUFBUSxDQURSLGdCQURGLFdBSUU7QUFDQSxVQUFNTCxLQUFLLEdBQUcseUNBQXVCSyxRQUFRLENBQTdDLFlBQWMsQ0FBZDs7QUFEQSwyQkFHMkJFLGFBQWEsQ0FDdENGLFFBQVEsQ0FEOEIsVUFFdENBLFFBQVEsQ0FGOEIsVUFBeEMsS0FBd0MsQ0FIeEM7QUFBQSxVQUdNLE1BSE4sa0JBR00sTUFITjtBQUFBLFVBR00sTUFITixrQkFHTSxNQUhOOztBQVNBLGtCQUFZO0FBQ1ZDLHNCQUFjLEdBQUcsaUNBQXFCO0FBQ3BDOUwsa0JBQVEsRUFENEI7QUFFcENnTSxjQUFJLEVBQUVILFFBQVEsQ0FGc0I7QUFHcENMLGVBQUssRUFBRVMsa0JBQWtCLFFBSDNCSCxNQUcyQjtBQUhXLFNBQXJCLENBQWpCQTtBQU1IO0FBRUQsS0EzQkUsQ0EyQkY7OztBQUNBLFFBQU1JLFlBQVksR0FDaEJMLFFBQVEsQ0FBUkEsV0FBb0JKLElBQUksQ0FBeEJJLFNBQ0lBLFFBQVEsQ0FBUkEsV0FBb0JBLFFBQVEsQ0FBUkEsT0FEeEJBLE1BQ0lBLENBREpBLEdBRUlBLFFBQVEsQ0FIZDtBQUtBLFdBQVFELFNBQVMsR0FDYixlQUFlRSxjQUFjLElBRGhCLFlBQ2IsQ0FEYSxHQUFqQjtBQUdBLEdBcENGLENBb0NFLFVBQVU7QUFDVixXQUFRRixTQUFTLEdBQUcsQ0FBSCxXQUFHLENBQUgsR0FBakI7QUFFSDtBQUVEOztBQUFBLDBCQUFrQztBQUNoQyxNQUFNTyxNQUFNLEdBQUcsV0FBZixpQkFBZSxHQUFmO0FBRUEsU0FBTzdCLEdBQUcsQ0FBSEEscUJBQXlCQSxHQUFHLENBQUhBLFVBQWM2QixNQUFNLENBQTdDN0IsTUFBeUJBLENBQXpCQSxHQUFQO0FBR0Y7O0FBQUEsdUNBQThEO0FBQzVEO0FBQ0E7QUFGNEQscUJBRzNCOEIsV0FBVyxDQUFDbk8sTUFBTSxDQUFQLGVBQTVDLElBQTRDLENBSGdCO0FBQUE7QUFBQSxNQUd4RCxZQUh3RDtBQUFBLE1BR3hELFVBSHdEOztBQUk1RCxNQUFNa08sTUFBTSxHQUFHLFdBQWYsaUJBQWUsR0FBZjtBQUNBLE1BQU1FLGFBQWEsR0FBR0gsWUFBWSxDQUFaQSxXQUF0QixNQUFzQkEsQ0FBdEI7QUFDQSxNQUFNSSxXQUFXLEdBQUdyTSxVQUFVLElBQUlBLFVBQVUsQ0FBVkEsV0FBbEMsTUFBa0NBLENBQWxDO0FBRUFpTSxjQUFZLEdBQUdLLFdBQVcsQ0FBMUJMLFlBQTBCLENBQTFCQTtBQUNBak0sWUFBVSxHQUFHQSxVQUFVLEdBQUdzTSxXQUFXLENBQWQsVUFBYyxDQUFkLEdBQXZCdE07QUFFQSxNQUFNdU0sV0FBVyxHQUFHSCxhQUFhLGtCQUFrQkksV0FBVyxDQUE5RCxZQUE4RCxDQUE5RDtBQUNBLE1BQU1DLFVBQVUsR0FBR25RLEVBQUUsR0FDakJnUSxXQUFXLENBQUNILFdBQVcsQ0FBQ25PLE1BQU0sQ0FBUCxVQUROLEVBQ00sQ0FBWixDQURNLEdBRWpCZ0MsVUFBVSxJQUZkO0FBSUEsU0FBTztBQUNMcUssT0FBRyxFQURFO0FBRUwvTixNQUFFLEVBQUUrUCxXQUFXLGdCQUFnQkcsV0FBVyxDQUY1QyxVQUU0QztBQUZyQyxHQUFQO0FBb0VGOztBQUFBLElBQU1FLHVCQUF1QixHQUMzQnRMLFVBR0EsS0FKRjtBQVlBLElBQU11TCxrQkFBa0IsR0FBRzlKLE1BQU0sQ0FBakMsb0JBQWlDLENBQWpDOztBQUVBLG1DQUFpRTtBQUMvRCxTQUFPLEtBQUssTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0ErSixlQUFXLEVBWk47QUFBVyxHQUFOLENBQUwsTUFhRWpLLGFBQUQsRUFBUztBQUNmLFFBQUksQ0FBQ0EsR0FBRyxDQUFSLElBQWE7QUFDWCxVQUFJa0ssUUFBUSxHQUFSQSxLQUFnQmxLLEdBQUcsQ0FBSEEsVUFBcEIsS0FBdUM7QUFDckMsZUFBT21LLFVBQVUsTUFBTUQsUUFBUSxHQUEvQixDQUFpQixDQUFqQjtBQUVGOztBQUFBLFVBQUlsSyxHQUFHLENBQUhBLFdBQUosS0FBd0I7QUFDdEIsZUFBT0EsR0FBRyxDQUFIQSxZQUFpQm9LLGNBQUQsRUFBVTtBQUMvQixjQUFJQSxJQUFJLENBQVIsVUFBbUI7QUFDakIsbUJBQU87QUFBRUMsc0JBQVEsRUFBakI7QUFBTyxhQUFQO0FBRUY7O0FBQUEsZ0JBQU0sSUFBTixLQUFNLCtCQUFOO0FBSkYsU0FBT3JLLENBQVA7QUFPRjs7QUFBQSxZQUFNLElBQU4sS0FBTSwrQkFBTjtBQUVGOztBQUFBLFdBQU9BLEdBQUcsQ0FBVixJQUFPQSxFQUFQO0FBNUJGLEdBQU8sQ0FBUDtBQWdDRjs7QUFBQSxpREFBa0U7QUFDaEUsU0FBTyxVQUFVLFdBQVdzSyxjQUFjLE9BQW5DLENBQVUsQ0FBVixVQUFvRHZQLGFBQUQsRUFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBRUEsUUFBSSxDQUFKLGdCQUFxQjtBQUNuQjtBQUVGOztBQUFBO0FBUkYsR0FBTyxDQUFQO0FBWWE7O0lBQU1tSSxNO0FBT25CO0FBQ0Y7QUFSa0Q7QUFXaEQ7QUFzQkFxSCxrQkFBVyxTQUFYQSxFQUFXLE1BQVhBLEVBQVcsR0FBWEEsUUErQkU7QUFBQTs7QUFBQSxRQTNCQSxZQTJCQSxRQTNCQSxZQTJCQTtBQUFBLFFBM0JBLFVBMkJBLFFBM0JBLFVBMkJBO0FBQUEsUUEzQkEsR0EyQkEsUUEzQkEsR0EyQkE7QUFBQSxRQTNCQSxPQTJCQSxRQTNCQSxPQTJCQTtBQUFBLFFBM0JBLFNBMkJBLFFBM0JBLFNBMkJBO0FBQUEsUUEzQkEsR0EyQkEsUUEzQkEsR0EyQkE7QUFBQSxRQTNCQSxZQTJCQSxRQTNCQSxZQTJCQTtBQUFBLFFBM0JBLFVBMkJBLFFBM0JBLFVBMkJBO0FBQUEsUUEzQkEsTUEyQkEsUUEzQkEsTUEyQkE7QUFBQSxRQTNCQSxPQTJCQSxRQTNCQSxPQTJCQTtBQUFBLFFBM0JBLGFBMkJBLFFBM0JBLGFBMkJBO0FBQUEsUUEvQlMsYUErQlQsUUEvQlMsYUErQlQ7O0FBQUE7O0FBQUEsU0EvREZ6SixLQStERTtBQUFBLFNBOURGMUQsUUE4REU7QUFBQSxTQTdERndMLEtBNkRFO0FBQUEsU0E1REY0QixNQTRERTtBQUFBLFNBM0RGckQsUUEyREU7QUFBQSxTQXRERnNELFVBc0RFO0FBQUEsU0FwREZDLEdBb0RFLEdBcERrQyxFQW9EbEM7QUFBQSxTQW5ERkMsR0FtREU7QUFBQSxTQWxERkMsR0FrREU7QUFBQSxTQWpERkMsVUFpREU7QUFBQSxTQWhERkMsSUFnREU7QUFBQSxTQS9DRkMsTUErQ0U7QUFBQSxTQTlDRkMsUUE4Q0U7QUFBQSxTQTdDRkMsS0E2Q0U7QUFBQSxTQTVDRkMsVUE0Q0U7QUFBQSxTQTNDRkMsY0EyQ0U7QUFBQSxTQTFDRkMsUUEwQ0U7QUFBQSxTQXpDRnBQLE1BeUNFO0FBQUEsU0F4Q0Y2SyxPQXdDRTtBQUFBLFNBdkNGd0UsYUF1Q0U7QUFBQSxTQXRDRkMsYUFzQ0U7QUFBQSxTQXJDRkMsT0FxQ0U7QUFBQSxTQW5DTUMsSUFtQ04sR0FuQ3FCLENBbUNyQjs7QUFBQSxzQkF5Rlk5UCxXQUFELEVBQTRCO0FBQ3ZDLFVBQU0rUCxLQUFLLEdBQUcvUCxDQUFDLENBQWY7O0FBRUEsVUFBSSxDQUFKLE9BQVk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUVSxZQVVKLFVBVkksR0FVVixLQVZVLENBVUosUUFWSTtBQUFBLFlBVUosS0FWSSxHQVVWLEtBVlUsQ0FVSixLQVZJOztBQVdWLDBDQUVFLGlDQUFxQjtBQUFFMEIsa0JBQVEsRUFBRXlNLFdBQVcsQ0FBdkIsVUFBdUIsQ0FBdkI7QUFBbUNqQixlQUYxRCxFQUUwREE7QUFBbkMsU0FBckIsQ0FGRixFQUdFLFdBSEYsTUFHRSxHQUhGOztBQUtBO0FBR0Y7O0FBQUEsVUFBSSxDQUFDNkMsS0FBSyxDQUFWLEtBQWdCO0FBQ2Q7QUFHRjs7QUFBQTtBQTFCdUMsVUEyQmpDLEdBM0JpQyxHQTJCdkMsS0EzQnVDLENBMkJqQyxHQTNCaUM7QUFBQSxVQTJCakMsRUEzQmlDLEdBMkJ2QyxLQTNCdUMsQ0EyQmpDLEVBM0JpQztBQUFBLFVBMkJqQyxPQTNCaUMsR0EyQnZDLEtBM0J1QyxDQTJCakMsT0EzQmlDO0FBQUEsVUEyQmpDLEdBM0JpQyxHQTJCdkMsS0EzQnVDLENBMkJqQyxHQTNCaUM7O0FBNEJ2QyxVQUFJaE4sS0FBSixFQUEyQyxVQXFCM0M7O0FBQUE7O0FBakR1QyxrQkFtRGxCLHdDQUFyQixHQUFxQixDQW5Ea0I7QUFBQSxVQW1EakMsUUFuRGlDLFNBbURqQyxRQW5EaUMsRUFxRHZDO0FBQ0E7OztBQUNBLFVBQUksZUFBYzlFLEVBQUUsS0FBSyxNQUFyQixVQUFvQ3lELFFBQVEsS0FBSyxNQUFyRCxVQUFvRTtBQUNsRTtBQUdGLE9BM0R1QyxDQTJEdkM7QUFDQTs7O0FBQ0EsVUFBSSxjQUFhLENBQUMsV0FBbEIsS0FBa0IsQ0FBbEIsRUFBb0M7QUFDbEM7QUFHRjs7QUFBQSw0Q0FJRWIsTUFBTSxDQUFOQSxvQkFBcUU7QUFDbkVSLGVBQU8sRUFBRVIsT0FBTyxDQUFQQSxXQUFtQixNQUR1QztBQUVuRVMsY0FBTSxFQUFFVCxPQUFPLENBQVBBLFVBQWtCLE1BTjlCO0FBSXVFLE9BQXJFZ0IsQ0FKRjtBQTFKQSxPQUNBOzs7QUFDQSxpQkFBYSxxREFBYixTQUFhLENBQWIsQ0FGQSxDQUlBOztBQUNBLHlCQUxBLENBTUE7QUFDQTtBQUNBOztBQUNBLFFBQUlhLFNBQVEsS0FBWixXQUE0QjtBQUMxQixzQkFBZ0IsS0FBaEIsU0FBOEI7QUFDNUJzTyxpQkFENEIsRUFDNUJBLFNBRDRCO0FBRTVCQyxlQUFPLEVBRnFCO0FBRzVCblAsYUFBSyxFQUh1QjtBQUk1QnpCLFdBSjRCLEVBSTVCQSxHQUo0QjtBQUs1QjZRLGVBQU8sRUFBRUMsWUFBWSxJQUFJQSxZQUFZLENBTFQ7QUFNNUJDLGVBQU8sRUFBRUQsWUFBWSxJQUFJQSxZQUFZLENBTnZDO0FBQThCLE9BQTlCO0FBVUY7O0FBQUEsK0JBQTJCO0FBQ3pCSCxlQUFTLEVBRGdCO0FBRXpCdkssaUJBQVcsRUFBRTtBQUZmO0FBRWU7QUFGWSxLQUEzQixDQXBCQSxDQTJCQTtBQUNBOztBQUNBLGtCQUFjK0IsTUFBTSxDQUFwQjtBQUVBO0FBQ0E7QUFDQSx3QkFqQ0EsQ0FrQ0E7QUFDQTs7QUFDQSxRQUFNNkksaUJBQWlCLEdBQ3JCLDZDQUE0QnBOLElBQUksQ0FBSkEsY0FEOUI7O0FBR0Esa0JBQWNvTixpQkFBaUIsZUFBL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkEzQ0EsQ0E0Q0E7QUFDQTs7QUFDQTtBQUVBO0FBRUEsbUJBQWUsQ0FBQyxFQUNkcE4sSUFBSSxDQUFKQSxzQkFDQUEsSUFBSSxDQUFKQSxjQURBQSxPQUVDLHNCQUFzQixDQUFDQSxJQUFJLENBQUpBLFNBSDFCLE1BQWdCLENBQWhCOztBQU1BLFFBQUlGLEtBQUosRUFBcUMsRUFPckM7O0FBQUEsY0FBbUM7QUFDakM7QUFDQTtBQUNBLFVBQUk5RSxHQUFFLENBQUZBLGlCQUFKLE1BQThCO0FBQzVCO0FBQ0E7QUFDQSx5Q0FFRSxpQ0FBcUI7QUFBRXlELGtCQUFRLEVBQUV5TSxXQUFXLENBQXZCLFNBQXVCLENBQXZCO0FBQW1DakIsZUFBSyxFQUYvRDtBQUV1QixTQUFyQixDQUZGLEVBR0UsV0FIRixNQUdFLEdBSEYsRUFJRTtBQUFFNU0sZ0JBSkosRUFJSUE7QUFBRixTQUpGO0FBUUY2RDs7QUFBQUEsWUFBTSxDQUFOQSw2QkFBb0MsS0FBcENBLFlBZGlDLENBZ0JqQztBQUNBOztBQUNBLFVBQUlwQixLQUFKLEVBQTJDLEVBSzVDO0FBQ0Y7QUErRUR1Tjs7Ozs2QkFBZTtBQUNibk0sWUFBTSxDQUFOQTtBQUdGO0FBQUE7QUFDRjtBQUNBOzs7OzJCQUNTO0FBQ0xBLFlBQU0sQ0FBTkE7QUFHRjtBQUFBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozt5QkFDTSxHLEVBQUEsRSxFQUFzRDtBQUFBLFVBQWpDdEUsT0FBaUMsdUVBQXRELEVBQXNEOztBQUN4RCxVQUFJa0QsS0FBSixFQUEyQyxFQWEzQzs7QUFBQTs7QUFkd0QsMEJBY3hDd04sWUFBWSxZQUEzQixFQUEyQixDQWQ0Qjs7QUFjdEQsU0Fkc0QsaUJBY3RELEdBZHNEO0FBY3RELFFBZHNELGlCQWN0RCxFQWRzRDtBQWV4RCxhQUFPLGtDQUFQLE9BQU8sQ0FBUDtBQUdGO0FBQUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzRCQUNTLEcsRUFBQSxFLEVBQXNEO0FBQUEsVUFBakMxUSxPQUFpQyx1RUFBdEQsRUFBc0Q7QUFDM0Q7O0FBRDJELDJCQUMzQzBRLFlBQVksWUFBM0IsRUFBMkIsQ0FEK0I7O0FBQ3pELFNBRHlELGtCQUN6RCxHQUR5RDtBQUN6RCxRQUR5RCxrQkFDekQsRUFEeUQ7QUFFM0QsYUFBTyxxQ0FBUCxPQUFPLENBQVA7QUFHRjs7Ozs4RkFBQSxNLEVBQUEsRyxFQUFBLEUsRUFBQSxPLEVBQUEsWTs7Ozs7Ozs7O29CQU9PbEQsVUFBVSxDQUFmLEdBQWUsQzs7Ozs7QUFDYmxKLHNCQUFNLENBQU5BO2lEQUNBLEs7OztBQUdGO0FBQ0E7QUFDQSxvQkFBS3RFLE9BQUQsQ0FBSixJQUF5QjtBQUN2QjtBQUdGLGlCLENBQUE7QUFDQTtBQUNBOzs7QUFDQUEsdUJBQU8sQ0FBUEEsU0FBaUIsQ0FBQyxxQkFBRUEsT0FBTyxDQUFULG9DQUFsQkEsSUFBa0IsQ0FBbEJBO0FBRUkyUSw0QixHQUFlM1EsT0FBTyxDQUFQQSxXQUFtQixLQUF0QyxNOzs7Ozs7O0FBR0UsOEJBQ0VBLE9BQU8sQ0FBUEEsbUJBQ0ksS0FESkEsZ0JBRUlBLE9BQU8sQ0FBUEEsVUFBa0IsS0FIeEI7O0FBS0Esb0JBQUksT0FBT0EsT0FBTyxDQUFkLFdBQUosYUFBMkM7QUFDekNBLHlCQUFPLENBQVBBLFNBQWlCLEtBQWpCQTtBQUdGOztBQUFNNFEsd0IsR0FBVyx3Q0FBaUJ0RSxXQUFXLENBQVhBLEVBQVcsQ0FBWEEsR0FBa0J1RSxXQUFXLENBQTdCdkUsRUFBNkIsQ0FBN0JBLEdBQWxDLEVBQWlCLEM7QUFDWHdFLGdDLEdBQW1CLDhDQUN2QkYsUUFBUSxDQURlLFVBRXZCLEtBRkYsT0FBeUIsQzs7QUFLekIsb0JBQUlFLGdCQUFnQixDQUFwQixnQkFBcUM7QUFDbkMsZ0NBQWNBLGdCQUFnQixDQUE5QjtBQUNBRiwwQkFBUSxDQUFSQSxXQUFvQnRDLFdBQVcsQ0FBQ3NDLFFBQVEsQ0FBeENBLFFBQStCLENBQS9CQTtBQUNBeFMsb0JBQUUsR0FBRyxpQ0FBTEEsUUFBSyxDQUFMQTtBQUNBK04scUJBQUcsR0FBR21DLFdBQVcsQ0FDZiw4Q0FDRWhDLFdBQVcsQ0FBWEEsR0FBVyxDQUFYQSxHQUFtQnVFLFdBQVcsQ0FBOUJ2RSxHQUE4QixDQUE5QkEsR0FERixLQUVFLEtBRkYsU0FERkgsUUFBaUIsQ0FBakJBO0FBT0Y7O0FBQUk0RSwyQixHQUFKLEssRUFFQTtBQUNBOztBQUNBLG9CQUFJN04sS0FBSixFQUFxQyxFQVdyQzs7QUFBTThOLDhCLEdBQWlCQyxrQkFBa0IsQ0FDdkMsS0FEdUMsMEJBR3ZDLEtBSEYsTUFBeUMsQyxFQU16QztBQUNBOztBQUNBLG9CQUFJL04sS0FBSixFQUFxQyxFQXdCckM7O3FCQUFBLFc7Ozs7O2lEQUNTLFlBQVksWUFBTSxDQUF6QixDQUFPLEM7OztBQUlYLG9CQUFJLENBQUVsRCxPQUFELENBQUwsSUFBMEI7QUFDeEI7QUFFRixpQixDQUFBOzs7QUFDQSxvQkFBSWtSLE9BQUosSUFBUTtBQUNOQyw2QkFBVyxDQUFYQTtBQUdGOzttQ0FBQSxPLENBQVEzUSxPLEVBQUFBLE8saUNBQUYsSztBQUNBNFEsMEIsR0FBYTtBQUFFNVEseUJBQXJCLEVBQXFCQTtBQUFGLGlCOztBQUVuQixvQkFBSSxLQUFKLGdCQUF5QjtBQUN2QiwwQ0FBd0IsS0FBeEI7QUFHRnBDOztBQUFBQSxrQkFBRSxHQUFHa1EsV0FBVyxDQUNkK0MsU0FBUyxDQUNQL0UsV0FBVyxDQUFYQSxFQUFXLENBQVhBLEdBQWtCdUUsV0FBVyxDQUE3QnZFLEVBQTZCLENBQTdCQSxHQURPLElBRVB0TSxPQUFPLENBRkEsUUFHUCxLQUpKNUIsYUFDVyxDQURLLENBQWhCQTtBQU9Na1QseUIsR0FBWUMsU0FBUyxDQUN6QmpGLFdBQVcsQ0FBWEEsRUFBVyxDQUFYQSxHQUFrQnVFLFdBQVcsQ0FBN0J2RSxFQUE2QixDQUE3QkEsR0FEeUIsSUFFekIsS0FGRixNQUEyQixDO0FBSTNCLHlDLENBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7c0JBQ0ksQ0FBRXRNLE9BQUQsQ0FBRCxNQUF3QixxQkFBNUIsU0FBNEIsQzs7Ozs7QUFDMUI7QUFDQTJILHNCQUFNLENBQU5BLCtDLENBQ0E7O0FBQ0E7QUFDQTtBQUNBLDRCQUFZLGdCQUFnQixLQUE1QixLQUFZLENBQVo7QUFDQUEsc0JBQU0sQ0FBTkE7aURBQ0EsSTs7O0FBR0U2SixzQixHQUFTLHdDQUFiLEdBQWEsQzswQkFDYixNLEVBQUksUSxXQUFBLFEsRUFBQSxLLFdBQUEsSyxFQUVKO0FBQ0E7QUFDQTs7Ozt1QkFHZ0IsZ0JBQWRDLFdBQWMsRTs7O0FBQWRBLHFCOzt1QkFDbUMsaUJBQWxDLHNCQUFrQyxHOzs7O0FBQWpDLHdCLFVBQUVDLFU7Ozs7Ozs7QUFFSjtBQUNBO0FBQ0FwTixzQkFBTSxDQUFOQTtpREFDQSxLOzs7QUFHRmtOLHNCQUFNLEdBQUcsMEJBQVRBLEtBQVMsQ0FBVEE7O0FBRUEsb0JBQUlBLE1BQU0sQ0FBTkEsYUFBSixVQUFrQztBQUNoQzNQLDBCQUFRLEdBQUcyUCxNQUFNLENBQWpCM1A7QUFDQXNLLHFCQUFHLEdBQUcsaUNBQU5BLE1BQU0sQ0FBTkE7QUFHRixpQixDQUFBO0FBQ0E7QUFDQTs7O0FBQ0F0Syx3QkFBUSxHQUFHQSxRQUFRLEdBQ2YscURBQXdCZ1AsV0FBVyxDQURwQixRQUNvQixDQUFuQyxDQURlLEdBQW5CaFAsUyxDQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0Esb0JBQUksQ0FBQyxjQUFELFNBQUMsQ0FBRCxJQUE2QixDQUFqQyxjQUFnRDtBQUM5QzhQLHdCQUFNLEdBQU5BO0FBR0Y7O0FBQUlwTSxxQixHQUFRLHFEQUFaLFFBQVksQyxFQUVaO0FBQ0E7O0FBQ0l6RCwwQixHQUFKLEU7O0FBRUEsb0JBQUlvQixTQUFtQzlFLEVBQUUsQ0FBRkEsV0FBdkMsR0FBdUNBLENBQXZDLEVBQTJEO0FBQ3pEMEQsNEJBQVUsR0FBRyxpQ0FDWHdNLFdBQVcsQ0FDVCtDLFNBQVMsQ0FBQ1IsV0FBVyxDQUFDLDRDQUFiLFFBQVksQ0FBWixFQUE2QyxLQUY3QyxNQUVBLENBREEsQ0FEQSwwQkFPVmpQLFdBQUQ7QUFBQSwyQkFBZSxvQkFBa0I7QUFBRUMsOEJBQVEsRUFBNUI7QUFBa0IscUJBQWxCLFNBUEosUUFPWDtBQUFBLG1CQVBXLEVBUVgsS0FSRkMsT0FBYSxDQUFiQTs7QUFXQSxzQkFBSUEsVUFBVSxLQUFkLElBQXVCO0FBQ2Y4UCxpQ0FEZSxHQUNDLHFEQUNwQixrQkFDRTVRLE1BQU0sQ0FBTkEsbUJBQTBCO0FBQ3hCYSw4QkFBUSxFQUFFLDhDQUNSeUssV0FBVyxDQUFYQSxVQUFXLENBQVhBLEdBQTBCdUUsV0FBVyxDQUFyQ3ZFLFVBQXFDLENBQXJDQSxHQURRLFlBRVIsS0FGUSxTQUZkO0FBQzRCLHFCQUExQnRMLENBREYsZ0JBREYsUUFBc0IsQ0FERCxFQWNyQjtBQUNBOztBQUNBLHdCQUFJeVEsS0FBSyxDQUFMQSxTQUFKLGFBQUlBLENBQUosRUFBbUM7QUFDakNsTSwyQkFBSyxHQUFMQTtBQUNBMUQsOEJBQVEsR0FBUkE7QUFDQTJQLDRCQUFNLENBQU5BO0FBQ0FyRix5QkFBRyxHQUFHLGlDQUFOQSxNQUFNLENBQU5BO0FBRUg7QUFDRjtBQUVEOztvQkFBS3FCLFVBQVUsQ0FBZixFQUFlLEM7Ozs7Ozs7c0JBRUwsVUFDSCwwQkFBaUJyQixHQUFqQiwwQkFESCxFQUNHLDRIQURHLEM7OztBQU1SN0gsc0JBQU0sQ0FBTkE7aURBQ0EsSzs7O0FBR0Z4QywwQkFBVSxHQUFHeVAsU0FBUyxDQUFDVixXQUFXLENBQVosVUFBWSxDQUFaLEVBQTBCLEtBQWhEL08sTUFBc0IsQ0FBdEJBOztxQkFFSSwrQkFBSixLQUFJLEM7Ozs7O0FBQ0k4Tyx5QixHQUFXLHdDQUFqQixVQUFpQixDO0FBQ1hqRSwwQixHQUFhaUUsU0FBUSxDQUEzQixRO0FBRU1pQiwwQixHQUFhLCtCQUFuQixLQUFtQixDO0FBQ2JDLDBCLEdBQWEsK0NBQW5CLFVBQW1CLEM7QUFDYkMsaUMsR0FBb0J4TSxLQUFLLEtBQS9CLFU7QUFDTW9JLDhCLEdBQWlCb0UsaUJBQWlCLEdBQ3BDbkUsYUFBYSxvQkFEdUIsS0FDdkIsQ0FEdUIsR0FBeEMsRTs7c0JBSUksZUFBZ0JtRSxpQkFBaUIsSUFBSSxDQUFDcEUsY0FBYyxDQUF4RCxNOzs7OztBQUNRcUUsNkIsR0FBZ0JoUixNQUFNLENBQU5BLEtBQVk2USxVQUFVLENBQXRCN1EsZUFDbkI2TCxlQUFEO0FBQUEseUJBQVcsQ0FBQ1EsS0FBSyxDQURuQixLQUNtQixDQUFqQjtBQUFBLGlCQURvQnJNLEM7O3NCQUlsQmdSLGFBQWEsQ0FBYkEsU0FBSixDOzs7OztBQUNFLDBCQUEyQztBQUN6QzFTLHlCQUFPLENBQVBBLEtBQ0csVUFDQ3lTLGlCQURGLHVEQUFDLDBEQUtnQkMsYUFBYSxDQUFiQSxLQU5uQjFTLElBTW1CMFMsQ0FMaEIsNkJBREgxUztBQVlGOztzQkFBTSxVQUNKLENBQUN5UyxpQkFBaUIsa0NBQ1k1RixHQURaLDhDQUNtRDZGLGFBQWEsQ0FBYkEsS0FEbkQsSUFDbURBLENBRG5ELDBFQUlnQnJGLFVBSmhCLHNEQUFsQixLQUFrQixRQUFsQix1REFNSW9GLGlCQUFpQixpQ0ExQjNCLHNCQW9CTSxDQURJLEM7Ozs7Ozs7QUFhSCx1Q0FBdUI7QUFDNUIzVCxvQkFBRSxHQUFHLGlDQUNINEMsTUFBTSxDQUFOQSxzQkFBNEI7QUFDMUJhLDRCQUFRLEVBQUU4TCxjQUFjLENBREU7QUFFMUJOLHlCQUFLLEVBQUVTLGtCQUFrQixRQUFRSCxjQUFjLENBSG5EdlAsTUFHNkI7QUFGQyxtQkFBNUI0QyxDQURHLENBQUw1QztBQURLLHVCQU9BO0FBQ0w7QUFDQTRDLHdCQUFNLENBQU5BO0FBRUg7OztBQUVEMkcsc0JBQU0sQ0FBTkE7Ozt1QkFHd0IsMENBSXBCMkcsV0FBVyxDQUFDK0MsU0FBUyxhQUFhLEtBSmQsTUFJQyxDQUFWLENBSlMsRUFBdEIsVUFBc0IsQzs7O0FBQWxCWSx5Qjs2QkFPSixTLEVBQUksSyxjQUFBLEssRUFBQSxLLGNBQUEsSyxFQUFBLE8sY0FBQSxPLEVBQUEsTyxjQUFBLE8sRUFFSjs7c0JBQ0ksQ0FBQzVCLE9BQU8sSUFBUixZQUFKLEs7Ozs7O3NCQUNPcFAsS0FBRCxVQUFDQSxJQUE0QkEsS0FBRCxVQUFDQSxDQUFqQyxZOzs7OztBQUNRaVIsMkIsR0FBZWpSLEtBQUQsVUFBQ0EsQ0FBckIsWSxFQUVBO0FBQ0E7QUFDQTs7cUJBQ0lpUixXQUFXLENBQVhBLFdBQUosR0FBSUEsQzs7Ozs7QUFDSUMsMEIsR0FBYSx3Q0FBbkIsV0FBbUIsQzs7QUFDbkI7O3FCQUVJVixLQUFLLENBQUxBLFNBQWVVLFVBQVUsQ0FBN0IsUUFBSVYsQzs7Ozs7aUNBQ2lDZixZQUFZLG9CQUEvQyxXQUErQyxDLEVBQXpDLE0sa0JBQUV2RSxHLEVBQUYsSyxrQkFBZS9OLEU7aURBS2QsbUNBQVAsT0FBTyxDOzs7QUFJWGtHLHNCQUFNLENBQU5BO2lEQUNPLFlBQVksWUFBTSxDQUF6QixDQUFPLEM7OztzQkFJTHJELEtBQUssQ0FBTEEsYUFBSixrQjs7Ozs7Ozt1QkFJVSxvQkFBTixNQUFNLEM7OztBQUNObVIsNkJBQWEsR0FBYkE7Ozs7Ozs7QUFFQUEsNkJBQWEsR0FBYkE7Ozs7dUJBR2dCLDJEQUtoQjtBQUFFNVIseUJBQU8sRUFMWHlSO0FBS0UsaUJBTGdCLEM7OztBQUFsQkEseUI7OztBQVVKdEssc0JBQU0sQ0FBTkE7QUFDQTs7QUFFQSwwQkFBMkM7QUFDbkMwSyx5QkFEbUMsR0FDcEIseUJBQXJCLFNBRHlDO0FBRXZDL04sd0JBQUQsS0FBQ0EsQ0FBRCxhQUFDQSxHQUNBK04sT0FBTyxDQUFQQSxvQkFBNEJBLE9BQU8sQ0FBbkNBLHVCQUNBLENBQUVKLFNBQVMsQ0FBVixTQUFDQSxDQUZILGVBQUMzTjtBQUtKOzs7dUJBQU0sdURBTUpnTyxZQUFZLEtBQUt0UyxPQUFPLENBQVBBLFNBQWlCO0FBQUV1UyxtQkFBQyxFQUFIO0FBQVFDLG1CQUFDLEVBQTFCeFM7QUFBaUIsaUJBQWpCQSxHQU5iLElBTVEsQ0FOUixXQU9HRyxXQUFELEVBQU87QUFDYixzQkFBSUEsQ0FBQyxDQUFMLFdBQWlCcUcsS0FBSyxHQUFHQSxLQUFLLElBQTlCLENBQWlCQSxDQUFqQixLQUNLO0FBVFAsaUJBQU0sQzs7O3FCQVlOLEs7Ozs7O0FBQ0VtQixzQkFBTSxDQUFOQTtzQkFDQSxLOzs7QUFHRixvQkFBSXpFLEtBQUosRUFBcUMsRUFLckN5RTs7QUFBQUEsc0JBQU0sQ0FBTkE7aURBRUEsSTs7Ozs7O3FCQUVJbkksWUFBSixTOzs7OztpREFDRSxLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBTUssTSxFQUFBLEcsRUFBQSxFLEVBS0g7QUFBQSxVQUROUSxPQUNNLHVFQUxHLEVBS0g7O0FBQ04sZ0JBQTJDO0FBQ3pDLFlBQUksT0FBT3NFLE1BQU0sQ0FBYixZQUFKLGFBQTJDO0FBQ3pDaEYsaUJBQU8sQ0FBUEE7QUFDQTtBQUdGOztBQUFBLFlBQUksT0FBT2dGLE1BQU0sQ0FBTkEsUUFBUCxNQUFPQSxDQUFQLEtBQUosYUFBbUQ7QUFDakRoRixpQkFBTyxDQUFQQTtBQUNBO0FBRUg7QUFFRDs7QUFBQSxVQUFJcVMsTUFBTSxLQUFOQSxlQUEwQix5QkFBOUIsSUFBK0M7QUFDN0Msd0JBQWdCM1IsT0FBTyxDQUF2QjtBQUNBLGNBQU0sQ0FBTixnQkFDRTtBQUNFbU0sYUFERixFQUNFQSxHQURGO0FBRUUvTixZQUZGLEVBRUVBLEVBRkY7QUFHRTRCLGlCQUhGLEVBR0VBLE9BSEY7QUFJRXlTLGFBQUcsRUFKTDtBQUtFQyxhQUFHLEVBQUUsWUFBWWYsTUFBTSxLQUFOQSxjQUF5QixLQUF6QkEsT0FBcUMsWUFOMUQ7QUFDRSxTQURGLEVBUUU7QUFDQTtBQUNBO0FBVkY7QUFlSDtBQUVEOzs7OzZHQUFBLEcsRUFBQSxRLEVBQUEsSyxFQUFBLEUsRUFBQSxVLEVBQUEsYTs7Ozs7OztxQkFRTW5TLEdBQUcsQ0FBUCxTOzs7OztzQkFFRSxHOzs7c0JBR0UsdUNBQUosYTs7Ozs7QUFDRW1JLHNCQUFNLENBQU5BLHFELENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQXJELHNCQUFNLENBQU5BLG1CLENBRUE7QUFDQTs7c0JBQ01xTyxzQkFBTixFOzs7OztzQkFTRSxvQ0FDQSx1QkFGRixXOzs7OztBQUlFOzt1QkFBMkMsb0JBQTFDLFNBQTBDLEM7Ozs7QUFBekMseUIseUJBQUVDLEk7QUFBRiwyQix5QkFBQSxXOzs7QUFLRVgseUIsR0FBc0M7QUFDMUNoUix1QkFEMEMsRUFDMUNBLEtBRDBDO0FBRTFDa1AsMkJBRjBDLEVBRTFDQSxTQUYwQztBQUcxQ3ZLLDZCQUgwQyxFQUcxQ0EsV0FIMEM7QUFJMUNwRyxxQkFKMEMsRUFJMUNBLEdBSjBDO0FBSzFDZ0gsdUJBQUssRUFMUDtBQUE0QyxpQjs7b0JBUXZDeUwsU0FBUyxDQUFkLEs7Ozs7Ozs7dUJBRTRCLGdDQUFnQztBQUN0RHpTLHFCQURzRCxFQUN0REEsR0FEc0Q7QUFFdERxQywwQkFGc0QsRUFFdERBLFFBRnNEO0FBR3REd0wsdUJBSEY0RSxFQUdFNUU7QUFIc0QsaUJBQWhDLEM7OztBQUF4QjRFLHlCQUFTLENBQVRBLEs7Ozs7Ozs7QUFNQTNTLHVCQUFPLENBQVBBO0FBQ0EyUyx5QkFBUyxDQUFUQTs7O2tEQUlKLFM7Ozs7O2tEQUVPLHlFQUFQLElBQU8sQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxR0FXWCxLLEVBQUEsUSxFQUFBLEssRUFBQSxFLEVBQUEsVTs7Ozs7Ozs7OztBQVFVWSxpQyxHQUFrRCxnQkFBeEQsS0FBd0QsQzs7c0JBR3BEekIsVUFBVSxDQUFWQSxnQ0FBMkMsZUFBL0MsSzs7Ozs7a0RBQ0UsaUI7OztBQUdJMEIsK0IsR0FDSkQsaUJBQWlCLElBQUksYUFBckJBLGdDQURGLGlCOztxQkFJNENDLGU7Ozs7OytCQUFlLGU7Ozs7Ozt1QkFFakQsZ0NBQWlDck8sYUFBRDtBQUFBLHlCQUFVO0FBQzlDMEwsNkJBQVMsRUFBRTFMLEdBQUcsQ0FEZ0M7QUFFOUNtQiwrQkFBVyxFQUFFbkIsR0FBRyxDQUY4QjtBQUc5QzRMLDJCQUFPLEVBQUU1TCxHQUFHLENBQUhBLElBSHFDO0FBSTlDOEwsMkJBQU8sRUFBRTlMLEdBQUcsQ0FBSEEsSUFOZjtBQUVvRCxtQkFBVjtBQUFBLGlCQUFoQyxDOzs7Ozs7QUFGSndOLHlCO0FBU0EseUIsR0FBTixTLENBQU0sUyxFQUFBLE8sR0FBTixTLENBQU0sTyxFQUFBLE8sR0FBTixTLENBQU0sTzs7OzsyQkFHMkJ2VSxtQkFBTyxDQUF0QyxrREFBc0MsQyxFQUFoQyxrQixZQUFBLGtCOztvQkFDRHFWLGtCQUFrQixDQUF2QixTQUF1QixDOzs7OztzQkFDZiwyRUFBTixRQUFNLFE7OztBQVFWLG9CQUFJMUMsT0FBTyxJQUFYLFNBQXdCO0FBQ3RCMkMsMEJBQVEsR0FBRyw0QkFDVCxpQ0FBcUI7QUFBRW5SLDRCQUFGLEVBQUVBLFFBQUY7QUFBWXdMLHlCQUR4QixFQUN3QkE7QUFBWixtQkFBckIsQ0FEUyxFQUVUd0QsV0FBVyxDQUZGLEVBRUUsQ0FGRixXQUlULEtBSkZtQyxNQUFXLENBQVhBO0FBUUY7Ozt1QkFBb0IsY0FBd0M7QUFBQSx5QkFDMUQzQyxPQUFPLEdBQ0gsc0JBREcsUUFDSCxDQURHLEdBRUhFLE9BQU8sR0FDUCxzQkFETyxRQUNQLENBRE8sR0FFUCxrQ0FFRTtBQUNBO0FBQ0UxTyw0QkFERixFQUNFQSxRQURGO0FBRUV3TCx5QkFGRixFQUVFQSxLQUZGO0FBR0U0QiwwQkFBTSxFQVhoQjtBQVFRLG1CQUhGLENBTHNEO0FBQUEsaUJBQXhDLEM7OztBQUFkaE8scUI7QUFnQk5nUix5QkFBUyxDQUFUQTtBQUNBO2tEQUNBLFM7Ozs7O2tEQUVPLDZEQUFQLFVBQU8sQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQUlSLEssRUFBQSxRLEVBQUEsSyxFQUFBLEUsRUFBQSxJLEVBQUEsVyxFQU9jO0FBQ2Y7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQU8sa0JBQVAsV0FBTyxDQUFQO0FBR0Y7QUFBQTtBQUNGO0FBQ0E7QUFDQTs7OzttQ0FDZ0IsRSxFQUE2QjtBQUN6QztBQUdGZ0I7OztvQ0FBZSxFLEVBQXNCO0FBQ25DLFVBQUksQ0FBQyxLQUFMLFFBQWtCOztBQURpQiwrQkFFSCxrQkFBaEMsR0FBZ0MsQ0FGRztBQUFBO0FBQUEsVUFFN0IsWUFGNkI7QUFBQSxVQUU3QixPQUY2Qjs7QUFBQSxzQkFHSDdVLEVBQUUsQ0FBRkEsTUFBaEMsR0FBZ0NBLENBSEc7QUFBQTtBQUFBLFVBRzdCLFlBSDZCO0FBQUEsVUFHN0IsT0FINkIsa0JBS25DOzs7QUFDQSxVQUFJOFUsT0FBTyxJQUFJQyxZQUFZLEtBQXZCRCxnQkFBNENFLE9BQU8sS0FBdkQsU0FBcUU7QUFDbkU7QUFHRixPQVZtQyxDQVVuQzs7O0FBQ0EsVUFBSUQsWUFBWSxLQUFoQixjQUFtQztBQUNqQztBQUdGLE9BZm1DLENBZW5DO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxhQUFPQyxPQUFPLEtBQWQ7QUFHRkM7OztpQ0FBWSxFLEVBQW1CO0FBQUEsdUJBQ1pqVixFQUFFLENBQUZBLE1BQWpCLEdBQWlCQSxDQURZO0FBQUE7QUFBQSxVQUN2QixJQUR1QixrQkFFN0I7OztBQUNBLFVBQUl5UCxJQUFJLEtBQVIsSUFBaUI7QUFDZnZKLGNBQU0sQ0FBTkE7QUFDQTtBQUdGLE9BUjZCLENBUTdCOzs7QUFDQSxVQUFNZ1AsSUFBSSxHQUFHdFYsUUFBUSxDQUFSQSxlQUFiLElBQWFBLENBQWI7O0FBQ0EsZ0JBQVU7QUFDUnNWLFlBQUksQ0FBSkE7QUFDQTtBQUVGLE9BZDZCLENBYzdCO0FBQ0E7OztBQUNBLFVBQU1DLE1BQU0sR0FBR3ZWLFFBQVEsQ0FBUkEsd0JBQWYsQ0FBZUEsQ0FBZjs7QUFDQSxrQkFBWTtBQUNWdVYsY0FBTSxDQUFOQTtBQUVIO0FBRURDOzs7NkJBQVEsTSxFQUEwQjtBQUNoQyxhQUFPLGdCQUFQO0FBR0ZDOzs7aUNBQVksVSxFQUFBLEssRUFBK0Q7QUFBQSxVQUF0QkMsYUFBc0IsdUVBQS9ELElBQStEO0FBQUEsVUFDbkUsUUFEbUUsR0FDekUsVUFEeUUsQ0FDbkUsUUFEbUU7QUFFekUsVUFBTUMsYUFBYSxHQUFHLHFEQUNwQiw4Q0FBb0JELGFBQWEsR0FBRzdDLFdBQVcsQ0FBZCxRQUFjLENBQWQsR0FEbkMsUUFDRSxDQURvQixDQUF0Qjs7QUFJQSxVQUFJOEMsYUFBYSxLQUFiQSxVQUE0QkEsYUFBYSxLQUE3QyxXQUE2RDtBQUMzRDtBQUdGLE9BVnlFLENBVXpFOzs7QUFDQSxVQUFJLENBQUNsQyxLQUFLLENBQUxBLFNBQUwsYUFBS0EsQ0FBTCxFQUFxQztBQUNuQztBQUNBQSxhQUFLLENBQUxBLEtBQVltQixjQUFELEVBQVU7QUFDbkIsY0FDRSx3Q0FDQSw2Q0FGRixhQUVFLENBRkYsRUFHRTtBQUNBVCxzQkFBVSxDQUFWQSxXQUFzQnVCLGFBQWEsR0FBR3BGLFdBQVcsQ0FBZCxJQUFjLENBQWQsR0FBbkM2RDtBQUNBO0FBRUg7QUFSRFY7QUFVRlU7O0FBQUFBLGdCQUFVLENBQVZBLFdBQXNCLHFEQUF3QkEsVUFBVSxDQUF4REEsUUFBc0IsQ0FBdEJBO0FBQ0E7QUFHRjtBQUFBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7aUdBQ0UsRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUVsRCxzQiw4REFGRixHO0FBR0VqUCx1Qiw4REFIRixFO0FBS013UixzQixHQUFTLHdDQUFiLEdBQWEsQzsyQkFFYixNLEVBQUksUSxZQUFBLFE7O0FBRUosb0JBQUl0TyxLQUFKLEVBQXFDLEVBaUJyQzs7O3VCQUFvQixnQkFBcEIsV0FBb0IsRTs7O0FBQWR1TyxxQjtBQUVORCxzQkFBTSxHQUFHLGlDQUFUQSxLQUFTLENBQVRBOztBQUVBLG9CQUFJQSxNQUFNLENBQU5BLGFBQUosVUFBa0M7QUFDaEMzUCwwQkFBUSxHQUFHMlAsTUFBTSxDQUFqQjNQO0FBQ0FzSyxxQkFBRyxHQUFHLGlDQUFOQSxNQUFNLENBQU5BO0FBR0YsaUIsQ0FBQTs7Ozs7Ozs7QUFLTTVHLHFCLEdBQVEscURBQWQsUUFBYyxDOzt1QkFDUnJHLE9BQU8sQ0FBUEEsSUFBWSxDQUNoQixpQ0FBa0MwVSxlQUFELEVBQW9CO0FBQ25ELHlCQUFPQSxLQUFLLEdBQ1Isc0JBQ0UsaURBSUUsT0FBTzVULE9BQU8sQ0FBZCx5QkFDSUEsT0FBTyxDQURYLFNBRUksT0FSQSxNQUVOLENBREYsQ0FEUSxHQUFaO0FBRmMsaUJBQ2hCLENBRGdCLEVBZWhCLGdCQUFnQkEsT0FBTyxDQUFQQSx3QkFBaEIsWUFmRixLQWVFLENBZmdCLENBQVpkLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUdBbUJSLEs7Ozs7OztBQUNNMk0seUIsR0FBSixLOztBQUNNZ0ksc0IsR0FBVSxXQUFXLFlBQU07QUFDL0JoSSwyQkFBUyxHQUFUQTtBQURGLGlCOzs7dUJBSThCLHlCQUE5QixLQUE4QixDOzs7QUFBeEJpSSwrQjs7cUJBRU4sUzs7Ozs7QUFDUXROLHFCLEdBQWEsMERBQW5CLEtBQW1CLFE7QUFHbkJBLHFCQUFLLENBQUxBO3NCQUNBLEs7OztBQUdGLG9CQUFJcU4sTUFBTSxLQUFLLEtBQWYsS0FBeUI7QUFDdkI7QUFHRjs7a0RBQUEsZTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQUdNLEUsRUFBc0M7QUFBQTs7QUFDNUMsVUFBSWhJLFNBQVMsR0FBYjs7QUFDQSxVQUFNZ0ksTUFBTSxHQUFHLFNBQVRBLE1BQVMsR0FBTTtBQUNuQmhJLGlCQUFTLEdBQVRBO0FBREY7O0FBR0E7QUFDQSxhQUFPeEYsRUFBRSxHQUFGQSxLQUFXd0ksY0FBRCxFQUFVO0FBQ3pCLFlBQUlnRixNQUFNLEtBQUssT0FBZixLQUF5QjtBQUN2QjtBQUdGOztBQUFBLHVCQUFlO0FBQ2IsY0FBTXJVLEdBQVEsR0FBRyxVQUFqQixpQ0FBaUIsQ0FBakI7QUFDQUEsYUFBRyxDQUFIQTtBQUNBO0FBR0Y7O0FBQUE7QUFYRixPQUFPNkcsQ0FBUDtBQWVGME47OzttQ0FBYyxRLEVBQW9DO0FBQUE7O0FBQUEsaUJBQ3JCLGtCQUFrQnpQLE1BQU0sQ0FBTkEsU0FBN0MsSUFBMkIsQ0FEcUI7QUFBQSxVQUMxQyxRQUQwQyxRQUN4Q3BHLElBRHdDOztBQUVoRCxVQUFJZ0YsS0FBSixFQUFpRSxFQUdqRTs7QUFBQSxhQUFPOFEsYUFBYSxXQUFXLEtBQXhCQSxLQUFhLENBQWJBLE1BQTBDbkYsY0FBRCxFQUFVO0FBQ3hEO0FBQ0E7QUFGRixPQUFPbUYsQ0FBUDtBQU1GQzs7O21DQUFjLFEsRUFBb0M7QUFDaEQsYUFBT0QsYUFBYSxXQUFXLEtBQS9CLEtBQW9CLENBQXBCO0FBR0Y1Szs7O29DQUFlLFMsRUFBQSxHLEVBR0M7QUFBQSxVQUNSLEdBRFEsR0FDYSxnQkFBM0IsT0FBMkIsQ0FEYixDQUNOK0csU0FETTs7QUFFZCxVQUFNK0QsT0FBTyxHQUFHLGNBQWhCLEdBQWdCLENBQWhCOztBQUNBQyxTQUFHLENBQUhBO0FBQ0EsYUFBTyxxQ0FBaUQ7QUFDdERELGVBRHNELEVBQ3REQSxPQURzRDtBQUV0RC9ELGlCQUZzRCxFQUV0REEsU0FGc0Q7QUFHdERyUSxjQUFNLEVBSGdEO0FBSXREcVUsV0FKRixFQUlFQTtBQUpzRCxPQUFqRCxDQUFQO0FBUUZDOzs7dUNBQWtCLEUsRUFBQSxVLEVBQWdEO0FBQ2hFLFVBQUksS0FBSixLQUFjO0FBQ1p6TSxjQUFNLENBQU5BLGdDQUVFZ0wsc0JBRkZoTDtBQU1BO0FBQ0E7QUFFSDtBQUVEME07OzsyQkFBTSxJLEVBQUEsVyxFQUdXO0FBQ2YsYUFBTyxlQUVMLHlCQUZLLFdBQVAsV0FBTyxDQUFQO0FBcm1DOEM7Ozs7Ozs7QUFBN0IxTSxNLENBK0JaNkgsTUEvQlk3SCxHQStCVSx1QkEvQlZBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JickI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF4QkEsQyxDQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBTUEsSUFBTTJNLGdCQUFnQixHQUF0Qjs7QUFFTywyQkFBc0M7QUFBQSxNQUN2QyxJQUR1QyxHQUMzQyxNQUQyQyxDQUN2QyxJQUR1QztBQUFBLE1BQ3ZDLFFBRHVDLEdBQzNDLE1BRDJDLENBQ3ZDLFFBRHVDO0FBRTNDLE1BQUlDLFFBQVEsR0FBR0MsTUFBTSxDQUFOQSxZQUFmO0FBQ0EsTUFBSTNTLFFBQVEsR0FBRzJTLE1BQU0sQ0FBTkEsWUFBZjtBQUNBLE1BQUkzRyxJQUFJLEdBQUcyRyxNQUFNLENBQU5BLFFBQVg7QUFDQSxNQUFJbkgsS0FBSyxHQUFHbUgsTUFBTSxDQUFOQSxTQUFaO0FBQ0EsTUFBSUMsSUFBb0IsR0FBeEI7QUFFQUMsTUFBSSxHQUFHQSxJQUFJLEdBQUd4SCxrQkFBa0IsQ0FBbEJBLElBQWtCLENBQWxCQSx3QkFBSCxNQUFYd0g7O0FBRUEsTUFBSUYsTUFBTSxDQUFWLE1BQWlCO0FBQ2ZDLFFBQUksR0FBR0MsSUFBSSxHQUFHRixNQUFNLENBQXBCQztBQURGLFNBRU8sY0FBYztBQUNuQkEsUUFBSSxHQUFHQyxJQUFJLElBQUksQ0FBQ0MsUUFBUSxDQUFSQSxRQUFELEdBQUNBLENBQUQsK0JBQWZGLFFBQVcsQ0FBWEE7O0FBQ0EsUUFBSUQsTUFBTSxDQUFWLE1BQWlCO0FBQ2ZDLFVBQUksSUFBSSxNQUFNRCxNQUFNLENBQXBCQztBQUVIO0FBRUQ7O0FBQUEsTUFBSXBILEtBQUssSUFBSSxpQkFBYixVQUF3QztBQUN0Q0EsU0FBSyxHQUFHdUgsTUFBTSxDQUFDQyxXQUFXLENBQVhBLHVCQUFmeEgsS0FBZXdILENBQUQsQ0FBZHhIO0FBR0Y7O0FBQUEsTUFBSXlILE1BQU0sR0FBR04sTUFBTSxDQUFOQSxVQUFrQm5ILEtBQUssZUFBdkJtSCxLQUF1QixDQUF2QkEsSUFBYjtBQUVBLE1BQUlELFFBQVEsSUFBSUEsUUFBUSxDQUFSQSxPQUFnQixDQUFoQkEsT0FBaEIsS0FBNkNBLFFBQVEsSUFBUkE7O0FBRTdDLE1BQ0VDLE1BQU0sQ0FBTkEsV0FDQyxDQUFDLGFBQWFGLGdCQUFnQixDQUFoQkEsS0FBZCxRQUFjQSxDQUFkLEtBQWtERyxJQUFJLEtBRnpELE9BR0U7QUFDQUEsUUFBSSxHQUFHLFFBQVFBLElBQUksSUFBbkJBLEVBQU8sQ0FBUEE7QUFDQSxRQUFJNVMsUUFBUSxJQUFJQSxRQUFRLENBQVJBLENBQVEsQ0FBUkEsS0FBaEIsS0FBcUNBLFFBQVEsR0FBRyxNQUFYQTtBQUx2QyxTQU1PLElBQUksQ0FBSixNQUFXO0FBQ2hCNFMsUUFBSSxHQUFKQTtBQUdGOztBQUFBLE1BQUk1RyxJQUFJLElBQUlBLElBQUksQ0FBSkEsQ0FBSSxDQUFKQSxLQUFaLEtBQTZCQSxJQUFJLEdBQUcsTUFBUEE7QUFDN0IsTUFBSWlILE1BQU0sSUFBSUEsTUFBTSxDQUFOQSxDQUFNLENBQU5BLEtBQWQsS0FBaUNBLE1BQU0sR0FBRyxNQUFUQTtBQUVqQ2pULFVBQVEsR0FBR0EsUUFBUSxDQUFSQSxpQkFBWEEsa0JBQVdBLENBQVhBO0FBQ0FpVCxRQUFNLEdBQUdBLE1BQU0sQ0FBTkEsYUFBVEEsS0FBU0EsQ0FBVEE7QUFFQSxtQkFBVVAsUUFBVixTQUFxQkUsSUFBckIsU0FBNEI1UyxRQUE1QixTQUF1Q2lULE1BQXZDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0Q0N4RUQ7QUFDQTs7QUFDZSxzQ0FHTDtBQUFBLE1BRFJDLEdBQ1EsdUVBSEssRUFHTDtBQUNSLE1BQU0vUixJQUFJLEdBQ1J1QyxLQUFLLEtBQUxBLGlCQUVJLGtFQUhOLEtBR00sQ0FITjtBQU1BLFNBQU92QyxJQUFJLEdBQVg7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lDQ2JEOztBQUNBLElBQU1nUyxVQUFVLEdBQWhCOztBQUVPLCtCQUFnRDtBQUNyRCxTQUFPQSxVQUFVLENBQVZBLEtBQVAsS0FBT0EsQ0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xEOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxxQ0FBc0Q7QUFDM0QsTUFBTUMsVUFBVSxHQUFHLFFBQ2pCLG9CQUE2QyxXQUQvQyxpQkFDK0MsR0FENUIsQ0FBbkI7QUFHQSxNQUFNQyxZQUFZLEdBQUc1SCxJQUFJLEdBQUcsY0FBSCxVQUFHLENBQUgsR0FBekI7O0FBSjJELGFBS0ksYUFBL0QsWUFBK0QsQ0FMSjtBQUFBLE1BS3JELFFBTHFELFFBS3JELFFBTHFEO0FBQUEsTUFLckQsWUFMcUQsUUFLckQsWUFMcUQ7QUFBQSxNQUtyRCxNQUxxRCxRQUtyRCxNQUxxRDtBQUFBLE1BS3JELElBTHFELFFBS3JELElBTHFEO0FBQUEsTUFLckQsSUFMcUQsUUFLckQsSUFMcUQ7QUFBQSxNQUtyRCxNQUxxRCxRQUtyRCxNQUxxRDs7QUFTM0QsTUFBSVUsTUFBTSxLQUFLaUgsVUFBVSxDQUF6QixRQUFrQztBQUNoQyxVQUFNLHFFQUFOLEdBQU0sRUFBTjtBQUVGOztBQUFBLFNBQU87QUFDTHBULFlBREssRUFDTEEsUUFESztBQUVMd0wsU0FBSyxFQUFFLHlDQUZGLFlBRUUsQ0FGRjtBQUdMeUgsVUFISyxFQUdMQSxNQUhLO0FBSUxqSCxRQUpLLEVBSUxBLElBSks7QUFLTDNQLFFBQUksRUFBRUEsSUFBSSxDQUFKQSxNQUFXK1csVUFBVSxDQUFWQSxPQUxuQixNQUtRL1c7QUFMRCxHQUFQO0FBT0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJTzs7QUFBQSxJQUFNaVgsY0FDYyxHQUFHO0FBQzVCQyxXQUFTLEVBRG1CO0FBRTVCQyxXQUFTLEVBSEo7QUFDdUIsQ0FEdkI7OztBQU1BLElBQU1DLHlCQUNjLG1DQUFHLGNBQUg7QUFFekJDLFFBQU0sRUFIRDtBQUNvQixFQURwQjs7OztlQU1RLFMsUUFBQSxHQUF5QjtBQUFBLE1BQXhCQyxXQUF3Qix1RUFBekIsS0FBeUI7QUFDdEMsU0FBUXhTLGNBQUQsRUFBa0I7QUFDdkIsUUFBTWlILElBQXdCLEdBQTlCO0FBQ0EsUUFBTXdMLFlBQVksR0FBR0MsWUFBWSxDQUFaQSx5QkFHbkJGLFdBQVcsK0JBSGIsY0FBcUJFLENBQXJCO0FBS0EsUUFBTUMsT0FBTyxHQUFHRCxZQUFZLENBQVpBLCtCQUFoQixJQUFnQkEsQ0FBaEI7QUFFQSxXQUFPLDRCQUF1RDtBQUM1RCxVQUFNalIsR0FBRyxHQUFHNUMsUUFBUSxJQUFSQSxlQUEyQjhULE9BQU8sQ0FBOUMsUUFBOEMsQ0FBOUM7O0FBQ0EsVUFBSSxDQUFKLEtBQVU7QUFDUjtBQUdGOztBQUFBLHVCQUFpQjtBQUFBLG1EQUNmLElBRGU7QUFBQTs7QUFBQTtBQUNmLDhEQUF3QjtBQUFBLGdCQUF4QixHQUF3Qjs7QUFDdEI7QUFDQTtBQUNBLGdCQUFJLE9BQU8vVSxHQUFHLENBQVYsU0FBSixVQUFrQztBQUNoQyxxQkFBUTZELEdBQUcsQ0FBSixNQUFDQSxDQUFtQjdELEdBQUcsQ0FBOUIsSUFBUTZELENBQVI7QUFFSDtBQUNGO0FBUmdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVakI7O0FBQUEsNkNBQU8sTUFBUCxHQUF1QkEsR0FBRyxDQUExQjtBQWhCRjtBQVRGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCRjs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlPOztBQUFBLHVDQUErRDtBQUNwRSxNQUFJLENBQUNMLEtBQUssQ0FBTEEsU0FBTCxHQUFLQSxDQUFMLEVBQTBCO0FBQ3hCO0FBR0Y7O0FBQUEsa0NBQWtCcEQsTUFBTSxDQUFOQSxLQUFsQixNQUFrQkEsQ0FBbEIsa0NBQXVDO0FBQWxDLFFBQU1KLEdBQVgsbUJBQUs7O0FBQ0gsUUFBSXdELEtBQUssQ0FBTEEsb0JBQUosR0FBSUEsRUFBSixFQUErQjtBQUM3QkEsV0FBSyxHQUFHQSxLQUFLLENBQUxBLFFBRUosbUNBRklBLEdBRUosQ0FGSUEsd0RBTUosbUNBTklBLEdBTUosQ0FOSUEsdURBU0csbUNBVEhBLEdBU0csQ0FUSEEsbURBV0osdUNBWElBLEdBV0osQ0FYSUEsaUNBQVJBLEdBQVFBLEVBQVJBO0FBZUg7QUFDREE7O0FBQUFBLE9BQUssR0FBR0EsS0FBSyxDQUFMQSwwTUFBUkEsR0FBUUEsQ0FBUkEsQ0F2Qm9FLENBOEJwRTtBQUNBOztBQUNBLFNBQU9zUixZQUFZLENBQVpBLDJCQUNpQjtBQUFFRSxZQUFRLEVBRDNCRjtBQUNpQixHQURqQkEsaUJBQVAsQ0FBT0EsQ0FBUDtBQUthOztBQUFBLDZFQUtiO0FBQ0EsTUFBSUcsaUJBS21DLEdBTHZDLEdBREEsQ0FRQTs7QUFDQXhJLE9BQUssR0FBR3JNLE1BQU0sQ0FBTkEsV0FBUnFNLEtBQVFyTSxDQUFScU07QUFDQSxNQUFNeUksU0FBUyxHQUFHekksS0FBSyxDQUF2QjtBQUNBLFNBQU9BLEtBQUssQ0FBWjtBQUNBLFNBQU9BLEtBQUssQ0FBWjs7QUFFQSxNQUFJNkUsV0FBVyxDQUFYQSxXQUFKLEdBQUlBLENBQUosRUFBaUM7QUFDL0IyRCxxQkFBaUIsR0FBRyx3Q0FBcEJBLFdBQW9CLENBQXBCQTtBQURGLFNBRU87QUFBQSxlQVVELFFBVEosV0FTSSxDQVZDO0FBQUEsUUFDQyxRQURELFFBQ0MsUUFERDtBQUFBLFFBQ0MsWUFERCxRQUNDLFlBREQ7QUFBQSxRQUNDLElBREQsUUFDQyxJQUREO0FBQUEsUUFDQyxRQURELFFBQ0MsUUFERDtBQUFBLFFBQ0MsSUFERCxRQUNDLElBREQ7QUFBQSxRQUNDLFFBREQsUUFDQyxRQUREO0FBQUEsUUFDQyxNQURELFFBQ0MsTUFERDtBQUFBLFFBQ0MsSUFERCxRQUNDLElBREQ7O0FBWUxBLHFCQUFpQixHQUFHO0FBQ2xCaFUsY0FEa0IsRUFDbEJBLFFBRGtCO0FBRWxCd0wsV0FBSyxFQUFFLHlDQUZXLFlBRVgsQ0FGVztBQUdsQlEsVUFIa0IsRUFHbEJBLElBSGtCO0FBSWxCMEcsY0FKa0IsRUFJbEJBLFFBSmtCO0FBS2xCSSxjQUxrQixFQUtsQkEsUUFMa0I7QUFNbEJvQixVQU5rQixFQU1sQkEsSUFOa0I7QUFPbEJqQixZQVBrQixFQU9sQkEsTUFQa0I7QUFRbEI1VyxVQVJGMlgsRUFRRTNYO0FBUmtCLEtBQXBCMlg7QUFZRjs7QUFBQSxNQUFNRyxTQUFTLEdBQUdILGlCQUFpQixDQUFuQztBQUNBLE1BQU1JLFFBQVEsYUFBTUosaUJBQWlCLENBQUNoVSxRQUF4QixTQUNaZ1UsaUJBQWlCLENBQWpCQSxRQURGLEVBQWMsQ0FBZDtBQUdBLE1BQU1LLGlCQUFxQyxHQUEzQztBQUNBUixjQUFZLENBQVpBO0FBRUEsTUFBTVMsY0FBYyxHQUFHRCxpQkFBaUIsQ0FBakJBLElBQXVCdFYsYUFBRDtBQUFBLFdBQVNBLEdBQUcsQ0FBekQsSUFBNkM7QUFBQSxHQUF0QnNWLENBQXZCO0FBRUEsTUFBSUUsbUJBQW1CLEdBQUcsWUFBWSxDQUFaLGtCQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFFUixZQUFRLEVBUlo7QUFRRSxHQVJ3QixDQUExQjtBQVVBLGFBM0RBLENBNkRBOztBQUNBLHNDQUFnQzVVLE1BQU0sQ0FBTkEsUUFBaEMsU0FBZ0NBLENBQWhDLHVDQUEyRDtBQUFBO0FBQUEsUUFBaEQsR0FBZ0Q7QUFBQSxRQUEzRCxVQUEyRDs7QUFDekQsUUFBSW9ELEtBQUssR0FBR2lFLEtBQUssQ0FBTEEsc0JBQTRCZ08sVUFBVSxDQUF0Q2hPLENBQXNDLENBQXRDQSxHQUFaOztBQUNBLGVBQVc7QUFDVDtBQUNBO0FBQ0FqRSxXQUFLLEdBQUdrUyxjQUFjLFFBQXRCbFMsTUFBc0IsQ0FBdEJBO0FBRUY0Ujs7QUFBQUEsYUFBUyxDQUFUQSxHQUFTLENBQVRBO0FBR0YsR0F4RUEsQ0F3RUE7QUFDQTs7O0FBQ0EsTUFBSU8sU0FBUyxHQUFHdlYsTUFBTSxDQUFOQSxLQUFoQixNQUFnQkEsQ0FBaEIsQ0ExRUEsQ0E0RUE7O0FBQ0EsaUJBQWU7QUFDYnVWLGFBQVMsR0FBR0EsU0FBUyxDQUFUQSxPQUFrQmpOLGNBQUQ7QUFBQSxhQUFVQSxJQUFJLEtBQTNDaU4sb0JBQTZCO0FBQUEsS0FBakJBLENBQVpBO0FBR0Y7O0FBQUEsTUFDRUMsbUJBQW1CLElBQ25CLENBQUNELFNBQVMsQ0FBVEEsS0FBZ0IzVixhQUFEO0FBQUEsV0FBU3VWLGNBQWMsQ0FBZEEsU0FGM0IsR0FFMkJBLENBQVQ7QUFBQSxHQUFmSSxDQUZILEVBR0U7QUFBQSwrQ0FDQSxTQURBO0FBQUE7O0FBQUE7QUFDQSwwREFBNkI7QUFBQSxZQUE3QixJQUE2Qjs7QUFDM0IsWUFBSSxFQUFFM1YsSUFBRyxJQUFULFNBQUksQ0FBSixFQUF5QjtBQUN2Qm9WLG1CQUFTLENBQVRBLElBQVMsQ0FBVEEsR0FBaUJwSixNQUFNLENBQXZCb0osSUFBdUIsQ0FBdkJBO0FBRUg7QUFDRjtBQU5DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRRjs7QUFBQSxNQUFJO0FBQ0ZTLFVBQU0sR0FBR0wsbUJBQW1CLENBQTVCSyxNQUE0QixDQUE1QkE7O0FBREUsd0JBR3VCQSxNQUFNLENBQU5BLE1BQXpCLEdBQXlCQSxDQUh2QjtBQUFBO0FBQUEsUUFHSSxTQUhKO0FBQUEsUUFHSSxLQUhKOztBQUlGWixxQkFBaUIsQ0FBakJBO0FBQ0FBLHFCQUFpQixDQUFqQkEsaUJBQTRCaEksS0FBSSxTQUFTLEVBQXpDZ0ksU0FBOENoSSxLQUFJLElBQWxEZ0k7QUFDQSxXQUFRQSxpQkFBRCxDQUFQO0FBQ0EsR0FQRixDQU9FLFlBQVk7QUFDWixRQUFJclcsR0FBRyxDQUFIQSxjQUFKLDhDQUFJQSxDQUFKLEVBQXVFO0FBQ3JFLFlBQU0sSUFBTixLQUFNLHdLQUFOO0FBSUY7O0FBQUE7QUFHRixHQTVHQSxDQTRHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FxVyxtQkFBaUIsQ0FBakJBLHdDQUEwQixLQUExQkEsR0FFS0EsaUJBQWlCLENBRnRCQTtBQUtBLFNBQU87QUFDTFksVUFESyxFQUNMQSxNQURLO0FBRUxaLHFCQUZGLEVBRUVBO0FBRkssR0FBUDtBQUlEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4S00sOENBRVc7QUFDaEIsTUFBTXhJLEtBQXFCLEdBQTNCO0FBQ0FxSixjQUFZLENBQVpBLFFBQXFCLHNCQUFnQjtBQUNuQyxRQUFJLE9BQU9ySixLQUFLLENBQVosR0FBWSxDQUFaLEtBQUosYUFBdUM7QUFDckNBLFdBQUssQ0FBTEEsR0FBSyxDQUFMQTtBQURGLFdBRU8sSUFBSWhGLEtBQUssQ0FBTEEsUUFBY2dGLEtBQUssQ0FBdkIsR0FBdUIsQ0FBbkJoRixDQUFKLEVBQStCO0FBQ3BDO0FBQUVnRixXQUFLLENBQU4sR0FBTSxDQUFMQSxDQUFELElBQUNBLENBQUQsS0FBQ0E7QUFERyxXQUVBO0FBQ0xBLFdBQUssQ0FBTEEsR0FBSyxDQUFMQSxHQUFhLENBQUNBLEtBQUssQ0FBTixHQUFNLENBQU4sRUFBYkEsS0FBYSxDQUFiQTtBQUVIO0FBUkRxSjtBQVNBO0FBR0Y7O0FBQUEsdUNBQXVEO0FBQ3JELE1BQ0UsNkJBQ0MsNkJBQTZCLENBQUNDLEtBQUssQ0FEcEMsS0FDb0MsQ0FEcEMsSUFFQSxpQkFIRixXQUlFO0FBQ0EsV0FBTy9CLE1BQU0sQ0FBYixLQUFhLENBQWI7QUFMRixTQU1PO0FBQ0w7QUFFSDtBQUVNOztBQUFBLDBDQUVZO0FBQ2pCLE1BQU16SCxNQUFNLEdBQUcsSUFBZixlQUFlLEVBQWY7QUFDQW5NLFFBQU0sQ0FBTkEsMEJBQWlDLGdCQUFrQjtBQUFBO0FBQUEsUUFBakIsR0FBaUI7QUFBQSxRQUFsQixLQUFrQjs7QUFDakQsUUFBSXFILEtBQUssQ0FBTEEsUUFBSixLQUFJQSxDQUFKLEVBQTBCO0FBQ3hCakUsV0FBSyxDQUFMQSxRQUFld1MsY0FBRDtBQUFBLGVBQVV6SixNQUFNLENBQU5BLFlBQW1CMEosc0JBQXNCLENBQWpFelMsSUFBaUUsQ0FBekMrSSxDQUFWO0FBQUEsT0FBZC9JO0FBREYsV0FFTztBQUNMK0ksWUFBTSxDQUFOQSxTQUFnQjBKLHNCQUFzQixDQUF0QzFKLEtBQXNDLENBQXRDQTtBQUVIO0FBTkRuTTtBQU9BO0FBR0s7O0FBQUEsd0JBR1k7QUFBQSxvQ0FIWixnQkFHWTtBQUhaLG9CQUdZO0FBQUE7O0FBQ2pCOFYsa0JBQWdCLENBQWhCQSxRQUEwQkosc0JBQUQsRUFBa0I7QUFDekNyTyxTQUFLLENBQUxBLEtBQVdxTyxZQUFZLENBQXZCck8sSUFBV3FPLEVBQVhyTyxVQUF5Q3pILGFBQUQ7QUFBQSxhQUFTVixpQkFBakRtSSxHQUFpRG5JLENBQVQ7QUFBQSxLQUF4Q21JO0FBQ0FxTyxnQkFBWSxDQUFaQSxRQUFxQjtBQUFBLGFBQWdCeFcsTUFBTSxDQUFOQSxZQUFyQ3dXLEtBQXFDeFcsQ0FBaEI7QUFBQSxLQUFyQndXO0FBRkZJO0FBSUE7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwREQ7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7OztBQUVBOztBQUFBLElBQU1DLGtCQUFrQixHQUFHLDJCQUEzQixJQUEyQixDQUEzQjs7QUFFZSwrRUFPYjtBQUNBLE1BQUksQ0FBQ3RGLEtBQUssQ0FBTEEsU0FBZSwrREFBcEIsUUFBS0EsQ0FBTCxFQUFvRTtBQUFBLCtDQUNsRSxRQURrRTtBQUFBOztBQUFBO0FBQ2xFLDBEQUFnQztBQUFBLFlBQWhDLE9BQWdDO0FBQzlCLFlBQU1rRSxPQUFPLEdBQUdvQixrQkFBa0IsQ0FBQ0MsT0FBTyxDQUExQyxNQUFrQyxDQUFsQztBQUNBLFlBQU1wSyxNQUFNLEdBQUcrSSxPQUFPLENBQXRCLE1BQXNCLENBQXRCOztBQUVBLG9CQUFZO0FBQ1YsY0FBSSxDQUFDcUIsT0FBTyxDQUFaLGFBQTBCO0FBQ3hCO0FBQ0E7QUFFRjs7QUFBQSxjQUFNQyxPQUFPLEdBQUcsb0NBQ2RELE9BQU8sQ0FETyw0QkFBaEIsSUFBZ0IsQ0FBaEI7QUFNQS9ILGdCQUFNLEdBQUdnSSxPQUFPLENBQVBBLGtCQUFUaEk7QUFDQWpPLGdCQUFNLENBQU5BLGNBQXFCaVcsT0FBTyxDQUFQQSxrQkFBckJqVztBQUVBLGNBQU1rVyxVQUFVLEdBQUcsOENBQ2pCLHFEQURpQixNQUNqQixDQURpQixXQUFuQjs7QUFLQSxjQUFJekYsS0FBSyxDQUFMQSxTQUFKLFVBQUlBLENBQUosRUFBZ0M7QUFDOUJ4QyxrQkFBTSxHQUFOQSxXQUQ4QixDQUU5QjtBQUNBOztBQUNBO0FBR0YsV0ExQlUsQ0EwQlY7OztBQUNBLGNBQU1sQixZQUFZLEdBQUdFLFdBQVcsQ0FBaEMsVUFBZ0MsQ0FBaEM7O0FBRUEsY0FBSUYsWUFBWSxLQUFaQSxVQUEyQjBELEtBQUssQ0FBTEEsU0FBL0IsWUFBK0JBLENBQS9CLEVBQTZEO0FBQzNEeEMsa0JBQU0sR0FBTkE7QUFDQTtBQUVIO0FBQ0Y7QUFDRjtBQXhDbUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXlDcEU7O0FBQUE7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RE0scUNBQXVFO0FBQUEsTUFDdEUsRUFEc0UsR0FDNUUsVUFENEUsQ0FDdEUsRUFEc0U7QUFBQSxNQUN0RSxNQURzRSxHQUM1RSxVQUQ0RSxDQUN0RSxNQURzRTtBQUU1RSxTQUFRcE4sa0JBQUQsRUFBeUM7QUFDOUMsUUFBTWlRLFVBQVUsR0FBR3FGLEVBQUUsQ0FBRkEsS0FBbkIsUUFBbUJBLENBQW5COztBQUNBLFFBQUksQ0FBSixZQUFpQjtBQUNmO0FBR0Y7O0FBQUEsUUFBTUMsTUFBTSxHQUFJdkssU0FBVnVLLE1BQVV2SyxNQUFELEVBQW1CO0FBQ2hDLFVBQUk7QUFDRixlQUFPd0ssa0JBQWtCLENBQXpCLEtBQXlCLENBQXpCO0FBQ0EsT0FGRixDQUVFLFVBQVU7QUFDVixZQUFNN1gsR0FBOEIsR0FBRyxVQUF2Qyx3QkFBdUMsQ0FBdkM7QUFHQUEsV0FBRyxDQUFIQTtBQUNBO0FBRUg7QUFWRDs7QUFXQSxRQUFNb04sTUFBa0QsR0FBeEQ7QUFFQTVMLFVBQU0sQ0FBTkEscUJBQTZCc1csa0JBQUQsRUFBc0I7QUFDaEQsVUFBTUMsQ0FBQyxHQUFHQyxNQUFNLENBQWhCLFFBQWdCLENBQWhCO0FBQ0EsVUFBTUMsQ0FBQyxHQUFHM0YsVUFBVSxDQUFDeUYsQ0FBQyxDQUF0QixHQUFvQixDQUFwQjs7QUFDQSxVQUFJRSxDQUFDLEtBQUwsV0FBcUI7QUFDbkI3SyxjQUFNLENBQU5BLFFBQU0sQ0FBTkEsR0FBbUIsQ0FBQzZLLENBQUMsQ0FBREEsUUFBRCxHQUFDQSxDQUFELEdBQ2ZBLENBQUMsQ0FBREEsZUFBa0I1VCxlQUFEO0FBQUEsaUJBQVd1VCxNQUFNLENBRG5CLEtBQ21CLENBQWpCO0FBQUEsU0FBakJLLENBRGUsR0FFZkYsQ0FBQyxDQUFEQSxTQUNBLENBQUNILE1BQU0sQ0FEUEcsQ0FDTyxDQUFQLENBREFBLEdBRUFILE1BQU0sQ0FKVnhLLENBSVUsQ0FKVkE7QUFNSDtBQVZENUw7QUFXQTtBQTlCRjtBQWdDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQzlCRDtBQUNBOztBQUNBLDBCQUFrQztBQUNoQyxTQUFPMFcsR0FBRyxDQUFIQSxnQ0FBUCxNQUFPQSxDQUFQO0FBR0Y7O0FBQUEsK0JBQXVDO0FBQ3JDLE1BQU0xSyxRQUFRLEdBQUdILEtBQUssQ0FBTEEsbUJBQXlCQSxLQUFLLENBQUxBLFNBQTFDLEdBQTBDQSxDQUExQzs7QUFDQSxnQkFBYztBQUNaQSxTQUFLLEdBQUdBLEtBQUssQ0FBTEEsU0FBZSxDQUF2QkEsQ0FBUUEsQ0FBUkE7QUFFRjs7QUFBQSxNQUFNRSxNQUFNLEdBQUdGLEtBQUssQ0FBTEEsV0FBZixLQUFlQSxDQUFmOztBQUNBLGNBQVk7QUFDVkEsU0FBSyxHQUFHQSxLQUFLLENBQUxBLE1BQVJBLENBQVFBLENBQVJBO0FBRUY7O0FBQUEsU0FBTztBQUFFak0sT0FBRyxFQUFMO0FBQWNtTSxVQUFkLEVBQWNBLE1BQWQ7QUFBc0JDLFlBQTdCLEVBQTZCQTtBQUF0QixHQUFQO0FBR0s7O0FBQUEsd0NBT0w7QUFDQSxNQUFNMkssUUFBUSxHQUFHLENBQUNDLGVBQWUsQ0FBZkEsc0JBQUQsb0JBQWpCLEdBQWlCLENBQWpCO0FBSUEsTUFBTUosTUFBc0MsR0FBNUM7QUFDQSxNQUFJSyxVQUFVLEdBQWQ7QUFDQSxNQUFNQyxrQkFBa0IsR0FBR0gsUUFBUSxDQUFSQSxJQUNuQjFLLGlCQUFELEVBQWE7QUFDaEIsUUFBSUEsT0FBTyxDQUFQQSxtQkFBMkJBLE9BQU8sQ0FBUEEsU0FBL0IsR0FBK0JBLENBQS9CLEVBQXNEO0FBQUEsNEJBQ2xCOEssY0FBYyxDQUFDOUssT0FBTyxDQUFQQSxTQUFpQixDQUFsRSxDQUFpREEsQ0FBRCxDQURJO0FBQUEsVUFDOUMsR0FEOEMsbUJBQzlDLEdBRDhDO0FBQUEsVUFDOUMsUUFEOEMsbUJBQzlDLFFBRDhDO0FBQUEsVUFDOUMsTUFEOEMsbUJBQzlDLE1BRDhDOztBQUVwRHVLLFlBQU0sQ0FBTkEsR0FBTSxDQUFOQSxHQUFjO0FBQUVRLFdBQUcsRUFBRUgsVUFBUDtBQUFxQjlLLGNBQXJCLEVBQXFCQSxNQUFyQjtBQUE2QkMsZ0JBQTNDd0ssRUFBMkN4SztBQUE3QixPQUFkd0s7QUFDQSxhQUFPekssTUFBTSxHQUFJQyxRQUFRLG1CQUFaLFdBQWI7QUFIRixXQUlPO0FBQ0wsd0JBQVdpTCxXQUFXLENBQXRCLE9BQXNCLENBQXRCO0FBRUg7QUFUd0JOLFVBQTNCLEVBQTJCQSxDQUEzQixDQVBBLENBbUJBO0FBQ0E7O0FBQ0EsYUFBbUMsa0dBZ0VuQzs7QUFBQSxTQUFPO0FBQ0xSLE1BQUUsRUFBRSxzQkFEQyxrQkFDRCxhQURDO0FBRUxLLFVBRkYsRUFFRUE7QUFGSyxHQUFQO0FBSUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEhEOztBQUVBLElBQU1VLFFBQU47O0lBY2UsUTs7Ozs7QUFjYmxKLG9CQUFXLEtBQVhBLEVBQXdCO0FBQUE7O0FBQUE7O0FBQ3RCO0FBRHNCLFVBYmhCbUosZUFhZ0I7O0FBQUEsVUFYeEJDLFVBV3dCLEdBWFgsWUFBWTtBQUN2QixVQUFJLE1BQUosaUJBQTBCO0FBQ3hCLDJDQUNFLHVEQUNNLHdCQUROLG1CQUVFLE1BSEosS0FDRSxDQURGO0FBT0g7QUFFdUI7O0FBRXRCLDRCQUNFLDJCQUEwQix3QkFENUI7O0FBR0EsUUFBSUYsUUFBUSxJQUFJLE1BQWhCLGlCQUFzQztBQUNwQzs7QUFDQTtBQUVIOztBQVR1QjtBQVV4Qkc7Ozs7d0NBQW9CO0FBQ2xCLFVBQUksS0FBSixpQkFBMEI7QUFDeEI7QUFFRjs7QUFBQTtBQUVGQzs7O3lDQUFxQjtBQUNuQjtBQUVGQzs7OzJDQUF1QjtBQUNyQixVQUFJLEtBQUosaUJBQTBCO0FBQ3hCO0FBRUY7O0FBQUE7QUFHRkM7Ozs2QkFBUztBQUNQO0FBekNvRDs7OztFQUEzQnJJLGdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaN0I7QUF5UUE7QUFDQTtBQUNBOzs7QUFDTyxzQkFFRjtBQUNILE1BQUlzSSxJQUFJLEdBQVI7QUFDQTtBQUVBLFNBQVEsWUFBb0I7QUFDMUIsUUFBSSxDQUFKLE1BQVc7QUFDVEEsVUFBSSxHQUFKQTtBQUNBdEwsWUFBTSxHQUFHOUcsRUFBVDhHLE1BQVM5RyxtQkFBVDhHO0FBRUY7O0FBQUE7QUFMRjtBQVNLOztBQUFBLDZCQUE2QjtBQUFBLHlCQUNHN0ksTUFBTSxDQUEzQyxRQURrQztBQUFBLE1BQzVCLFFBRDRCLG9CQUM1QixRQUQ0QjtBQUFBLE1BQzVCLFFBRDRCLG9CQUM1QixRQUQ0QjtBQUFBLE1BQzVCLElBRDRCLG9CQUM1QixJQUQ0QjtBQUVsQyxtQkFBVWlRLFFBQVYsZUFBdUJJLFFBQXZCLFNBQWtDb0IsSUFBSSxHQUFHLE1BQUgsT0FBdEM7QUFHSzs7QUFBQSxrQkFBa0I7QUFBQSxNQUNqQixJQURpQixHQUNOelIsTUFBTSxDQUF2QixRQUR1QixDQUNqQixJQURpQjtBQUV2QixNQUFNMEosTUFBTSxHQUFHMEssaUJBQWY7QUFDQSxTQUFPeGEsSUFBSSxDQUFKQSxVQUFlOFAsTUFBTSxDQUE1QixNQUFPOVAsQ0FBUDtBQUdLOztBQUFBLG1DQUF3RDtBQUM3RCxTQUFPLDRDQUVIaVMsU0FBUyxDQUFUQSxlQUF5QkEsU0FBUyxDQUFsQ0EsUUFGSjtBQUtLOztBQUFBLHdCQUF3QztBQUM3QyxTQUFPMUwsR0FBRyxDQUFIQSxZQUFnQkEsR0FBRyxDQUExQjtBQUdLOztTQUFBLG1COzs7OztrRkFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBTUgsa0JBQUlrVSxHQUFHLENBQVAsc0JBQUlBLGVBQUosZUFORztBQUFBO0FBQUE7QUFBQTs7QUFPSzNRLG1CQVBMLGVBT21CNFEsY0FBYyxDQUFsQyxHQUFrQyxDQVBqQztBQUFBLGtCQVVLLFVBQU4sT0FBTSxDQVZMOztBQUFBO0FBYUw7QUFDTW5VLGVBZEQsR0FjTzBQLEdBQUcsQ0FBSEEsT0FBWUEsR0FBRyxDQUFIQSxPQUFXQSxHQUFHLENBQUhBLElBQW5DLEdBZEs7O0FBQUEsZ0JBZ0JBd0UsR0FBRyxDQUFSLGVBaEJLO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQWlCQ3hFLEdBQUcsQ0FBSEEsT0FBV0EsR0FBRyxDQUFsQixTQWpCRztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQW9Ca0IwRSxtQkFBbUIsQ0FBQzFFLEdBQUcsQ0FBSixXQUFnQkEsR0FBRyxDQUR6RCxHQUNzQyxDQXBCckM7O0FBQUE7QUFBQTtBQUFBO0FBb0JDMkUsdUJBcEJEO0FBQUE7O0FBQUE7QUFBQSw2Q0F1QkgsRUF2Qkc7O0FBQUE7QUFBQTtBQUFBLG1CQTBCZUgsR0FBRyxDQUFIQSxnQkFBcEIsR0FBb0JBLENBMUJmOztBQUFBO0FBMEJDMVgsaUJBMUJEOztBQUFBLGtCQTRCRHdELEdBQUcsSUFBSXNVLFNBQVMsQ0FBcEIsR0FBb0IsQ0E1QmY7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkNBNkJILEtBN0JHOztBQUFBO0FBQUEsZ0JBZ0NMLEtBaENLO0FBQUE7QUFBQTtBQUFBOztBQWlDRy9RLG9CQWpDSCxlQWlDaUI0USxjQUFjLEtBakMvQiwyRUFpQ0gsS0FqQ0c7QUFBQSxrQkFvQ0csVUFBTixRQUFNLENBcENIOztBQUFBO0FBdUNMLHNCQUEyQztBQUN6QyxrQkFBSTVYLE1BQU0sQ0FBTkEsNEJBQW1DLENBQUNtVCxHQUFHLENBQTNDLEtBQWlEO0FBQy9DN1UsdUJBQU8sQ0FBUEEsZUFDS3NaLGNBQWMsQ0FEbkJ0WixHQUNtQixDQURuQkE7QUFNSDtBQUVEOztBQWpESyw2Q0FpREwsS0FqREs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQW9EQSxJQUFNMFosYUFBYSxHQUFHLHdHQUF0QixTQUFzQixDQUF0Qjs7O0FBZUEsbUNBQXNEO0FBQzNELFlBQTRDO0FBQzFDLFFBQUk3TSxHQUFHLEtBQUhBLFFBQWdCLGVBQXBCLFVBQTZDO0FBQzNDbkwsWUFBTSxDQUFOQSxrQkFBMEJKLGFBQUQsRUFBUztBQUNoQyxZQUFJb1ksYUFBYSxDQUFiQSxpQkFBK0IsQ0FBbkMsR0FBdUM7QUFDckMxWixpQkFBTyxDQUFQQTtBQUlIO0FBTkQwQjtBQVFIO0FBRUQ7O0FBQUEsU0FBTywwQkFBUCxHQUFPLENBQVA7QUFHSzs7QUFBQSxJQUFNaVksRUFBRSxHQUFHLHVCQUFYOztBQUNBLElBQU0vSCxFQUFFLEdBQ2IrSCxFQUFFLElBQ0YsT0FBTzlILFdBQVcsQ0FBbEIsU0FEQThILGNBRUEsT0FBTzlILFdBQVcsQ0FBbEIsWUFISzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hZTSx3QkFBd0IsMENBQTBDLGdEQUFnRCxnQ0FBZ0MsZ0NBQWdDLG1DQUFtQyw0QkFBNEIsK0JBQStCLG9CQUFvQix5QkFBeUIsVUFBVTtBQUNwVixpRDs7Ozs7Ozs7Ozs7QUNEQSxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBNkI7Ozs7Ozs7Ozs7OztBQ0F0RCxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBb0I7Ozs7Ozs7Ozs7Ozs7QUNBN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLElBQUksSUFBcUM7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMseUZBQTRCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxrREFBVTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsZ0ZBQWU7O0FBRXBDLDJCQUEyQixtQkFBTyxDQUFDLHlGQUE0QjtBQUMvRCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7O0FBRS9DO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVUsS0FBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7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O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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YUFBYTtBQUN6QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsRUFBRTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FB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b0NFO0FBQUcsbUJBQVMsRUFBQyx1QkFBYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFwQ0YsZUFxQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFyQ0YsZUFzQ0U7QUFBRyxtQkFBUyxFQUFDLHlCQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQXRDRixlQXVDRTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQXZDRixlQXdDRTtBQUFHLG1CQUFTLEVBQUMscUJBQWI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBeENGLGVBeUNFO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBekNGLGVBMENFO0FBQUcsbUJBQVMsRUFBQywwQkFBYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkExQ0YsZUEyQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkEzQ0YsZUE0Q0U7QUFBRyxtQkFBUyxFQUFDLHNCQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQTVDRixlQTZDRTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQTdDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUEzQ0Y7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERjtBQStGRCxDQTNHRDs7R0FBTUosSTtVQUtGdmIsaUU7OztLQUxFdWIsSTtBQTZHU0EsbUVBQWYiLCJmaWxlIjoic3RhdGljL2NodW5rcy9wYWdlcy9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBQcm9maWxlIEF2YXRhciBhcyBTVkdcclxuICogQGRlc2NyaXB0aW9uIE1haW4gU2l0ZSBBdmF0YXIgZm9yIHByb2ZpbGVcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuXHJcbmNvbnN0IEF2YXRhciA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxzdmdcclxuICAgICAgdmVyc2lvbj1cIjEuMVwiXHJcbiAgICAgIGlkPVwic3ZnMzE2OVwiXHJcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxyXG4gICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgIHZpZXdCb3g9XCIwIDAgNTQwLjg0NTA5IDUzOS40OTI5OFwiXHJcbiAgICA+XHJcbiAgICAgIDx0aXRsZSBpZD1cInRpdGxlMzc0MlwiPmR0cm8tZGV2dWsgYXZhdGFyIDwvdGl0bGU+XHJcbiAgICAgIDxtZXRhZGF0YSBpZD1cIm1ldGFkYXRhMzE3NVwiPjwvbWV0YWRhdGE+XHJcbiAgICAgIDxkZWZzIGlkPVwiZGVmczMxNzNcIiAvPlxyXG4gICAgICA8aW1hZ2VcclxuICAgICAgICB3aWR0aD1cIjU0MC44NDUwOVwiXHJcbiAgICAgICAgaGVpZ2h0PVwiNTM5LjQ5Mjk4XCJcclxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiXHJcbiAgICAgICAgaHJlZj1cImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBWkFBQUFHUENBWUFBQUJ5UDRhQ0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4XHJcbiAgand2OFlRVUFBQUFKY0VoWmN3QUFDdXNBQUFyckFZS0xEVm9BQUFEYmFWUllkRmhOVERwamIyMHVZV1J2WW1VdWVHMXdBQUFBQUFBOFxyXG4gIFAzaHdZV05yWlhRZ1ltVm5hVzQ5SXUrN3Z5SWdhV1E5SWxjMVRUQk5jRU5sYUdsSWVuSmxVM3BPVkdONmEyTTVaQ0kvUGcwS1BIZzZcclxuICBlRzF3YldWMFlTQjRiV3h1Y3pwNFBTSmhaRzlpWlRwdWN6cHRaWFJoTHlJK0RRb2dJRHh5WkdZNlVrUkdJSGh0Ykc1ek9uSmtaajBpXHJcbiAgYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUlnTHo0TkNqd3ZlRHA0YlhCdFxyXG4gIFpYUmhQZzBLUEQ5NGNHRmphMlYwSUdWdVpEMGljaUkvUGlNSGRGRUFBUDYrU1VSQlZIaGU3TDBId0cxWFZTZSt2dDc3NjcyL2wwNHFcclxuICBDUUdCQUFGQkhVVUhSa2ZGam4wY3k5OFpIVVd4akgxMEhOR3g5MEhVRVVaRkJOSWdCTkpJZmNsN3lldjFlK1hydmYvWGI2MjEyeW4zXHJcbiAgdTk5N2lRR1MzNzM3N05YMlB2dWVlODVlWjVlelQ4M1MzRk5MRkdGcGFZbWVldW81ZXV2YjMwdjk1d1pNbWtVdFVRMEhRMDJORVlLRVxyXG4gIFlXUjVScHFBRWZNUkxXU0pqdW1RVFN3SG1DL1VHVjJtMDYvU01aTHlSclNRR1Z2bVM0OUh6dDdvakwxbmMvWUE4MWxSTEJCMTRKY1dcclxuICA1Mmx1ckorSkJaTmtVRk5IRFowYitPK3N0MnppMURFazR3SVVDTVcwT0JlRjZVcE5paFdWejdNeVJIYlZKc2tZWG1LeUFsU2Qwd3VBXHJcbiAgNUxMT1l4bTFROTdzVWhKV21TYXk0MnFvQkNVS0x5N2YxeEowaGVvQ29ZaFMrZExpQXMyT1hBUmhFb2NsMnJDK2d4NTU4RzlvL2ZyVlxyXG4gIEpudDVJSGdCdy9uekEvU2ViL3RKamdkTlVvUndJYVNWZVBZQ0tlQnpsWEdXdDBqc25DNm1nYmlTVHVVU1JHUzBoOGx6T3FXUm4wcWNcclxuICBISUF3dzdzb0tSK0FQTExsTWtZeWozakVJbFBTRWZweHJGY2FtSFpwQkU2dkF0MkZ6OEVROUJVUnBVMnRSV0hCUkFJd0xnUlNmMzgrXHJcbiAgbDhqQWdvazhuQ0FvaE9LTkJzM1hwQmF5aUhRaG9SZEo4SWlGV3Q3MGsxcmtCRW4rVWNnYlpzSy9KWXIySDRXaThrdkltS1VzaC9TVFxyXG4gIHR6QWtZdDY0a0NpeUNEcC9MakVyUWZSQXNJbWxRY1FiaEt5ZUlTV1dQR0VqQW9OanZNQlkzdmk4WGtFUmNnNWtjWEZKbk1kaStTMkFcclxuICB3QjliUWRFQnpzamNuK1lSTTZDTmx5aXJjd2dubGNxZHptZ3ZjbklnMGpuYVEvTXF6Qzhwcitra010b2pMaE1RNlNXUDFGWmx4cHF0XHJcbiAgYk4xR0NRNE9Kdk9pU0M4cTNYOWt3QkFGM3hmeEozZTNsSWVXd0VIVHB2c0V3TGdRU05tL2ZWSjRBMDhHT0VGUUNNVWIvM3NRSW4wS1xyXG4gIGt6czdDVUVjRUlUcEo5WmttQ1JQQzZrQmgwdEJVVDR2ZHJnVVpQSW9PaDc4OWVyVW1rUHBVVllrWXQ2NGtMWHpNRG5idUhORGtxaVNcclxuICBZWG9mREY1VW9HTm9DVFUvVVhtMVk3eEFTTlNHZWkxVnJoZGZic2c1a0tvUUhkc013OGdjZkVEK1JJZXMzbWdSeDdxVWRpZU93aE1NXHJcbiAgb3lYQ3h1bU05aUluQitMOHZJRUNRczlHT29tOGdsRlVwc2cyS0JoTVovTFZqNW5wQmdvRDAyS1BZQ0sxVmtwVUxnY0gwOGRwK0NaZ1xyXG4gIFlSSk43cEx1SzQrQ3RBS1RPeUhVMksvdE85MC9JQVlXbEZVNEpnaUY0bzNMVHhqVHBYQnlzNUZnb2dRcVREK1JhY3o0ZkN3a3l1V1FcclxuICB0YmVRelRNWExpSEpDa0pSL29XR2NTaE94R0U1UkxhNWZDTlZZbG40cndSNE1XOFF5dXdFYXVQUFJiQ21DV2xjaUVneGpPUUdMWlhMXHJcbiAgQ3phbUVNSUNYMFB6NCtjNFh2Nkc3T1dFUzNNZ0FuZHdZeFR3OG9jNVpHbmpKU3EzQzFtQWNJelJFc1Z5d0dpSllwM1NhWDRHT1hGU1xyXG4gIHUwQkdQTWZ1cEZWRU9pRWpIakY0eHpLaEh5RlZwNXlCNll4OUNLYXFsTWFMSGNNdGtNWGxuQWVqTUswSk9ISVhscFU4Z3RscHdaVDFcclxuICBNRjBrOUdhT1NCTVlUTzZOZ3loQUJlbkhUQndoZ1RmSnZseW9oSXh0bkllRUVsV2FLaE9LUDBXV2x4cktQMFhXRm5qalFxa2lyK1JRXHJcbiAgQ1pGZGtrOGs5bVJSS1EyeEtGZU9MRlR2cmtzeDlYQnBJcUd3dkJIRGpJNGhKWks4WUdOQ0p2UmFrclpJUVhoNTRoSWRTSHJBRlJsWlxyXG4gIGN2Q0JtSWxvL3ljQ01jMlFQOUhvb3ZRU1plVWNKRExhSXo2NVlwMFhHb3dXRTlrSWk5aWRvSXBJSjJURUl3YnZXQ2IwSTZUcWxETXdcclxuICBuYkgzaktoMDM1RUJReFNSeU9sTkFKV2txUWJGYVNVNG1ZZlp1WDE3dFdPQ1VFd2t4T1ZYWFlESnZMR0pQRlNRZnN6RUVUNnRGMWdvXHJcbiAgUTJRVHA1V1FZek1oVzRwcXdrdUpvdkxrUS9ySmFIbmpRazRRaEJiS0VOa2s2VTNrdFVXbE1IZ1JiNUw5eGxDWlAzK2RxY0RadXhDUlxyXG4gIEpmbHBPUmkrNVlFNERiVTFTN1I2ZFEvVjFxWnBYdzY0akJhSVEvYWdNeDMrTVVhQjNrVTVPd2Y3ODQwT09xTWxpdVdBa3h2dEVVNmtcclxuICB5RUJqQ0IzcmRCSVo3ZUhTQTVGT3lJaEhuTWxUUDBLcVRqa0QweGw3ejRqS3B6YVl2a0lhNlBMcHFvQmxVNXpXS3oycGNJd1hxSW1WXHJcbiAgSWF0VG1Fd05QUnVnZ3ZBeHRTTjhPaS9nVUlSSUg2ZVJrSkJSaVBkWUZncFFaT1lEYjE3eVVGUXVDNFVvTXRRUVBwR1VOd2dKa3dvdFxyXG4gIEZNRjBTVG9UZVcxMmp3WXY0azJ5cnhncWMrZWttSGxrMG5nMkkxOWFxRGlUY2MyYVh2cXpQLzVGZGlLOUpubjU0RElkaUIxZ0QrWVRcclxuICBVY3lBTmw2aXJNNGgvcE1MYkNUS3lqbDR1ZE1wWFpnWGhJbmNHSW04Z2hHZmRCazdFUm92WU5xem5FWStRbktRRFRnRDB4WEtJUHNNXHJcbiAgU29ZSTFjU0xJd1lxUytQVmdwUXJSSkkydGdjdFNrOHFIS01DVVV2ZzFDQ0NZUVJ2cE9yRVJBWGhZMnBIdUhSQlU0QkluOWxQdkVzTlxyXG4gIDhWNnlJWU9jQ1crS1F0NHdDbDhJS0NxWGhhTGZJeUZqbWtQV3dCM1p6TkhOTXFtQVF4Rk1seW1MUlJ5eWV6RjRFVy84ZnJMZ2xLelRcclxuICBZR1lDWjI4Q3p5cXhWR0Vjc2JhMlZwd0k0cGNiTG5NTUpJTDhHMFlMWXNab1JQYUhLRkxhL2FsWnVRU0p5dVNPZDRoUERtK2dzUXFWXHJcbiAgZG5JaEk1N2pVQmFnekE1Z0dqSVJxUzZReWdjdzdXMkJvQmN4Ynl5MVFZVE9oQUhDQlkwSzA2aEN5UlVoazlhbmQ0d0tSQzBobFFlWVxyXG4gIHpCdXFWS0c2OERHMUkxeWFvTWtnMGtYNVI2U0ZPUGM0WkpDb2VST0hWTWxoNVhEbGVDay9sNGJNYjg4ZUcvNzZrRU9zVEVzaWdUY0lcclxuICBCWXlGTEV6dWJCM3JOVW51SEF6QzhpYkpQNGJLM0xVdVpnSm42d1d2b0FRdnpCaElPUEtNN0lFM1dxSUN1VUQvUUVXQmpVU1Y1RTZuXHJcbiAgdE9ZVnl4bHloaGp0Q0RHUmpiQ0k4NDdEbU1RT1lOcm5xVHJaaGcwSEI2YTlMUkQwSWw2QnZaSld6bURBWU5xbDRZQUhRcGNXWGIvdFxyXG4gIGNralRLaHlqQWxGTFNPVUJKaXZKSjN4TTVRaVhjZEJrWUhKbmw1SVdBaFZDaEVURm16Z2t5c29JdnlIejRYektBcXRmOGxCVUxoOUtcclxuICBQc3NqMlVFbVJPb0VzU0xzU1FKdkVBb1lEbG1ZM05rNTFtdVNuRGxFWkdtK0t0UGpZbWFDckcwNmVJNWhqOVdydTErV3JRL2dFbjUxXHJcbiAgZkRDWkRrZWFrYVdOOTM4YWtOTHVEOHZLSlVoVUpuZThRL3pIUi9JZ0JHTUJVVVFMWERtQTJBNGh0ZE04aldYQ214VGttYlYxakloWFxyXG4gIFlLOGs5cVg3QzJDdUtNM1NvazA3ckR3THE2YkdQWUVPV0ZvVGFCa1JVbm1BTjhpb2xYRmxGYkVqbkgzUVpHRHlLTjg0KzVCakhDSjRcclxuICBNVzljS0xQTndKWFlmemh0SEZoVUhDcWlLRUgxQVk5akxTNHNGQVo5VktzNFhSb3FvTWljUS9hM1p6K1ZrV1FVQlJNbmNFSU5MbmNKXHJcbiAgTVJFWURsbVlQTE1maXpnRVN1Qlozdmg4WTZoTS9uTnhGUE1hQ1ppbU9SL1dyT21nUC92ajk4c2crc3NSSzNjZ05YVVc0K0FycVlnWlxyXG4gIG94SEpuK0NRMGtGVllDTlJKYm5US2ExNVplUkYreGFUVks0WGlkSjVPK01SZzNjc0Uvb0JpYTFYTUdDSFlLd1F5b2g0QmZhcWl2WWxcclxuICBFS0VGRXdsaGpKQ1YrMjBGc296SldvN1ppVmhhU3lyN05BN2lDS0swWUNLQks2T1dVMVJDd001SlJKcUJ5YU04WGRZYUFxVWhnaGZ6XHJcbiAgeG9VaXV3aWhqUGJoTkM0d200WkNaSTJXQzVjT3RDSVg1MmRwZXVBMFRaMC9uZ1RJcXBxaUxTZ3FWNlZRZ0l4SmZOeXluM0w0eEZFd1xyXG4gIGNRSW5ERGxLaUluQWNNakM1TkUrVE1JaHp0RWdMRzk4bmhINFJteDJ0SHdBL2VVOC9nRmNVZ3VrSmpsWTJZTnV0RVFGY2dIbjRkbU1cclxuICBEVmdSVlNmMy8zc3NGNkhSUWhpZk9VSDBBakRHeVF2c3N2bnBSMGpWZWNBT3dWZzFVRXBVZ1ZlSU1CSkZlbEg1UFJsRTZFMlVjRUdqXHJcbiAgY0VGWEFiRnYwRFNXVm9oY2FwTkxNSkhBN1FzZllTM0F6akZabUR6S3oyV3JJVkFhREY3RUd4ZXlOaEZDdWZqRHRpNHdtNFlFV1dWUlxyXG4gIEtFQ1JtUSs4dWNRQUJ6SXpkSkVXNXhhNUhxdU5BdXNXK0U2NElFMXhLQ3FYaFVJVUdXWkRoSXdxUHQ3eHB4ZytVUlJNN09FRUlTY0pcclxuICBNUkVZRGxtWVBzcGJvemczZzdBd01EbTNQS3AzMUM4L1hFSUxKRHJZOFlHUC93aDM4QVVwclNlVzBqbWJGY29MOC9IbGkrUVNPVG1nXHJcbiAgNVhCMHNJdG9BZE9Sblg2RU5IblFDZTlZTlZCS1ZJRlhpREFTUlhwUitUMFpST2hObElqMG9pNUlVd1gwLzhqa0o1Qk1MWmhJb1B2UlxyXG4gIGo3QVdQTUVoaHNtaXZGeVdHZ0tsd2VCRnZDbk5XeEhLd3grMmxkOVRtaVJXWkVNR1JTYXVQSEhJR0tXZnJIWWxZWWtkQmNheGlyVEZcclxuICAwdUpRb1RSRnY0ZS91WkJEa1pFTEVTS3grMi9pVHpGOEFnc204bkNDa0l1RW1BZ01oeGdtaS9MVktNN0prR0d6cU9VOFhxN1BmemhjXHJcbiAgUnJzclBtaEd5d0V2a0F2NDcvRnN4Z2FzaUtxVHkzK2ZsWXZRYUVjZ0VrT25RTnFDY25nN0I2WXorUW1KVFpJZkkyUG5HQkZuYlVHWFxyXG4gIDJLc0srL0ZLaGdpOWlSTEdpTXArVHpCZ2lNTG81WkMxczdUSlBnSGRoOThUTmhJOHdTR0d5U3dmbDUyR1FHa3dlQkZ2U3ZPRkpQcXdcclxuICBuUnpqVXZOWVVXaFFZTUtiWEJuOEh2a1RTNHRESGtWV2xRUEdONVlXY09mck85OHpLRTZYRHltS0xQS2g0SmZHeDhWRVB1U1FOY2dZXHJcbiAgUmVMNEhIYWZQTHl4QlJONU9FSElRVUtlNEJERFpGR2VHc1c1bE9QbC9QeUh3eVYxWWFVSDFtaUpDdVFDL2pzODZ3akVISVExV2xCWlxyXG4gIHJ2bGs1RDd6U0M2Umt3UFpNbkNReUdnQlpDWVg2SW1rSnJJUnFRSjJqbzkwSW81NGdRZ2pVYVFYbGU0blFJVGVSQWxqUkpXMUIwVGhcclxuICB6U0tpQ21UVEFyb1B2eWRzSkhpQ1F3em1KUThFSDNIUWJRZ0dMK0pOYVo2UTJJZHQ1TGdXbXNiQ09FUklWTHpKN0RkOG5DUU5LUW9zXHJcbiAgNGp4em9UaEpXY0FpbUl2ejB6UTlkS3B5OTBsQjJuemdUVmtvVEJCUXBOV1FPVkpKdnBGaGdsZ1JCME1rY3Y5MTJFOFczdENDaVR5Y1xyXG4gIElPUUFNMDk0Sm9iSjR2eGtCZ05hZ01WTy9PVSsvZ0ZjNWkvSFVYYVIwZjdvQS96bjhSOGkvMWRHSGlJbkE4cmwvbitQNWU3UEZoaUJcclxuICBTQXlkb3FRTW5uZGcyck5zTHg4aDNjWUFPd1JqSFNGaW44b2dRbStpaERHaWVnSHNWYUdrd0dUVklqSFgvUDFlbkE3NWV5WUc4N0p2XHJcbiAgQk5WcUNKU0hGL0dtTkQ5STdNTTJDR0tTTTNQQ0FtV2k0azIwdi9BeGRSUUNNcG80RHgveVp0V2hLR0Urd0dsTUR4Nmp4YmxwNXN2Z1xyXG4gIEtyWGlQS3BDVWJLaTM1c3pVaFJwa2lPYzVCTVpKWWdWR2FXSjNMa1E4czdDRzFvd2tZY0tYR3BSQ2NFYkJKVkVNTm5TSXMyTW5zWTBcclxuICBPQlcvZ2h3dTBZRkVCejM1QTF3TThKL2wyVlF1cklpSzVGNXBzY3NuSS9lWlIvSWtMZGlDTW9oSmJNY3hlTWN5SVNRMnk5aXBER0trXHJcbiAgOFFxR0NDVlNnREJHVkMrZ3ZSY0hSbFRZQkdVRnFGMnlCeEc1OUY1cVlGNTNvS1JLT0FUS3c0c0tkQWEzWi8ydldKOHpjNEk0R0JJeFxyXG4gIGI2TDk2TWR4R2dJeUdwYzIzcjhMcGNnYVZoT3Fod3lTbHdMT1kwYkpVaFR0ZjdsUWdwd3BiMXpJS1JWNVRjUVZIV3VQV0poUkd1dk9cclxuICBGZmZKd3h0Nk1rQUZMcVdvaE9BTmdrb01hSUdVekw1aTI1ZjcrQWR3aVYxWUZza0JkMGpwb0hLRUpERFdhRUZXN3FCNWFENlJYSVJHXHJcbiAgT3dKUnBpeGFnU29kN0NJYXlPUWxIekdwYk9jWUZYc0ZBd0lSR2tBWUl5cmRSNEFJdllrU3hvaXFXbnNWaUFxYllGQVJ6bEtzaGVCTlxyXG4gIFlYcVRTMUN0aGtCNUNNc2JuMCtrWStndjRnL3JwYXc1RXlmSUtTSXhiNkw4OWVNNERZcEk0dExFKzNRaGg2eEJVU2hHc3B1S0lSeURcclxuICBmRUJHbWw4cEN2Tnhzc3FoSEZBdUZ6TEltZkRHN3lnT0thY2g0bnc2RXlWd3dvelNXUC83N1pQQ0cxbFFxVUoxTHBXb2hPQU5na29ZXHJcbiAgVFJ5YWs3Qm16WWFYL2ZnSGtEZ1FUQnU4Y0dHUUZwZDdndGtmYVFkSDh4K0JQOUxyZ3p4RVRnYVV5elVQSUpKN0lXS2pKUW8yWWY5QVxyXG4gIFpCT0VES2FqdlBRanBOc1lVanVuZ3dqN2NiekVJalEyc2xXVjM0TkJoTjVFQ1dORVZiMjlVRkJoRXd5cVEyMmRTOHhNTnEzSkphaFdcclxuICBRNkFFbnVWTllUNlEyTWZ5a3VEaEJCbEZJdWFONWEyZlNNVkJFVW1jZlNUS0kxWm1ReDQreXlUb2I0b0RTNnNNeFpBVkJORDZXTUtsXHJcbiAgQ1R1ME52SkJYa0djeXlmT3Z6d1VsWnUvdVZBTUtNcENCb21hTjVKcEhGSk9nMUcrSUpIU0l4WkdDbVBsOTlnbkR6R3dvS3hDR1o4S1xyXG4gIC84UFNnaHh0MWVIL0NLR1dyNTAxYS9wZTF1TWZRUExycTNxZHJSeGRkOVQxb0N2NHdEdlN5d0NtdlptVG0wQWlvd1ZLYXo0WnVjL2NcclxuICBZbEhMUmxqRU9IRWM3ZVhaL01FN2xna2hzVm5HemtXNkQ2OWdRR2lrRU1aQXpMYTJCNE1JdllrU3hvaXFlbnNSNjhiTEZDYUxSVVhnXHJcbiAgQ3FpcGE1UEVBWmFYcFRlT1E2QUVuczNJRGZvcitNTjZMYU1JSXpoQkpQUWkza1Q1NnNkeERwSEUyVWVpRkxFaURpbDhOajZFOHN0dlxyXG4gIHFDS1B5NFBtaWZHUHFZR2pIS01MQzlVWHVsRFNnT2V3V3ZwMm1CTjVvWkQ5YmVudjE4RFNLT1NoNmZJaFFxTGlqV1FVaDVUanZRYk9cclxuICA3OXhFSGs0UUNZMzFaYmRQQ20va1NRVVQvRC9NRHAvaXVGSlg0aXRJSE1qeXI3T05qN0kvMmd6OFNVWm01TXBpNCtRV2U3bUQ1cUg1XHJcbiAgUkhMMzV3cU15Tmk0azFzUjJRUWhnK25JUmo4Z3hSQ1VJcmMvWmR4SkdBQTdCS09kVHNTVmJBRVF4b2lxZW5zUlk1UFlBNkxJaTBzZ1xyXG4gIE9mQmRsTS9MMHJvc3REd3VHSVF0a0RQMEYvQW5aQkRCQ1RJS0x3cTZRR2xRR0NkNUl3UlJpbGlSTnhBSmIwTFE4b2JqR1lkcVVaUTJcclxuICBDbUZueTRTUVpOa0gxOWkrcHE1ZUgrak41Vk1RNHN3TFE3VkkwOFhIeisxS0Frd1RxSDBhSWlRcTNpQkVkakdYU056T1ZHaHdnb3pDXHJcbiAgV0NtcmZWSjRBNG1rbmZlSzgxZ1dsOWoraWcrK25qd3FjM0tqdmR6QjZBSjVZUjRxVkZwNFJFWUxrQzdRWHA2eEVkNnhUQWlKalU4TFxyXG4gIHdNYnhvbFJLeEU0T2lNQ3BHVVlnWXJubGJvQWRnckZxNUVsM01nZUkwSnNvb1l5SXNVbnNBVkZFWXMwem0zTWhORk9mWE8wREpSQ1dcclxuICBOd2l4bk9IM2syWmdjSUpJNkVXOHNmejBFMVFLNDV5ZHNTbWNNQTRCUHFrRVYwYll4R0U1Wk8wNWhFd3RGSnY1c0ZMQWVmaDAybDJWXHJcbiAgRGVsS0VGVWdXNlpjNEUwY0NvMldRMlRMZWJoajdySkVTR0cyU1lqZ3hieVJ4QzRFU29OUmZrZW04SENDU0dpc2xNOCtLVVJwOUN1b1xyXG4gIGhFdDBJQUFmZHZ3QmNwempnMjEwa1J5c0pIRHlrandnOEt3UldSdW1OUjBRMlFRaGcrbklSajdleGlsZ2cyQ3NJMFFNMmlsRUVGZ2hcclxuICBqR0c1Zmh4Z2gyQ3NFTWFJS3JVMm9UZFJRaGtSWTVPMVI4aWtTWEwxUkdXb0diWXVPSkkzdWYyQ3M0L2JkNkoyZ2tnb0xHOHNMLzJZXHJcbiAgbUlQQ09HZG5iQW9uekN0OU1nbFd0aExiUERLMlNXWjVkV1VFdzB2NW9OOTlldWdrTGMxam9UNlhGMW9qdUJPMlVMTkFMYjNycWJhdVxyXG4gIHdWSlYvd2w1SWxSQTFsUUNiMXpJS1NzaDJMbi9Kc2txUWJEVkVNR0xlU01KWFFpVUJxUDhUcGoxTUYwc05GYktaWjhVamc4T1BLekFcclxuICBtN1Y5K2VHU1d5RHlId3JpZzhnMFdCRTV1UWtTR1ZDU2h4Y2lObHBrUWU1T3drbzJ3Z3VMVXdJZkZkdkc0R3dBRU1xNGt5bWcyRTdFXHJcbiAgWXVzZ0FxOVd3aGhSRmVXTFlLd1F5b2dZbXpKN0w5WThoUlU1OUlsQkJVUjJqaXhJNi9ZZzVjbXBuU0FTQ3NzYnk4dHBFUlRHT1J0alxyXG4gIEE1d2dEZ3FmUklLVnFjQXVqOGdteVNSVkZVT1Z5MytXeVNaR2JPd1RjUVVsdndjVkZTRENDRmFKc2JnR2xSZlVjVmdHcVhubFQ3QXNcclxuICBRS3lXd0JzWEVrVVpnbzM3RDVNc1BJSmRDQVl2NG8wa2NpRlFudk9aaThBQXhnV0RzVkllTDhjeHg1UnBQSk9qWWMyYVZ2cXpQMzZmXHJcbiAgVE9OOXVlTVNISWorMllybzRNdVJ0OWpMTGZaeUI1Y0hOazdPc2MvWVlsRTdHVkN3N3dJYnB3SWhwTGR4Q283QkN4dmtJc3JsaFdDc1xyXG4gIEkwU012TDJDa2JVekJ1SkNXd1JqaFZCR3hOaFV0QWMwVHhGaGswdFRKWkswYVhySjMrMDNVVG1CQ1QzTEc4dkxpemdvakN2TUQzRENcclxuICBWT0d5bEdOb2VZZFFoRWdmRW51UmhCeFVVZjZwbUt3azhLWlNLRWcwUHpWSzg5T2pUQVBPaWNSUU8zMUdKSisrY0Q5SktFNG1JWU9nXHJcbiAgS3Y1VWtaQURiMXhJRkVVSWV2ZGYrNlFKZ2wwQ0wwNzFPYzVsR29RTXgzaEJRbWFoVDZEakdaREw2TUQ1RXNHS2owRDRReDFoQjE1WVxyXG4gIHIyU1lMSkdyUVBOd01vYjdRd1ZHWkd6Y0NhVXlaeFBSaUgwK2JDc2ZGZHZHNEd3QUl5QXF6UXN3blVRK1p3UGtwbE1ERUNhdVpBdUFcclxuICBVRWJFMkZSaDczTVZWbVV4TUFkaWFXbXhzQXBLVUpEVzVTNWxTVlRPMW9TZVZVSS9RYXhnU3ZKQlVEYkFDVktGTitkTk9CNUJuNGZwXHJcbiAgZmNJZ3lrTVYrVStCdVJNbWdUZHhLRGF5c0hMVU5iVlpTbXhiT09ENWd6ZzBVSDF6dTRSTFExeStUTWorTnY3bVFvUWdUaitGeGtDc1xyXG4gIGN2c29zL1ZRdlRzWGZESVBsOTRGZ3hmeFJoS296b3NsR0NVMkpoVFlPbVR5S0FPRXFDS2RnVGQ2QllaTGFvR0VBMm14UlBIQlpkckxcclxuICBuRHcrQVp5TW9RSVFGaEJGdEtTTGJTenlNb0JweitxcEVXeWNnbVB3d2dhNWlwUldpTUFBd2hnUng1WVFpTkJnaEloVFN4TjZFeVdVXHJcbiAgRVRFMnk5aTdIRVVraE9jTXhyTzhabWxsVXhCZDdsS09KRnZIZUlHeEt0TlBvbVV3Si9rZ21NZ0RBaGNVM3BRMzRUZ0VmWXBJN3hPYVxyXG4gIEtBZFh2dmlUTVhVQ0gzampRbDdKNFhKUWxGOGFhdW9hcWI0RjNTSncvYWpBY0huR29ZNFdacWRZVzV3K0h5NEhCZm5GeDhkRVBoaUNcclxuICBLUDBrUmc3ZW1EZTVZMTRFMWJsenhTZnpjR2tUb1lsNEk4WkI1emhmUHJGUjU0Rmw5SmNXOGRCZ1d4VGcxR0g3Q2h3dXdZRTQ2TUhXXHJcbiAgNCtrT3Fna1NHYUIvdHNJUnNJdG9Gd1ZEUmtFNmlTSWIrOU1WZWlya2JFQkhOaTRLRlJZZ2dzQm03Q3huSi9CcUpZd1JzVmN3SUJDaFxyXG4gIEFZUXlJc1ptR2Z0NHowSlVTT09Tb3ZxcFpncWk1TzBTSVFnYzR3WEc4c2IybmRFeVRPZnk4Z0FUQjRVM3RmeGlYUXJUeFhtN2tFQ1BcclxuICBVdnFKRUtjTE84OHFPRlNMb3JRYzRyeHpZWGtUWXNlL09PK1dLRUdjYlVPaSsycUpGcVpHQ3RPNzRQWlZxSFFoR0dWQ3RjaWtTL0tQXHJcbiAgVkFabDAwOWlBRGlSQk40azVTeUM2dVQ2ZE9ZZUxwMExCbUY1NC9OV0JBNDYvQlZGRHJ6V2xqQjUrYjdDTmd0L0ZLcCtDbDJnQjFrM1xyXG4gIFFvVFl5eDMwejFXWnMrSFltemlaMzBqc1RncVZPWnVJUnF3R1FzdEgxQVUyd2dhNWlwUldpTUFBd2hnMnJNNk92MWxidjE4QWhESWlcclxuICB4aWEyQloyeFQzSURVU0ZOMEFTcUtpU21tYlNPdGYxNmxvT0NLZGsvZ29rRVlGeFFlRFBlaE44ZTlBRW05d2xNbE1BZG0vZ1R3YVdSXHJcbiAgd0p0a2Z3alZJSlBHbDhlRkFoRkNQbVV1NUJHMHRkd0NhZXBZSTFLZGZaVmY3NnFtdGtsYUt2cW9Wbkd1SWNjS2dUZlpVS2pJcGF3R1xyXG4gIGtiM1BLeElibEUwL2lRSGdSTG55WktGeWQ0NTVjdytYTGhJS3l4c3hWSG1naW9HeEQxM0M1SlVCZE1BN2tLcWVRaGZnZ0Z2c1liSkVcclxuICBEcG4ra1VIR1NQNVZvNk0vRUhFd2NYb0VMMlF3SGRrSUdUYUcxTVpGYWVVdEFtTWp1WWd0WDRFSXZOb1RJb2FkVnpCRUdHalRTWEtSXHJcbiAgT3gwZ3draWtlUW1MalFSSE9EQnRhVlNqV3cyT05IcFpaTklDUG4wb1M5QXlKZnRHTUpFQWpBc0tiMlo1eGJvVXBuTjU1c3hjT2R3blxyXG4gIGdyT1h3SnRrWHdpVmtMRjE2YTBjR1RZWEFvcTBLd2twdXJ1YTVRRlBCV2I5cEMzSnBjVWxtaDBmNDNMRmFiTjVyalFvaWpUeGNTZ1JcclxuICBSS0VTSWp1ZlJ5UTJLQnYvMjVFU2NLSmsvMFZRblZ5ZlRJcTVoMHNYQ1lYbGpjKzNHTFcxOWV4RVh0NUx1TWZ3UjJINXA5QU5jbXpqXHJcbiAgQTR5RGJyR1gyNTltdEFLQ2lCWWVrWk1CbWs1aGhFUk95TEhQR0tjWFBpQ3hGVXJqeU1iSlZhUzB3TnNBUmtERThzcDJ4bVR0UUJma1xyXG4gIGllMktIQWNnQkRaZXdtRGEwcWhHdHg3Q1ptVFZ3cVhsNE1vUmNqRXVLUzlnOGtob1dYREk2d0pNN28xTjVPSEs0RDRSbksxTEd3UWNcclxuICB5cEN4aS9iclNXV1RvTWhLaTBLVktFcGFFRVluNXFoM3pVWm1IQ1k0cEUrbXowMk0wc3pZVUdINkpGU05vc1RaVUNEbGpRdUpJR2RaXHJcbiAgaHNqR1oyWWlnN0x4MlpCVGN1Qk5zdDhzVkY2Tk01RzF5Q3F1QkpBa2Z0bGpaVzdVLzBtQTBjSTZHYUIva3NJUnpnNHdRaUl2OUgrdVxyXG4gIHlqaElaTFRBWkFJOWxXUVRkc1pJYlZ5VVZ1QWlDSFJzNTJnQkJJNUhiTFNJWTBzUmVMVVN5dWh1dmNMQWZDS0s4dkwyc1FIVGxyOXFcclxuICBkT3NoYkVaV0xhSzBhUTdHMlg2RHdqRmVvQ1lTOHJvQWsrZnlBN0R2K0JQQjJicWRlRUVaSWh1WEppYVY5VUVSUzdLaEFvck1KZkNtXHJcbiAgS0JRYko2R3RrV2pkK2swMFc4OTN1QTBZc0FWd1F6Zk9ZWXBEZUJaaGJweHY5dVpMcHZPNlVGUU9DY1htbFZHVXdJV01oRGN1SklMRVxyXG4gIHFneW05NW1ZeUtCc2ZMYmtsQnc4d1NFTGxaYzVFd3lnVHcrZUwzQWlNcktvNUN2d1dJRUQ0UU5lMXlxeEJoZkYvNEQrS2FrTng5NGtcclxuICBrbm1oL3BtT0RwR1RNVEo1QkhXNWpXeEZWTmtHa1RvRXB4Q0JWM3RDeExFZGtMVlRScEpqazdORk1KWUpueHMyRmV4Vm8xc1BZVk9aXHJcbiAgeXpFY3o4cW80ZXNobTRNdll4QXlVb0dZU0hEeW9BdndSZ1VtdnFUOGllRHNYRG92S0lQcG8vMUVwQStLV0JLSEFoU1orWXd0RkJ0eFxyXG4gIHVIU01qbzdUOVBRczFUVzJVa3Z2VnM3T1haNm91TktIMmVhbno5UGM1SExkeldVb0tqZUg3Ry9rYnk0VW9zZ1FJU1BoRFVJQnc2RU1cclxuICBwbmYyeGpvbzY4NmtuSUlEYi94K3NsQzVYTmZPaktHdkVzNEMvd0dPL1N0T0pNYUtXeUExN3FTV2crMytGUGRIT05yZy9oSFRLeG5wXHJcbiAgZlJyQTZmMUc0eWdQK1lEVmpVaXpOc3BEWkxSQUJJRjJjb2dkTFJDQkFZUXhJdllLQmdRaU5DZ2hvbVMvZ0FnamtmME9KVldubklGcFxyXG4gIHMxZU5iZ1dPektTUi9OdytncmdpdEo4ZEY0TWxTc29JbU55RVF2Rm1SVTRqZ2Y1cS9VUUFJOEVUSElvUTZXMGY4YTVjVU1TU1ZKTWdcclxuICBaOFliaEx5Q1EvVW9TaDErZS9GblhWOG43N3FHNXVabWhHOXM2NlBPVGRkVFhaTjc1aU9mNDlURkk5d1NHV0NxN0pOUHRUSVU1RkIwXHJcbiAgMEJFS2tUVlN3MFRDR3oza25vaENFVXdYbDhHZ2JQekxJNGlJTjM0ZldhamNYMGV2b0Nxc3pJRzRJeXVSTzhvNDZMeE5aQXdWZ0FpUlxyXG4gIGw0SFVkS1lBWVhwbnc3RWptUkF5YkJTd2oyeGtLNkxJQm5UR1JrVFl2MWVJd0tzOUllTGw3RlFySjE1UU1Kak8yUHFjc0tsZ3J4cmRcclxuICBDandaeVJpU1g3SVB3Tmtrd2hSOEU5RFV2WVZxNnBzeXB2bTBrcjF1d0trd2dlbHk1UUFiZnd3Z0pNRGVNeHl5aUhTV2Q3d2JCSVhqXHJcbiAgNHBCQm91YU5DNm1DUTJXazFpV2ZPUDhrNURKSXdzek1ETFcxdFVsd3NyckdabllpMTFGenoyWVd3Tm5ENlRkRW9aNW14czdSNHNKc1xyXG4gIGtsY0l2TWtFZHo0WGY5akV3dktJclRrays0bFVPY1RLWU9RNTNpQjRKbWc0WkdIeTdINHRTbjlaQkZIeXh1ZGZIY0lhV0N1c05yK0VcclxuICBzY0lXQ0VKODBQbXY4Y2MveUlMUVlvbUNUQ3RicFgwVU1tSXc3Vm43K3pQN1RmZWh0T1lieWNFTEc4bEZaTFJBQkFZUXlyZ0xMYURNXHJcbiAgem0wY21QYjdCVFFmWWJIUkJPQU1USnU5YW5RcjhHUWtZMGgreVQ2QXlDWWlDN0dFcWRvTG1vY2dUU0JaUzBqbEFkNGdvOVpmNmo0ZVxyXG4gIElDVjRna01SVEdmNXhydEFVRGd1bFhva2F0NGsrMFFvUjdBcStQakN1SkFrQ09FU01UazV6azVraW5wNzgyKzRhK25kUWgwYnIrWFdcclxuICBDSjVHajhjOWFtbCthb3FtaGs3THlnTlZJeTV2RW5oandaMy8rWSthVm9hejBydzBST0ljWXFVYWVJNDNDSjZKYlBJd1hidy9RK2t2XHJcbiAgRUpZM1B1OXlyRm5UVFgvMnh6Ly95aFRlQ0pmV0FoSHdYK0ZaUjNDY2xVa1U5TGswR2IzLzgza2pIOUFoRWNQcEFTTWdxdElHbjBqZ1xyXG4gIDFaNFFzUmN5Uk9EVmpoQ1IySGtGQTBJakdYNXZZaVliY0FhbUxWL1Y2TlpEeUZRbStTVmxBU0lianFTSFZnWUFFNk1jRm1ZbmVSdWxcclxuICBaYVMvS2NnVkpzdnRINno3UkRCenNmZE1GaWJYSGJzb1krMjRWQ3BJVkx4QlNJVEZDQmJwSjFlQU9DeUxva1RWaDRHQkFScmtjUGpFXHJcbiAgK1VKOWZYTW50YTNldzA0RTQ1QVlEd245OUxPakF6VGVmNWovOW1VRzFYTmhHUlFsc1dPVS82aTZIRDREU1o4N3pnbGloU285eHh1RVxyXG4gIGlMQ1FoY25qL1JpVWRhV09JQ3cydUlyZ2tOT2dhMkM5TW9VM3hpVWVDVDcwL21EYm4rRCtLRUVrODBLWEJpaldleEsyR3JtTm9tQWZcclxuICBLcXBzZ3lnOVdiSTJ5cWNPaHBITFN4bUlJd1dENll5dHowY2lyMkRBRGtHbGFvZGdFRGFWU1c2RlpUR0JrTXJYOEozb0RKWUVSN2RHXHJcbiAgQmN4UGo4bE1FOGxXZ3FaUFlUSzM3MGd0WmJLUGg5akExaGxIT2crVFc1NzVyQjJYU2dXSkttRTQ1QkcwNmNlWE1SaG9LRVhXc0NoY1xyXG4gIE92cmFHK1RKNTQ3Mmp1S3NMZFExdDFIbjVsZFJTOTgyRnNCWjREL1dsc2Y4NUFpTkhIdWNwb2Y3aGE4T0JUdkpoUkxrVEhuRElmOVJcclxuICBkVEY4WWtrYnN5bGloU285bHljNFpHRnlLMk5za3BZVXdQSEUxR25NZklzRGJyaGVHVURQNGhJY0NCOXFPZGJ4ditCb3hCd2tTdlVoXHJcbiAgamNsanZVc2pzTDh5YkRRdTJFZGE2WWtnMEdZRFdUZzVJRE81d0FnUmVTRURBc2NqVmxxU2lqelNaZkx6ZThNbXNRV1kxcTlKSTUwSVxyXG4gIGd3YVF2REw1eDNwbFZlWTFtT1RnWisrVVkzRnVraFpteHBqeUtTTXc3L2FicVBUWDZkNE16aWIzVzJPWWptMGtXd1NUS2h3WEpJSllcclxuICA3UE4zSVEvVmhFOXVaeTRVSW1zVWgyVlFsQ1FKdktrUXhzZkhxYnU3bTNidDJsV1VPQmN3SnRLOS9UWnFhRVZYQ3Q0ZEVoNDJuQm80XHJcbiAgU2FPbm5xSDUyU2syWmZ0ODhqUXNpNkpFTGhRZ1o4WWJEdW1uREZIQ2JOa1RwQXJQOFFiQk5oYUtZSVlaazFBNk9JcWk4QXF5V0tFRFxyXG4gIDRjTXJCencrNm82Mk9LTkhCYWhjcFBkcEdPNlA1STM3KzFUdmJKd2VNRUpFWHNnb3R3bFdXUnZsdFh4ZUFZR3FCVXFJS0NrVEFLR1JcclxuICBUUGhjeEV3MjRBeE1ZeitJSE8vMFFrWThRL0lLeG94VXI2ektVZzN6M0x5dWJYVFBFRlRBMGhMTmpKNmx4WG5YVXJHY2t2MENVaHI3XHJcbiAgR013MGxOdHJJckJNOHVKMGpqU05VbkV3Sk9LRTRaQWlhT3dUNzhTRlFzUUdjU2hCa2FuZmx3VlRsSCtjUlQ1ME5TOVJTMHNMTlRZMVxyXG4gIDBQSCtvVUtib2xCYlYwOGRHNjZpMWxVN21VTjNGcnExMUpFc3pFelEyTW1uYWVyaUNiWXQvdmljc3IrRnY3bFFpaUpqaEFJa0psd0NcclxuICBCUDhwU3hVbHlwYk5JeGFxUWlqZUlFUUVWQm1ZUE03N0Zhd0lLM0lnOGovRVIxa0ZJS0lveUxUU1ZUcEVrU3pTZTVXWEFiQXgwZ2lvXHJcbiAgelJxY0V5anQ1Q3dydGdHY0RiNWV5SURBOFlpVlZwR1RBMHhuOGdza0tNOHhZSWZncE5ncXBXVEVNNlRVU2Q1QXhJaTViSlNFVE1CVVxyXG4gIGxLNitxVU5seTJCeGRwS21oMDdRSWhaZWhIbVNSRW9UUkU3dnkrdzFFVmdtNWNEdnlGbzVMa2dFWGh6ckVWS29OSHpjZmtCS3lNRXBcclxuICBzcUVBT1RQZXVNQ0MvTWZNTXVGU01ESTRSUDM5L1RReGdXNlRsYU81ZXdQMTducWRETFFIUjZMakkrak9HanowRUUwTm5oWStSbEg1XHJcbiAgTmFRZmtjYkh3MFErRkNKcjVFSUdYc1ViRHVtbkNENkJwVEUyZ1JPcXduTnVvd1NITEd3Wjk2VXd0dlFLbHNlS1d5QStsai9DYUI4RlxyXG4gIG1WZVg2RDNKUkZCNUlaUE9CaHVWcTBOU1dtSkhPZ0lpdHZIaW5JMHk3dTdIdys4TGNEWnFGeWtZRUJySmhNOUZ6R0k3aHVVcEt0c0tcclxuICBoSXg0aHVSajlnR1JqWkRLUjFJR1UwazYxZUxaZ2RwR0RMWXVqL21wWVpxNmNNZ1Bxb2VQUWJMVWZEVmtZWEsyY1VVSlZvNExFb0VYXHJcbiAgbCtnWktnMmZKSE9FSEdKbG9VSGVSUEpVSnYxRUpoeXFSelpsUVhEN3REQjB2cDliZ1hPMGFmMkduRzRsQWVNaXZidS9UQjlBbEphSVxyXG4gIGE1RXNzZ001U2NQSFBrOXprMlZkbHVWdzFpRmtqcEl2UThhd0VNc1lKZXA0VC9nVXdZemovU2R3UWxWNExtd3NLTENDOWVURm83WVNcclxuICBMNlpNdStCVzRjVkxwSUw5SzFpeEF3SDRBUHBqYUlUL013RCtzNWZSZXhLMkVtWDFFVzJSVnVZT0VCZ1oyd1FoTXlVMnVYd2NqMWhwXHJcbiAgRlRrNXdIU1Vueitoc1JGalV3aVlabG1RUmpvaEk1NGhsb2tJakFtRVZENlNNcGlLeXFORTBLSjdvNmx6WGRXelJSWm14bW55M0FGdFxyXG4gIGpXQTVjWmRkN3JjNW1CeS9VNlBJeW5TUkpJaDQ0L05FQ0FoUy9maE1YVWdRS3dvTk1tcmUySDdUVHpDcGpOZ3lDaTVmSDRyTmtoQmhcclxuICA1enAyOGdzTHRIYnRXdW9mclR6cG9WcTA5RzBWUnlMUGp0U2dJdFF4a3NYNVNSbzc4d1JOOE0zQ0VnYUtzMlV2TEN4Q09WTEx6RkgxXHJcbiAgZVVkR09jVEtBcU5FbGR0REJpYk43dGZEQ1ZRb0ZHOFFiQ1BESFBvVXV2RlJ3T3dyWFlVM1A4MzY1WXlWdDBCd1BBVkd5TUYzNEQ5M1xyXG4gIEdiMFh5d2RFc2Q0UlVKc2xPQ2RRMnNsWmxyTnhkS0VOdytjREtDRWlTZXNWSmpTYUNaK0hSSkVkYUxOVktiWktLUm54RE1rcGs3ZG5cclxuICBoRlEra2pLWUtrdkRFSldscTIvcHB0VnIxcXFpQ21CRzF1eG9QMWN5VDlIRStlZHBibW9rODJ5QjdjdjJueFRENlNKSkVCWG9EQ3JWXHJcbiAganhYZUNUTnd3a0psUnMwYjIyZjRCSFU1WWlzTDJUSmx3NHFSWm5EeTVFbWl4a1o3OWlQVlhXNW9YYlZkQnRyMUlVUkFCNEZuUnM3U1xyXG4gIDhKSFAwVFRIQ1lxejRjQWJPNTc1VUl6VUt2b0hpbzVuRHJFeVkrREZ2T0VRUGtVdzQzaC9IazZnUXFFQ1c0aFhwdkFXWXdWSGc0K3VcclxuICBQOEJHeUZGWG9PSlNGaHNPRWdXOTBNTGFYMTZxQjVSSUsvTzhYa1JzNDhWVjJ6Z09zZElxY25LQTZjak9TcTBtSW5jNmdHbjljb2gwXHJcbiAgUWtZOFEvS0J6SXNpdlpES1IxSUdVMlZwR0tMSzdvZjVMVnV3bmhLYTRDc0FPNDM1eVNGdWtSeWswUk9QMFBqWloyaDYrQlROVDdORFxyXG4gIFdaeUw5dXlvc004Z0t0QVpWS29mLzV2eVpneW5LRkRHS3R0WCtBUlZNV0lMRGxJR2hMeHFlUlFscWhSU0RBME44UjN0R2hsRWYrR0JcclxuICA5NHMwc0NQWlFUMHlSb0t1TFoxTmhKdUZ5Zk9IYVBqWXd6UTdQaUMyeXlMN1V5VHd4bzUvR3ZKSUxhSi9LbnZzYzZpZzlDcVhvK2FhXHJcbiAgaHhuRysvSndnckswcjZBU0xyMExTMDRjaFZaZVFrVlJKSXYwUWVWa2pDUTlCM3lqL0oxTVlZU0lJaHZZTDJlakFvTVNra3oyNVJVbVxyXG4gIE5KcUpRR2JzUUxNc21Kc09VY1lXdWNoK3ZDalNDNmw4SkdVd1ZaYUdJYXJNZmhTaWtJb0o3eStvYjI2bDNyN1ZLbDhKbHBaa3F1L01cclxuICA4R21hNkgrV0hjcWpYT2s4UktNbkg2ZHg1aWNIanNvZDdlekVBTTNQVGtoZnZyNUxPb1dXVUQvKzkrU0s0b1FGeWtTbFJQaW91QmcrXHJcbiAgRVg5ZFNNWGx5Qm9XaFdJVVdVcmdqUXZkOWVQeThqWk0zMzN1MU1WRTk0S0VhTC9vdjIvdDIwWjl1MStmT0pMRnVXbTVRUmc5K1JqTlxyXG4gIFRZNUVLY3BDQ1hLbXZFRkloSGtFYmZSUFpndWZJRlprbEY3c2N0TWM4ekJEdDU4RXhTbGVRVGxxbHVhZWtyYnQyYk1YNktaWHY1dk9cclxuICBjRnlNV3FwdDdyWkYrTUtCWHQ1NUdNbEVVQlhyWFpUODlUNS93Tm5FRnBMQUVFbXo2V0xXR0RVcHM0djJVY0ZPbzBnblpNUXpKS2RFXHJcbiAgbExmUHBrZ0ZHYTJseVNOTnQzdDFEVDM2NkdOVTE5aEF0OXo4YW5ycXlFVlp3WFdPV3hpWWdmV2lvNlpXenBjYWJnWFYxTlhMSFhFTlxyXG4gIE96VDJhaXBqV3ZRNHA4eFdiTmpXOFdJRDJySXNSMlN4dkhHRTZvMXpsaFdUbGl2M2JHamwvK1ZSTnFtbDNidjNVai9HdHY5Tm9OMVlcclxuICB3T1RBTVpvYU9NNlV1NGRjb29hMlhtcGJ0WlBQbDViSXNocXN3RG94clp3dWFDTzcwaVFsQ2kvbWxwZFJlYWhtY1c2V3hzN3NwNlVGXHJcbiAgakJ2RldLSU42L3Zva1FmL2h0YXZ4NDNZSzNBUUI0S1hxRHoxMUhQMDFyZS9sL3JQb1VsYkJIWWdMZXhBYXZqaUZuQ2w1NjhSSXlSeVxyXG4gIFFvNGp2YXE4Z0pIcVphdEdRaGZwVmVTRmpFdXprVzFTRmthbWJDRkp4ZzRhL1NydElHVEVNeVNYUkpTM3o2WklCUm10cGNram13NXNcclxuICBEZFZQSEtQaDRWRmFXSmluVjk5Mk94MDRnK1dvRll0OGtjQ0p6SE1MQTg4TjRHNVVGdVZieVpwS0x4RnEyTW5VMWpkemFLSzZoaVoxXHJcbiAgTXBEQitkUTNjb3hnanNpajZMamxrVmdWSnFrdW4wcG9tRHRQL1dkUEU4M08wMjJ2ZnlNOWR4cFBPcjgwVUVkeWdpbDNyQmFvdVh1ZFxyXG4gIGRIM2htU0tQcVBZdHI0aXpxTUl5TWFsc0g3UkdWVFF2VUhwUnNUUEJNMUZqcDU4b2NDREVEbVQxS3c2a0FPSkF6cDI3U0c5N3gzZlRcclxuICBrMDgrVi81R1FyNWJxbTN1NFVwTVd5Q2hYalVpVXdGNzhUSjZSNVMzR0l3UVVXU1R0YmRvT1JzVlplU2VqVkpYc05NbzBna1plTWtsXHJcbiAgVXBmWkJpbFRrWWtpMGdxWk0yRGswOFcvdjNubUZBME1ETkg4L0J6ZGNOTXRkUGhDUE1mZDdESlpvQXNLZytlNGlPQmtFR051dk1qeFxyXG4gIHZBaDBtQ3V2aytiNWl6NTEyTTJMQTVJWDhYeEJPcUVhY1RpMTdIRGdmT29hbWtXR0ZXL3gvZzI4d0FtejE5S2o4ZUpnYnVRWWpWNDRcclxuICBSOTFyMTFOZEI1N2ZlT2t4TlhTU0hja3ArK3ZnT09hcHBYZURETWJua2FrampDMnBPVEpZeGlwUmw5c0dqVkVWc3kxUWVsRndKampmXHJcbiAgeDA3QmdlUm54TDNpUUlvaERtVDU3aXVHZHlEb1VqQ1p1OWl5RmJXd1ZwV0ZqY0xiQnRuS25FZUJuckZzSGd3MUtiY0xaR3dEcUoxS1xyXG4gIEk1MlFFYzhvZFI2UmJhSUdsd2dDa3krdlF6WU4yRWhnNU1MQVFacWJtNk9abWRuSWdZUzBhUllwRjlpTW5LRVNrK2ZWakVKaEpFNXlcclxuICBLRUdrTFRCVVI4ZS94ems4ZG01d1hoTERtY0habVRPVDFwWTR3MW01eTVTcHloV0JaMm5hcUI3UDA3Q2pRUXVudnJsREZqUk16N01zXHJcbiAgS3Y4aVlNK21WbnI0NFlkcGZtS0NicnI5ZGpwNlBuKzNlMW1vV0pIR0tEYWNIRGdldFVqZ1NPYW9wVytUaktFc2p5alBZcklBeXhRNFxyXG4gIFVaZmJCbzFScGFZRkNwZUViNFJHMllFVW5SK3ZPSkJpck5DQllCcWJtOVZqRjB0OFFYbTZTdWZCVVZyeFJiUzNpUzBrZ2NIcDhRMFdcclxuICBSVGFhYlprTlNHTXEyR2tVNlpLeVFoTnNGYkd0YnJJcFVrRmc4dVYxeUtZQkd3azhxY1RpNEVHYW5wNW1KekpMTjkzeUducitQQjRzXHJcbiAgaTdQSVpBYUlxRURPVUNsdmk5V01Bb1VYK2RRVllOcktSb3h5QTY5SlRDcG5DT2V5TUR2RkZjZTBQVkRKenBkNTBBdXo0MXl6NUNzZFxyXG4gIFBLelpnQzVkYnJYQXVXQmRLaG5MV1FZMWs2ZGw1ZDJtcGlacVc3UFhwQzh4TWo4UGpuaHE4QmlIVTh6QmtXQ01hb0ZiSTF1b3BXZVRcclxuICAyRlNQS0hOWFVXdFVnc3Jhb0M2M0N4cWpDazN6UXZ6dTBWTlB5anB4V2F4ZnQ0b2VmZWhEcnppUURGYmtRT3JZZ2VoRndoZWtYSlBSXHJcbiAgaGVrclZLdlNFajNIam5TRWlMeVFHVWVYNkZWZ0tMRkpLbldsODVVeDA1Nk5VcGZZcVNTU0N4bnhqRnpyeHlHeURWS21JcE5FNDhuRVxyXG4gIGdKRk5BellTbEtScm56OUxwMDl4SmNEaVcyNTlMVDNYSDY5N2xZR0k4bktWbUx3Z1dhSFFpNUxVSlRCdFJhTmlwWmNtNm9vWkxZT0NcclxuICB0SkVJclpmNW1YR2FueHBsYmtsV05KN0g4ekpvN1VSb2FPc1RwNEl1czhhTzFUSWU0ekJ3N0RGcWFtbWhiZHUyMGNEVUN6bDlWeXZFXHJcbiAgd3JyeU1vQW5zME9McEk1L1V5MDdrcTNVMUxsRzlKZUdxSlJHbHBlN3dpL3lxbXBTRzFWb3FrSjB4NDZmMlM5VDFyTll0N1pQSE1pR1xyXG4gIERaZnp1Ny8wVUwwRDRXWjhuUnNEa1lzcXVyS2l5aitvZ3N5VFJxU1ZlbDZ2SWk5a0pxSzlUV3doQ1F5Uk5Fbkh5T1FqWE5nWW1EWldcclxuICBvNWd4MmlBNUpLS0lzWDBGU2RZV2lMUkNaZzN5YWRMalluSFdTRkJEUzBNSGFYU1VLenRXMy83YU45RCtrNWs3cXdycFZjTGJ2SXBSXHJcbiAgS0RTeFQxa0MwNVFiTUlxVlhwcW9LMlpVZ2t5YVM4bkNvRWwxT3o4OVRyTjRUem5meWM1TkRjdHNOdysrQVZ1emZpT2Q3ejlITFowOVxyXG4gIDFMYjJLbE84MUtnME95bEFIUWxtYmNFWjFyR0RiS2JXMWR1a0ZaYWltdHl5aU5JWVdaNUxoZnk5cXRnbVNKa3F5V2JpL0hNME80WjNcclxuICBzcVJZdmFxSFB2L3doMmpUcG5VbWVRVkFkUTRFclkrbUhuRWlOYklXakx2aU9IWWtFMEtHamNhUlhyYVpTanlyVjVFVExxY0g4amI1XHJcbiAgeWppMWlVaTNNYWlkU2lLNWtJR1hIQ0oxa1cyaUJsZGlYK280b2doSWN2UmtOaDNBTXYzUzhMSFBVVjFkSXkweWN4dTNRSjQ1TmVWTlxyXG4gIGl0TkNhdkpDZFlIUWk3Sy9PVWFsUEIyS2xTSk5WQlV6S1VCa3Y5S2tqRXEvcWxxZ1QzMW03QUl0VFEvUTVCamYzUzZGRmt0VHgxb1pcclxuICB4RzlzWHlXdEZvK2kzWlpVZWk4MlloZVRkU1JOblgzVXVtWmIwc29TSkdWZGFjRWpleWJMVTFmSTE2dUtiVlJxdXNnRXp6Vk5YanhzXHJcbiAgWE1EV0xldnAzcnYraEZ1T0cwM3lDb0RxSHlSa0o3Szg4eWpYeTNaWjU0RjhuTEJJajY4WE12STIxVHNQVUpFZGVQMkNrYTBnWXljNVxyXG4gIFJHclBpSmxzSWpWVGxxOUM5VUtKS3ZBQlVHaWtRSDZSalpDSmdZRjV6aS9lSGFaaExpd3NjSDAxTDJNaG1rdzJvbmRRaWUwbnAzYUNcclxuICBTT2hGU2xqS0RNeklGU2h2d0hDS29QUVMzbWoyWG1LaEVpSTdsMEVrS29PcWl6OHJRcnl2S0dEbTE2YjFxOWg1ekZBRE80clczczIwXHJcbiAgYXQrYjVIM25lTU1ndXNXR2p6OU1Gdy9lVFJlZnUxY2UwSnlVYnFOTVJ2NDNWUXI1WklWaEJZaVBSOXVxSGJScTd4dXB0UThWNlRUTlxyXG4gIGpKNm5vVU9QY3FWN1VvMGRrdjN4QmlFUlZrSmt4K215UHkzQVNWS3B3S3VLYlZSaThpanpPbkhpWUFMcTYrcm9WMzdwaDduMVVmM1NcclxuICBRQzhYck1DQitJM0cvaGpyMzZCL2xFT3FsKzB5ZXFRUEZrVjZmSU9GLzlNRlN1Z3V5bTI4T2xjV2Z5cjViZFlPRnZJYnZFZ01BZ205XHJcbiAgSXdWTUJZWVJhWVJNbEF6WUl4akxoSDRNSUNTaGx4aVlaM21TVkkycHZyNmVXeUE2c0t0eG1sYXRrQkRCQkI0NWdZbFU3c3FXc1dDWVxyXG4gIHRGakpjSXFnRkk0M21yVW5MRlJDWkNmcElsRUpYTW5qVDhVRURuSGVTZUJOcnN6NWNQdzQ3dHFKVnExaUI3Sm1qOUJvZGVCNWk4NU5cclxuICAxNHBEUWVoWWY0WG9jQ2Q4OGNCZEVzYk9Qc3NWOUJHWmJiWThpdmVmQzNHNVRaUUxGWURwdmNHUnpIQ3I1Q1FOSFB3Y1RWM0V3SHNKXHJcbiAga3Z3VGhrTWxtSTJWTnk1MkFEZ1hNdkRpdk41SjNIbUExbUJOZmRxYW11ZWJNRncvdUo1ZVFZcnFIWWdjWUlzZHlZU1Fjakk0T0QwMlxyXG4gIFNpZk93Ly96MkNnTnZZZ0VLbE1ZSVhvbmhENmlUWlBlelhNYzJmalVZV09BblpOZ2E3b2tMMUJNQjViaDdCQmtFNm1aZ3N3TFZDK1VcclxuICBxQUt2RUdFa2lzb0xnTWlsQVpobmVaSlVqWlZrb1BXeHdLMFBQUG5kMWRWbFVtZUZoQWdxQzFDdGgyT3hML2trV29OSlhYNDVBeWNNXHJcbiAgQ3VGNGcyQWJDNVVRMmNYN1FpaUFLM0g4cVlnNFB4OTRrNVF2RzZxRHpMcnE3ZVc3Mk1xem1MQ0tzcXhmdGVOV2NTZzlPMitYaHlYblxyXG4gIFp5YTVncjVISE1wNC93RnhLQzhjaW40WEIvZmJJNUVQQm5Va2I2Q1d2dlhNelVyTGFlQzVoOWdCWG1DelpZNTdrbWZDY0tnRXMrRTBcclxuICBjUkVEVEorUkJuR3hIaHhtbVRhMjlxa2d3cE5QUFdmVUs0aXhBZ2NDOENIMng5eE9DL2t6RFA2Zk5KbXdHYjBTUHNycGhjVkc1Y3M1XHJcbiAgRjhuUzV3dWtOa0o2RzZmZzJQYWxFcE1qU3ZJQzY0MFlZaEJJM2dRSmIwdHNSU3o1ZWlYRCtFaUUzRHdyYXJOSndEekxrMTJwc1pLQVxyXG4gIHNEVVl5eFUwY3VYMXlQT0RMTFk5cElrWmtzQ0N3Yk0rVlFabTRQTEtHVGhoVUFqSEd3VGJXQ2hEWkJQdkJ5RURGYWVmVXNUNVNPQk5cclxuICBVcDQ0WEQ3YWFaZ21KeWRwZG5hVzcyUnhkMXUwbitKUTE5RENsZlJPNnR4NERUdVVOMVBmM2p0a2RoZW1HYnNXQ3NZbGRIVmRsKzZGXHJcbiAgUmxvbUNlNllHZHUyZWdmMTdYa3ROWGV2SWxxYVlTZDNtRVpPN0pkeUF2SC9vcDhDV0Y0YUVvWkRHVXpQOW5HUkFreWZrUVp4WG8rWlxyXG4gIGMxazgrT0NUUnIyQ0dDdHJnZGd4OWllQUhIeURwNzJSc3pLbWtwNVJwSS96MXdRR0pWUmRiaFBVZVJ0STFNSjBFaG5OZ0M2M2Z4ZUpcclxuICBQQzQ5VTRGaFJCb2hFeVhEN0wxWTl1WklEb25Td0R6TG9RcWFqSjJ3a1d4cGlSb2FHMlZSUmNrL1VpbHlBaE9wUENwVkJFdGpVUW9uXHJcbiAgREFyaGVLTlpPaDFDR1V3dmlRS2JoWXJEcDlBSWNDb2ZjZ0lPbDRPaS9OS0FWWGZueHNlbFJYam8zSlEvSHBjU3NKdzRLdXZPalZmVFxyXG4gIDZpdllvZXgrSGU4RDcwSS96czdra3pSMDlIUGlVSHlDZ3ZMa3crVWc1SU1ITHR2WDdlUFcwMDNVME5aQ2MxTURYSjdIYVNJN1BpSUlcclxuICAvNTErQ2hDeTVoQXpaVEE5MjdxZm4xcWJQaU1OSWlVdzZTRzk5b2srLzlpenNpelFLMGl4d2pFUVJJNklEckNuTmRZL0xwSTUwaEU1XHJcbiAgZlVSYmxKeFNtcUZCQ1UzaWhOQWpPTTVTaDQxQmJWUmlja1NTbWZFTVNlM1pTQ2VSNXEwUzN1YktaaHBSQlY0aHdraWtKWTFZdDRrQVxyXG4gIGU0UllBeXB3eW1aa0J2VGJOalR3WFcraXl0ZzZsdk53NVltMERKTzRzaWRLSndoQzRYaWpSWEk2aERLWXZqQi9oWXJEcDlBSWNDb0pcclxuICBDV05ocFNqS2c0UDlRSXRLd3pYYnUzWDhxYjZSOXV6Wko2bGZTS0ExQW9mU3UvTTJjU2l0OG1wYm9vdlBmbElDdXJyd1lGeFIyVnlJXHJcbiAgaUpLd010UTF0bEhYNXV1cFk4TmVkaXB6N055TzBzV0RuNlhKQVhZa3BkbUYvMVkvQmZCRjhnU0hNcGllYmQzUFM2MU5IMHVOM2J0clxyXG4gIEU4ZVJuSEhoNGhBOSt2bG5qSHNGRGl2cXdwSy9WUTV5ZEhBOXJiR3lrY3lSamhCUnRYcEdrcjlxMG9xWlkwZUszcGljRFdzUU9kNUhcclxuICBSak1rZFRCaVJIYVduMWVCQ2d3ajBnaVpLQm1wdmV6TGFDRXMvd0RqOVd1YVFBbUV6Y2dZbW5jTjFiUGptTEt1RTZkSmJEM3JVbVJoXHJcbiAgQnQ0dVJpb1VqamRhSEtkREtJUHBKWkd4R2JoU2Fja0tEVEloSzZnVzJYUWM3TWRZbEE5bXVSend2bk00OE5hT0RocVlhVElwNEhKNFxyXG4gIElZTytJeDBPQmM0RWc5ekEwTkdINkFJN2s0a0xSMlE2Y1JZK0I5NFVoWWdvQ09YQWVFN2ZudGRUNnlxODFHcEtXa1lYRHp6QWprUWZcclxuICBicTJjVGZqdjhjbkJwL1VFaHpLWW5tM2RUMG10VFc5NDVvRzdxTHN2UCtQcUwvL3FuNHg2QlE1Vk94RDVFK1VZUjRkZS9qd2hkSnZvXHJcbiAgT1hha0kvQUhWdFRqRytzakdsdEVYZ2JBeGtnbWhDeXhVWWtvaGRMSWFFYjRmUUFJWXlUU3ZGWENXK1N2RENQU2lDcndDaEZHSXVSbFxyXG4gIERLS2NQY0E4dmhvcEg5c0ltNUV4TkdlVzhmZldmWGpvVS9WNDcwUmlDOUxTVzRvTVdPSjJuaWlkSUFpRjg2SlVsNGZwQy9OMm92QXBcclxuICBoRXZuZHhxSGFwQkpZMldSS0E1bVVSMmNkVDVnTGJLSmlRbnFZQWVTNmw0TXhQbnpFYXl0WjJleVV4eko2aXZlQWdOMklvY3JPcE1pXHJcbiAgK0J4NUV3Y3ZEQllXVW1CU0FDWUVxQ09aWmtkeW1BWVBQMEx6MC9vZWZnbVNxYkVGQ0djRlBobTRkRWxaeW1CNmZEV0tZRHJHNUlXelxyXG4gIDFOY2JKcDRBLy9UUDk5SFFVUDRwOVpjelZ0aUY1UTQzeC9KbkdZMXRUbStrSTlqQWl3cjBxT3lDUlpFKzBJclVKcWp6TmlveE9TTEpcclxuICB6SGhHWWFzRE1MdklNbEU3UnF3eWVRcWR5VGYraFVwNHpnQjd0a0Zra3NRR1pHNC80Q3puU0RVK1BrNXpHTFN0cjZmbVpxdzh5eEM5XHJcbiAgR2tXbUJwT2tPemVZemlBY3pCeVIwYWN3bmNzM1k2WWlLNytFREp4WVFzeFVnOWllQTZlWFlzVEJ0Slhock1wQ01mWnRicFhuYjhZSFxyXG4gIEJzeUJ2TFNBTStuZGdhNHVkU1pZeXQwNWs0VTVMUFZmL1c4RHZCVnY0bUNiVElnZHlSWmFuQnVWbDVOaDN3Rm1LeGtGTmc5M3h1Q1RcclxuICBnVS9uQ1E1Rk1CM2J5ZTRRVkNFQS8zTS8rd1BHS1M0T0ROUGYvdDNIalhzRndNb0cwVjNzajdRU2FlVlpyUGVpRW4xQWtUN1FBZ2lNXHJcbiAgOVNkUmlZMUtUQzZSMFF4Sm05MjNpMWd1a1FnWTBUN05RQ2todmNMQWZDVHlaUVM4ZldRQTJ2SVBVbERHZVRKb0FSWHoxdXNkV0ZxN1xyXG4gIFJMWDFOYlN3TksrVmwrMHpaK29rZVFVakZRb1hOaGFLWURyN1RWa3pQUjc2eVNrQkowNzJnN0FjSWx0T0s3dVBnOWlVQWRxeXNFSllcclxuICBzc09IRDlzRG5EVTBzdGdlc2lzTnZLazZGS1d2SWhqZ1RIcTIzZUtkQ1Y1dmUrSFpUMGdMSlVWUkppNFVRN1M4aVlOdEpHQldtVHFTXHJcbiAgclRvK2dwbGs3TXhTQkh2TnhOZ2N3cm1FVHdLWEp0cDNNVXpIZG1MSzJIcmRiZlE5My8xdXV2NVYrMVJuYVgvNVYvOVlXcFd2UUxHaVxyXG4gIE1SQTl5RVlhc1h6bEgrbEJDNHVOMGl0ekh0QUgycDh3SWt0dFZCTEpKVEthSVRyUGdqQkdJcDh6ZzZsc0dRMWE5b3dPTWk5Q1BzWWdcclxuICB5dGtEek92WE5JRVNDSm5LbE9OdHNpOUFOVUt4VHJ1dWlLYW1KaUtOZzBseUNpZFFvVkM4MGFJSGVSNm1jMlhLbU9tUjBFOE96bDVDXHJcbiAgekN5SHlKYlR5YTVkRUgwWm9NMkdLbEdVMUFmZUlEQnp6Zll1T2Y1b0NTb1N3NUt3RWhTbHJ5TEVCOGhDMjVxZDFMZm55MmoxbGV4TVxyXG4gIG1JY2pHWGorVXdYT0pJc29FeCtLSVZyZWhFT2tqcVJueDJ0a1plTkozdGZvNmFmRXRoaVN5RElJYkJiaExNc29mUnBQY0NoQ0t2K3JcclxuICBQLy9sU0ZKRFI0NmVvdi83RDNjWi93cXFXd3VydG9IcVcxZFRqVDNWN0E1eWNlVnZNbUVqdmJkZFRnOG9YY201Q0JrMkJyVlJTU1JQXHJcbiAgOGdFYjgwWkxwSFRRTXVXWlNDcGs0Qld4TGNpRWNac0lhaCtrR2Iyd3FVdzUzbVpNY3dKbXI5cFVSL2ZmZDUrd25UMDlWTjk3dGRERlxyXG4gIDZZRlVLSndYRlNZd21LN0FSRVVsYVJOeGlVME9hb2ZWYjlIbElpKzdXbHpROTN6Z25SL3pNOG9qdUhlRllLRWplZkVWTzFPOE55UmFcclxuICBtbDMrSS80ejVkVzVkVmpuRFc4MXRMY2IxamZLTXhpSWtSWTZ2SVFLdHRoWGJ1Mm5ETm9YTDlLeFk4ZW90cWFPTm03ZVJGUDFYMXpMXHJcbiAgZ09OWTRpVlRreGVPVU92cUhkVGN2VkZmd2hXdEcxVTlsaytFcml6M2NDUzZ1b3BmWkZXRUtPL1MzWlFzR09tRnFYYmkrWHVsQlhMZ1xyXG4gIDRkOFgvdjAvOTN2MHZ2ZC9RR2hnKzdZTmRQQ1pmOVRaalM5ejFDek9QcmxVOFhXMk5iWGlQUGpzc1lwWEwrSVh4M2xvTE52Qy9BRkxcclxuICBHVFlHdFZHSnlTVXltcUVWaGpHQzFDNjJqQmhHcERIYmdMeXRaM08yZ1BFY0JVMWtJMlRFTTVUamJTcG1aQVRDcW16UDJnVjY4SUVIXHJcbiAgcUthK25ycTd1Nm1tNjhxQzlFQXFERmtVR2h0TVYyS1MvTGN4RW5HeERkYUZnbVBBeXJaWUxoM3Y2RmhjWUljeEUxNGNuazBaODZEalxyXG4gIDZxQm9MMDVmWElKeUpGTVIyREdJazJsa0o4T09wcVllYnpwc2xCZFF5Vkx1ay8xMDhjd1ptYjY3WnZmTmx1aWxRMkVGV2lYUUVwa1pcclxuICBQY2Yvd1RnN2s1M1MvWlhMY2NVN0tFNkFmY2x6TEl5Mk5idXBwWGVyME5YdElMSXBNUzlkZTlpTGw4U0JBRk96b1VWMHc4M3Zvc2NlXHJcbiAgUDJEY0V2MzJiLzVYK3Y3dit3YmpYNzZvNlQ5MXoxTEYxOW5DZ2JTdmt6c3ZkL204cU01RG9raXZDWXp5aE5zb0xJOTRtN1dSdEo0TlxyXG4gIGNpWGpFc1YyZ0RMNWNnR3BiZnE3L0NhQzJnZHBSaTlzS2t0L3MwTjVPcWZaMURsT1R6NytPTFcwdFZGdmJ5OU5OV2JmS0pmbTRmK0dcclxuICBiTjRKVEZkZ2t2ejJMREo1NDcwYUM3TVRzdHc1QXQ0dU9EODk2czNLY29JY1o2alRMNkhsd0JVNUZvMUVqTXFibXdac1VFTzF0ZlhLXHJcbiAgdzVwNXRERHd6RVI0NlZOMkw1eHpwcVdDbGc3S3FpMGR2Tm1RYVh1aklXUXNrSFJ4bWJLNXdxS3pvNHNXNnJ0a2pTVjVFVlZycnppYlxyXG4gIGYzc1VYTjhaTEdjaEZUeUg0RWhpWkZJdnY3c0l3Uml0eTdIVFQ4dVMrQzI5VzZodDdaNU1YdFZrYkRZVlRBdWRDWXNtbnI5SHlOaUJcclxuICBuRHJWVHp2M3ZKMW01M1FsNWQ2ZURqcDA4S1BVMDVQTzFIcTVvZWJNaWJ1WGxsdktYUjJJTGlUMndqa1BZUXhLcUxrWE9vRWdyVWlkXHJcbiAgbkdQOUdveVNLSmJHUm5rYnJ3TGxtVWdxWk9CVE95RDYxVGxiUU8xVGFjUUpXYVRsYlNwbVJBSlBKa2RkMEZOM2pvNGNPVUtOalkyMFxyXG4gIGV2VnFtbXh3ZDNMQlVxZ29qM0t3cmtTZDM3UEJ4SE9UdzF3UmpOTGN4RVZwVmFCU2hpcWJLcjZVb2F0djRRb1g1eDdmemRlQjVvb2ZcclxuICBENmpoUEpRdUorOElDcEFyVWs1UWlGVWRkWFQwb1g4eHJqcTRleTVFTGpTMmRkSE05QlF0NEVWVDZQNWlHUUowam5iQWIydHFYeVgwXHJcbiAgbWxYZE5GYXI5SXNLSzNNeHlwV3hCbzVrYXVBWU8rbFdlYmxVM3BrNFpQS3J1RzhITlVKTHhJM0RvRnNMejdjQTZYMXVOUm1hVFlscFxyXG4gIDFwR3NhcG1tNDA5OE5uRWd3Ri84NVQvU04zL3JUeHEzUk4vMUhWOUgvL3QzMzJmOHl4TlZPcEQxZXRIR3ptT0Z6a0ZGNWZweTV4RlhcclxuICB6cEVlVXYwcTdaRFlnSTE1b3lXS3F6Nm1Zak5qMUN4Uk1GTGJwQUxWQkVJR3FIMlFSbm9oSTU2aEhHOVRNU01qRURiWnUwRWx6Yk5IXHJcbiAgNVNHMnhiazUyckI1TTAwMzZjVUhXRkpEUGdlRnlRdlVSWHZGdU1QOHpLZ3M3NjJ0aTJGdmhaa2F1RVN6MXk5ZUE0dkY2NXJ4bWxSdVxyXG4gIFFUUzA5WmdtUmxuNUltUk1HdXBxYU03V0FSdDdWcWRkdHEvZEtJUGFXRTRFNjFKaEpnMldCWEV0RFR4MFdUOWo3MHU1UkV3dk5WRnpcclxuICBUZm8rN2FYbTFUUXpoZWNkRnJnRlVzY3RtQm0rbHZnSTFpeEoxeHpnaW84WUFjZXBvYm1kbWxzNnFLdTdsNlpiVi9vYTJSY0FoWlZ0XHJcbiAgWG9qZk1EbDR2RUtySkl0TUhvWDdTVEZ4L25tWnBZVVdKQmFaak1lZkpMblBvNHJNbkUySktaeEptUU1CdnZYYmY0cis5TTgvWXR3U1xyXG4gIFBmVEEvNkdiYjNiaml5OC9WT0ZBNnFRRmdzRkZqNmh5ZDFHb1ZJUXhWS2ZYN0x6UUNVQkVwcEVlVXYwcTdTT2pHWkxTczBHdVpKUXZcclxuICBxRWp0bUZ5WkJMRnRYRGEvaWFDMlFaclJDNXZLZkk2SnVEaGRSc3BJMDlhTlAwY1hMMTZVZDRGczNyYU5KdXEzdXFTR2ZBNktOSjhZXHJcbiAgYnErb2RQRXFWM25yM3NTZ3hNN2N4YmcraFdZSFVkL0VyWWlHWm1yczJpQmRTZlV0bmQ2dUdKVzFVRit6c1VHV1NELzkvSDRUL3R0aFxyXG4gIHVoYUR5ZndMK1NScGJXcGxoelNSY3h6VkFGbmdPTTNXdEtpWFhaeGxnWGsraG9nc2xpTlN4dzZxdFp1ZFhTTjFzdE50Ym0yaGRldldcclxuICAwY0V6ZzlCR0tLa2RYd2dVWnExQ3RCWVE0RVRnVEtwREpzT1NvazhObnFEeGN3ZUZqbHNqTVNTcFQxK1NrWWZwQzh6R243dGI0aUlIXHJcbiAgQXV6YSszWTZmQVRMMWkvUjltMGJwU3NMTnlNdlIxVGxRQm82UWhlV25NcHlOdHRGTHF6UnloaXEwNmNWZGFvUEtpOWtxSTFLVEM2UlxyXG4gIDBReEo2ZGtnZDA0b3RpeXl5enVQMkE1a3dyaE5CTFVQMGtndlpNUXpsT050SWs1dGxFMzJiREJKUnRFd2VZak9uY1VLcmR3a1g3T0dcclxuICBsam94bngzSTU2QW96Z2RZbXArVHdXM015c0ZnTnNZRllPWk0zVFZZdzA2aW9ibFRYblBhd0JWZExkNnQ0TThiMXBmdFdsQ3V2R3BEXHJcbiAgSFowN2QwNENMbFMwSkFiWk9kYlcxMVBqL0NSTmM4VUtPZGFja2xZRzV1bHo3ZHhNNGMxL1paam02cm1tWHNkUUd1ZFc3Z1Jpek5lMVxyXG4gIDB6d2ZxenAya3R6ZW9PWkZONFczTWhiNEJxMnprNDhYLzRiQndVRlorcjJWdzlqb0FMZGVKdGlMNENFL0JZNFNqcmVycnByYStsaFlcclxuICBSNzNyZDlEOHdxSWNBNHg1TlRZMzBhbUx1Z1lXSEZWbExHdXdQS0lzSmk0YzhvNGticEZVdDVmSXFpQUI4dFhaV2pYVXMvM1ZWTTh0XHJcbiAgdFNLa3YzbTVQWnZlb3Azcm0raUorLzZsMUlGZ1BHVDdyaS9uNDYzbjE0Ly8yTGZSTC8zaWZ4YjY1WVlWT2hBK0crVTZ0NHRkV0tPVlxyXG4gIE1WU24vemR6SG1ZVHJCaEpiYWEwbWlWV0RPWWprYzlGallVTVVOc2d6ZWlGeldwNW16RkxCSjdNbEY5UW5yWjU1Z2lkT2Ftcm9LNWFcclxuICB1NVlkaUw2b0tJK2lQTGd5bkJ5V1B1aTU2Vkcrc0xRZkg1VVdyakdFMnZwbXF1T1dSQ05YWU9JczJIbGd6Q0xBTWkzTzNsQ3MyYk42XHJcbiAgVWFiQTRobUtFYTVRRzF0YVpFVmh2Tjk5YVdHQjZoc2IyYUZ4WmMvL1ZUUHBPbC9UVkwrc3c2anZYRWRkbTYvaVpEVTB2MVJqbFF3R1xyXG4gIDNHdUk2MTZxNCtJdnNzeFZQclUxUzFMQ2hhWGw3eTZiYWhmcHpMT2ZwUVU0VjNac0dNVHYyMzJiYVM4Zit6WjAwY2p3QlJxNmVJNlBcclxuICB5ekFOWGpodG1uQVU1ZjlwN0tUbWxsWmF4S0I5SGQ5Rjh6SHM3dXVUbHNyZzVQSy9Jdzg3R0plQWlmTndKRWVrdGRDMmVoZEwwcnlxXHJcbiAgeXpteU1oSTNNSU5ISHBDSkROb2FnWk1xemsya1hsVnNFNkQ2UFJ0YjZmTjMvMU9wQXdIKzRjT2ZwSGYrKytBMFhxNWRXU3R3SUc1RlxyXG4gIFZ6dGRPUXBWbWpDRzZ2VEZnL0dBcFFvYmhkbkgyNnpOWlkxM21GMksyRGJLbzRKdGtFWjZJU09lb1J4dkUzRnFvMnhjZG9kc09pQVZcclxuICBkQ3llcE9OSCtFNk5mOWo2alJ0cHRnVVhjSXcwRDh5R21yeDRqQlptSi9uQ3pMUXcyREhJZTdzN1ZsTmorMnA5YTF2aElMYWxTTFBPXHJcbiAgb0ZoenphWUdPbjM2dEhTNzRlbHRqRk5nbnYzc2xJNUwxUE1kdVRnTlJrdDd1N1EwWnRnRzJUVVR0empRZ3VqYlJtMDlxNmkycVl2bVxyXG4gIDhDSjRSbjN0RXMwYlhSblYyRlRHK2YzM3FoZGlEOVRWM1UxTkc2NHp6WXVIcGNFalZNOS94Ym5UaC9tWWFQZVgreVdJRjJ0YnFZN3ZcclxuICAwaGRxR3FRbENzQVJiOWl3Z1ZwYlcrbmllQTAxTnRUUzdCdzZ5MWFLNVNwa3hmVHdHWm9jUEVHTnJUMVM0WWN4akRUOThybEZGa3k2XHJcbiAgMWdpNlNMdTIzQkROYkN2T1NhUmVWV3dEakIrOEsza09wQXcvOWI3ZnBwLy9SYlhadUdFTkhUMzBzWmZkc3lGVk9wRDFIRmtMUkdUNFxyXG4gIFJxZXBJeDNCbFpZWEZlZ3Z4WGtvbDhwaXJOeDVSRkt6QzRqdFFDYU0yMFJnaTBSVWJxOFVieU9UREdOc3NsZEROaDJRQ2l3cGRkZWNcclxuICBwY1BQUDgvWHlSSnQzYkdEeHV0MG1lODREK2MwNXFlR2hZZFk3bEhaWWRRMnRWRWozN0UzdHZmSjdLZkswQXd6ZjBtRVlzV092ams2XHJcbiAgZXZnSVRiR1RjSVBiWEF1cUVzMkEybHA1bjhrY094UzBRdEE5ZzNXOTFtN2FTUk1McmR3eVVMTUZiazJVN0tJRUt6SXVSaVlMYnNSUVxyXG4gIC8xUDNjRXVzZ1ZzeGk3VHZpaXRvY0VrcmJPQUYyR05Wd0l1bE1JRUJGVFphamdEK1UreS9vWTFiaXR4eVhCenRGem5Rc080S1BvYmNcclxuICAwdUkvRDExb1RkMVk4UEJ5VUY0eHowMk5TS3RXbHFCZnMxdGFhU2xDMnZKY0hOUUNremVHamo1SUN6TVRVV3NrUm5GT09HOFVlWDIxXHJcbiAgRGdUNDZuZitJSDNrSDNYYTd6ZC80MWZTbi8zSkx3cjlja0YxRHFRVHM3RE1zL0taR0tvMllReEc4SW5vUlFYNmxUa1AxU3ZuWkl3b1xyXG4gIEQwbmwyZGhHTjdGbFlDS3AyUVhFZGlDTnlka0JhaHVra1Y3SWlHZWtlVGxrMHdCeHVZR2lkRUFRQ0JVMjFFV242Y2podzh6VzBKVlhcclxuICBYa25ucGxkeDNUd25nOTdUdzZkbEVCeUFOVUl0TzRuR3pyWFN5cWhuNTZIUXZJcGhPbzZLcllxbFY2d25tVjZNbGdhV21WK0VGNERUXHJcbiAgd0I5aE1jWTJGdG1oOUsxYVJlMW9iYkJKSzdjdWhqQ1p5YUU0K3dKVWJaaEhhZEtnY0ZSSDdRZ2RlLzRwbXArZHA1YU9EdXJjZEtOcFxyXG4gIFhqcWdxMmVLLyt2WjhRRU9lTVdzbGhkdXBiV2xuU3YwY1hVdVJiK3pZeGZkY3N1dGRLRC9vdkxGOVhDVlNCTmpQRzNpM1BNeVJidHRcclxuICBUZFF5VHN6U05KVjN2NlN0a1F0SHFLVm5zN3pVcWhqNVhFVGl4VXFzeElFQVczZThoVTZjVktmOGYvN3lWK2cvdlB2TGhYNDVvRW9IXHJcbiAgc2tISFFQaEVDMVdiTUFZaitFejBvZ0o5bWZNb3JxUlZyNXpKSkRLYUllazhHK1R1aWdpcVNHZFNGY1Z5Z0hrdmluNUxCZHNnamZSQ1xyXG4gIFpqVzhqVXd5akxIeDhYUElwZ09Dd0pLNWpVZnIzREU2ZWZ3NE5mSWQreHF1aU0rY3ZVaUxjMU5pSmFHdWdlOUkrL2lPYzZOMEFlQmhcclxuICB2SkJGbWxjSzAzRlViRlVzWGQ4eUxPTWFvOFBjMm5HM2YvZ1Q0RFBZWWVEY1dKeWZwMTR1SzU1YjZlbnBvU05EMGZzemlyTXRRTldHXHJcbiAgQVlWSlZGaHRicE5uSHBVVzFNTE1IRjF4M1hVME9KOS9yL1pMamRteEN6UTllbzVtUnM3SW5ic0RuQWhDWFlVZjIza1ZLc1Y4QlZ3a1xyXG4gIFdoNmFhSFppU043djNzUTNMWWtqY1VqeURrelpMdkV3NnZDeFIyUmFkdnZhZmRUU1c5YWF5dWNnRWhQM05VK1VUdU10d3BrejUybkxcclxuICA5cmZRQXQ4QTFYTXIrZmlSajlPR0RhSDErYVdNNmgxSUhWL2svbkxpMko5c1JuQUZFTTYvdkg1NTU1SFhxOFRwL1VZZzZUeWIyc1JXXHJcbiAgRWNOUVJuY1ZLMUs3T0FjbDg3WkJFdW1FakhoRytIMGFLZkpwMGxRQVMzTENJTEJrYnBOZ25wdnpNeGYyMHpTNmhBeFNTVFRpb2EvMVxyXG4gIDNOSllJK3M4ZWZnczhua0ZxQzc1bXp6SzAyMW9IZUVMN0F4ZE9IZU9MMUMrUXZrQ1ExY0p6Z2QwU2MxT1Rzc2cvNW8xYTZTMWNXeWtcclxuICBxRnlWVUpWUlFNNWNCU3ZNSllkenozeFNmaHR4eTJudGxXODI2YVdnbXBLVVZhSFZBOTJYcytNWHBVdkpPUlBzV1diUmNVc1VGZnJlXHJcbiAgTmF2bzBPR2pOSGppZnRFNzdMNzltK2o4OE1Xb0ZKbnlyTEI0ZU1ZRGprUm1iUlU1RWlESnMzVFBBbTJONExrVTY5S3FXSjY4c3JkcFxyXG4gIFpRNEUrTVFuSDZBN3YveTlRbDkxNVU1Nitva1BDLzJsanVvY1NOY0d2dWpkNEJDZlp2NGNOMEpFVHBqWHYvVE9JNUthWFVCc0I5S1lcclxuICBuQjJndGtFYTZZWE1hbmdibVdRWVkrTXlPMlRUQVVFUURsZVFZZkFiWFZNelkrZDFtUTJHMCs3WXZadUdsdkFzVDJhQXJ5Q2ZGQ2JuXHJcbiAgcU5paUpCMkxtOGNQMDhtVDZJZG52aFlEdFkyRXNlejVhY3llSW01aDlOS0d6WnZvd2h5ZXZJN3lLY2t5UlZWR0JXWXFxREoxMWRpeFxyXG4gIGVvNCtlKzk5Vk5QY0pNL2RyTjE3aDJsV2lKVVVyR0tsdUJ6U3hBdXpVM3p1bkpKWlV6RmF1amZJcElrbWpoMWFPZTJGd1FHYVAvdXdcclxuICA4RmpCRjY4TEdCalh5UTRoNTB3QnF5aXZ6dG82Vk5tUkFFbGV4WHVjSERoT0UvTGNTSTJzTk93SDJFdkxFUlJqQno2NW9pNHNody84XHJcbiAgN2dmcCszN3dGNFQrbnZlK2l6N3d2MzVLNkM5bFZPVkFHcnMyYWhlVzhPNHN0NWlqVUFVS1kxRGlpOGQ1Uk9semRvRGFCcWxSRWdVcFxyXG4gIG9CeHZFM0hFQ0JtWDF5R2JCZ2dDUytZMnREQTNJOTBSTTZQOXNqNFRBQTI2cEhwN1d1bGNQOS8xYzl2ajVsdHVvYU1qcmFJWCtDdzlcclxuICBrWUhKT1NxMktKYnU0NG9VNHk1bnpwN2x1MXFzWUZ0TGRSem11Vkoxd0RNS1c3ZHRvOVBUVVJkUFdURThsalZRNU15S2p2SGxvRGkzXHJcbiAgTlkwWGFQOVQrL2svbUtNYlgvMXFPalhSYVpvdllKUlVwREp1TXNpVjcvbm4vYS9GbUVrSFYrZ3RxN2I3ZW1CelR4MDlmWC94SzE1M1xyXG4gIDNmb1ZkR0VzZEpIcHJqSTdMSzNJWTBleWl4M0pNZzhrSnZrRXhsRmpaN2dsempkV3VVVWdTL2UvSkE0RVdFa0x4T0g3ZnVEbjZRTy9cclxuICA5emRDLytXZi9YZjZqOS93RlVKL3FTSnhJT2pteUlFZFNMMXpJQysxODhqYSt5aXVLSmp5VENSTjBnS3BYWm9rdGxXN0lJbDBRa1k4XHJcbiAgUTNKS1JLbGUyYmk4Z0hFbDZTeUpiTERZSC9xeThXUXVsZ3h4S3Z4MzlhMDkxTEptTjlVMXRkR20xaUY2NXBsbmFINXVrVzY0NFFZNlxyXG4gIFBtWXZOQktFdkZPWW5LTzhSVWthRmwrNWVwNmVmLzU1R1JqSDlGb2NhMWtpaEFObVYrRVpqbzBiTjlMbXpadHAvemwzSTZKUk9aWTFcclxuICBLRERKSHRkTFJVa3VKZUw2MFFOMCt0UVpybWtYYWUzVmw5Tjk5UVVFcm1EbkpnWm9kbUpRbkFrZzR5VE5uWHhEdVo0cjQvQWtlRWZEXHJcbiAgSEoxNlhDdmRJbHozbHErblkyZDBwaCtnZFhlbUJpK28wT0ZJMEwyRjVVdnFtL0RBWUdtdHIvRHFZQWZLZFdrMTkyeW1qdlh4ODFCbVxyXG4gIGw4bjJxbTF0OUxtUGZmaVNIQWh3NTl1K2l6NXgxMmVGUG5Ia0UzemVyeFA2U3hFNUI1Sy9KdXVvRGc3RWQzK1lCVWZoY2hYR29NUVhcclxuICBpdlBRWk1FaXRRRVpNN0Vkb0xaQkd0djZqVUFwM2tZbUNTTmtVUVdYVFFNRWdTc1NGaVJFZjdXYmNndEExZGpTVGMycnRvbnpjREpzXHJcbiAgcjlsRTlPaWpqOUxFK0JSZGYvMzFkR3dNTTZ0eU96S1luS084UlVrYUU4LzNQMFpUVXpNMGJjOXJ4RUFMQkU0RHp4d2NRUXVvSkt1QVxyXG4gIFpRMHlKa1hIY3lVb1NiMkNUTGQyak5GRG45WEtBbE40Vis5OW85QXJ3K1g4aWt6dDl5Smg4dHp6TkRNNVJQUGpmSlBBUE9vS1dXNmRcclxuICBXd2w2YldvNTFyVFgwUE1QZmxUb0lsejV4bmZTNmZQcHVhSXBvOStSK1VsWXdnUXJCYVRkV3N2OGJxOVdBdTl3dVhqd1hqN1VOZXlRXHJcbiAgYm90bUdnSm1iTkhZZ1U5SWZLa09CTmkwOVUxMCtzeDUycloxb3p3ZjhxV0s2aHhJOXlacnVwcVdvM0RwQ21OUTRzVnpIa0htYkx3a1xyXG4gIG15ZTJaaFBBZE1TRzh2aE5CTFVOVXFNa0NsSkE4a2xGakVoZ2FiS3A0a2dSR0ZCWVBod1BZU0VzTFlaeERjeWZ4OTBVSEVlTWVBODNcclxuICBiRytnKysrL255WW5wdW5HRzIrazQrTWRwb2xoOWh5RmxBNTVpWURGMTIycGxZSHhJMGVPMGJUMWZjTlpvTnNLNk9qc3BDMWJ0dEQ2XHJcbiAgOWV2cHlkT1laaVhpRWxSVUtoS1Q3SEZjQ1RJcEx6MGpqOW4rejlNUXQ3d3drK3pxcTYrbTgvTnJUZk9Gam1VcTRCSmd3QjEzODJnZFxyXG4gIDRQQWhOSGF0aytkSE1Kc3FZSWxHOW9lVmpXdFc3NldsQzdxV1ZZenI3dmdhT25ZdUxOV2lwWXJLWmlTZVZ4by9oNEYyZEd0bHgwY3FcclxuICAvSlpFcGROOUVlRDg4aSt0VXVPeFp5L2ZnZlQzWDZUMW0zRXpVVXZmOUIvZlFYLytwMSthejRmQVoxUUp1OW80Q3Bld01BWWxYa2puXHJcbiAgZ1RURnpnTzB5NUczMlR5eGxTZ2o5NnprN0VpM0NlREVTSzlTYkUwdmtkRU0xZkEyaUJncURhVHVLekVCRjVrcGxNRVdyWXlSazQvUlxyXG4gIDBKSFBTbjgwbkFma2FHMTBicjZCdW5lL0xuRWVSWHVZbmNYVDNPamlDbjNSQWJEbGdLOUdFVXlYaFlrNzVrL1FQZmZjUjgvc2Y1YW1cclxuICBKemgvenFEV0h2QmJ6eTJObTI2K21WbzIzVXdYbHRiU2syZktuSWZiUjZFeVZmdmo1ejdWSXNsRVExYTBZcVFaN0YwMVR5TWpJL0RvXHJcbiAgc3NUS1NweEhtdE1MRTFhR29oemlVQXlzUUlEM2M2eTU1dTNVdnY0S3F1OVlRek1qL1RSeS9HRzY4TXkvMGlTNnV5UjVtb2R6SG50ZlxyXG4gIDh3NmE3OWxLMDAzYXJmUEUzZjhnam1iYldoM2sxcjFILzdhZG9LMnJ0OUdhcTk4bU51ZjNmMHk2MWdJMGxZWU1FbFdOT3FEVk82VmJcclxuICBidUxjY3hCR1NQT1l4SlR6UzhTNmRhdm8zay8rTVZPTDlCZC85VkVaWVA5U1JKVXRrTTAyQm9LdnN4REdvTVFMN1R5Y09DS1lEQ1VRXHJcbiAgZVlHTjdpYndXYnVJZEJ1RDJnVkpwQk15cStGdFpKSXdRc1psQll3clNJTTd1NW5oMHpRMWZNclBvZ0pxNnhwMU5neTNBbXZyMDFsVVxyXG4gIDJkd0ZJcXFoSzlmTjBxYys5V201cVhyMXJiZlM0YUdvQzR1amZNcXl2SUFhdW5GSEUrM2Z2MTlhSGd1enV2NlVZS21XZXZ2NmFPZk9cclxuICBuZHJLS2NnbW9JSXlVUlgrc21XUVNiSHlEQ0pVbVhqZ2FUcDM5alNiMTFCRFV4UDE3WHE5S1M0Ukt5bHpoWnZ1YW5GcFdlUlRMVXlQXHJcbiAgc2VNNFRGTWpaNFJIUGRMS2QvaHpGM1RzeEtIcnFyZEx2SzVyZ1U2Y09FVVRFMk0wT3pwS3pRdHBSYjN2OXJmSk1pdUh6NVIzZGNtTVxyXG4gIE1TYkxaMnRWK0hXbXVuRGdMbG1XQjRzeXhuV1Rld1hBNE1CbnFLWGo4aVpFL1A0Zi9DMjk5M3QvbnFrYSt0ejlmMDZ2ZnZXMXF2Z1NcclxuICB3ZktENkZ5QjFWZnhITWlMN2p4TTc4V2dzamFNRjhkNXhIYlFKSWFNVks5c1hGWWdtd2Fva1lGd1BFRTdONWt1eVkzNStKZzVVcyt0XHJcbiAgRGtGdUZ6bUIyd2pnUUI1NDRBRjV1QnRkV0VkSCtFSmdkU1lWSXk4Sm9ocGEwNkJyVTUwOGVWTFhwY0xUWm5pZWd6TnU3K3Fpdlh1dlxyXG4gIG9KT0YzV01PQmZuSGlQYTFqR1VCb2hRclQ4eW9QbEdSNVlXRDk4cExvL0JjeTYzc3BJOE1WVFBPVXkyS01xcFFLYTRFVldhenNyMHRcclxuICAwZUxjTkUwUG5xUnhtOEdGZ0RvRnAwelgxZW84RXZBT3RxeXBvYk5uejlMUTBKQytvMlVReTZTbjZKS0hHRk9nYkxMcTc3bm5TN3ExXHJcbiAgWXBUL0VwM3hkWmk2dDk1TWpXMDlZdWtjeU9WMFljWDRzUi8vZGZxMTMvZ0xhbTlycHJPbjdxYjI5bWhHNUJjNWFzK2RHNUNaTXdDMlxyXG4gIFNVRHJvNTJiNVhpWmxEK2hPWGFrRVpmdlBCQTdpVmN5bkY0M1hnd3FhOFBRY2dSZThqVVdxYjBtYXdkYXYwbzduWkJHRzlMeUFSRmpcclxuICA5c20rQlBrMFdLOW81UGdqRXJ6ejRPT05wUmd3eU5lNTVRWjFIcEtucW9GYzdsNGZ5Umk0R0RFTENrdUNURXhNeElmQzRCTUdlSkVTXHJcbiAgelZOSGFQOVRUOGw3TitBODBNL2Yxc1l0R1Q1Zk9ycTdxWFhqTFJXY1IwSCtEazdsajFYeWl5ckFKOVFRczFVaFRsQ2NLR3ZoZ2tja1xyXG4gIGxKWVlId3U4dE92SXNITWVrY0ZsaFNJVTJWMUNLQkFsd1ZDa1FpaEdEZUhkOEszU3ZmVU8ycjduYXFtTTBZRTZ4d1FxK2h3NHN4TVhcclxuICBsbWl1ZmgyMXI3cUNycnZ1T3FwZHM0Mm1HN3BvdXFXUHBodjE1cWxwL2h6dDJZalhFd2VnSE8zc09OWmV6YzZGbWJHeit5c1VEb3BpXHJcbiAgSlJ3UHVyU0dqejhzanNSWjRUbVFTWFJQdmdENDFWLytFWHJYMTkxSjR4TXo5S1k3djhPa1h4cW8rOGovdS90bnpwOGZMUGJSZUJzaFxyXG4gIGx1cTJ1ZDhDWDZGcXJHd2tNOUpYQ2Q0ZVVMMUs4bnBKNDFtbjEwMXNGUmdsc0UyZEdDT2JyeEtKWE1GYUZxazAwZ2taZUZCcCtZQ0lcclxuICBFVEl1SndCN0JHTVoweVA5TkhibWFWMU93cnFxc0JRNjdxTGExMS9KZDBHOWZOalJWWldtQTVuTlhWblZaTkc0TUVqbnpwMFh1cld0XHJcbiAgaFM5Uzk5eEZnYjBYS1hIMXhscTZjUElaZWY4R0JzZDlseFgvbHU3dUh0cXhjeGZOdHUxV1dRS1hrV1NXSWxIaGwrUitUUW1paEJFcFxyXG4gIG9TS3l4dmtFcFJaRkNoZU13T3lyMDJkTzg4MnRYam50YTNFOHhPQ0xBUEVQS2dnRkloOGlNaU5PY09IQVo2VGxzVUNOMU5qVVFOT2pcclxuICA1MlhjQVVjTEMzVG13TFlqazNpL3lXcTY2c3B0VkY5WFR5UG5MOUJDYXhlTlhMaEFKMDZlNGdyK0JIVzMxZEppUTlxdGhGY0tZRjJ0XHJcbiAgQzg5K1V2SnBiTzh0THBRdmJhckVOZGZVdFo1R1R6MGgvTklrdDRicUd1bnI3OWhIdlJ0Zm1MZEIvdnV2ZXd2OTFWLy9NejMxOUJHNlxyXG4gIGNHR0EzdkgyTHpQTkZ6ZFF2ZVY4aHhmd0hYRlR6eFlkL3hEZUhYaU5sWTFrUnZxcXdkc0RxbGRKWGk5cFBPdjB1b210QXFORVdnWWdcclxuICB0Z0ZwVElsZGtFUTZJYk1hM25wUjBBbUV6VmFJd1I0dEFidy9lbnBJMzJMbVVOZlV3UlhQSGpuNUEwSTZoMnpPeW1aa0hpcGYxM2lXXHJcbiAgbm41cVB6VTFOOG8wMnZIR2dncmZaNkhFdHE1eE9uWHFqS3pwaFBkd2VQQkI3dVFXeDQ0ZE8rak1sSFdwSlNnckN5UGFSd1dyRENMTFxyXG4gIDZoTXh5bzFMTlN0WENHcUducGF1RjdSQVZxOWRTM1dyWDJXYUwyWGtxZ3BGUnJ4dlF5Tjk3dVAvSUhUanFxM1VzdTVxbXBFbnc1L2pcclxuICBGdkdzOUc1Z2pFU2Riam0ycjY3bENuZS90Z1F3VVdIYVptczFOVkZuZTRmTTlMc3dHMC9ISmVrK201OGFwYTZ0V016U0NsWlNiRVdxXHJcbiAgSEQ3K0tNMk5YNlFtL3Z1ZnZ2OFBhT2N0dDVybThqRTZPazZyMXI2UjV1Ym42RS8vNkdmcFBkLzg3MHp6eFF2VXY3bkQ2d1cxN0VDNlxyXG4gIHpZSDR5bDdqdE9MbTJNaFFZVHNkb0hxVjVQV1N4ck5PcjV2WUtqQktwR1VBWWh1UXhwVFlCVW1rRXpMV0pJYU12RzJpZGh4SGNCeTRcclxuICBhR2JIOEVSNFFFTnJMN1h4eFpPc1J4V2xjOGptSE5pTTNJUGwrcVcxRGVwQUdocnJaYW1KdXRVM3FZbURaQkh5MmRRMkxLdmt5cXdpXHJcbiAgWUdHSjhBNk8rdm9HV3J0dUhmV3UyMDZuaDNEcHh3anBFeVRpM0s4b1FXUlZYUUpHdVdHaHBucGhSV3p0R0tXSEhucEkvbCtzZlhYTFxyXG4gIGJiZlJpZkV1MDc0Y2tWWWhqVk9uNk1UaFE3VHVxamZRampVMWRPUzg2ckdkdm5pVUp2b1A4ckZiaUJ6Skh0TVdvNzUyRVg2YUdtYk9cclxuICAwY2tUeDJsSjNndFRRMTI5dmRUYzFpclRwNTgrb1EvVkFsaE04Znl6ZDNHcmZvZE0xMDN5THQxTlVBenMvMWZwZXZ2NEIzK0IzdksxXHJcbiAgWDZYQ0Z3aFBQdmtjWFhmanU1bGFvdWVlK1FqdDNyMVZGVitrUUN2elo0ek9BMTFZelYwY3VaY0g2Y1YyK2M3RGIzanJsWXhVNzhXZ1xyXG4gIE1qYVZuUWZTR2xOaUZ5UkdJWkpNWXczVGdXVkVqSkJ4R1FHejV6RE9GOGxFL3pQK2FYR2dnWnZLWFp1dnArYnVEWmwxcVVJNmgyek9cclxuICB5bWFNUEZqR1pVZnhuYmFqZm9MT256dFBkWFc2bEVoVHQwMzdsU3hrSTJ4WDh6dzFUcCtVMlZWNDBSQXFSSFRMdFBWdW9OV3JlbW4xXHJcbiAgbGl0b2JLbUh4cWJkQmViU2F2b0VYb3pTdTA4bHVBUWNJckl5aWcxanFkZFVMMXdST2h1bTVPVlhjcXo0V0M1MFgyV2FJbVQzOTFLRVxyXG4gIEZ4dnAvdnBQSHBCbmdpYndicExtVGI0SWlCcndVcWsxdTZpV2o5djh4QUNIUVdrMTRPeHFiTStzaTJaWXhOc2pXYjVRMzBGdGZadG9cclxuICAwOXBPT2FkSEJnWm9ZbUtTamg0OFFBMkxrMVRmcnMraDRNMlk3YndQVFBXZEdUNUx6WjFyT2JXVno2SThuSUxMZGZFUWRheGVUMy93XHJcbiAgNXgraDFwWm11djMyNjhYaWhjRGF0WDIwYmVzRytzai91NWMrK0RmL1FqLzJvOTlpbWk5T1ZPRkF1amtLRTN5bDd2SC9BTWVPWkNLb1xyXG4gIFVyMXlKcFBJU2J5U2tlcTlHRlRHSmkwRGtOcEVwTnNZMUM1SWpKSW9sYVpsQXlKR3lMaU1nTnJqRFdsanA1OUtIQWNHdzd1MzNVVE5cclxuICBYWGl2U3Z3bVArU2c2UnlRYTVLem1TUkdIcXJFOFVpMU5leEF4dWpjdVF1MHVMRElGMThEdGZieG5VNG1uMDNkODNUZzhjOXdxMk9JXHJcbiAgWm1kbkpKOGx0cTl2YnFGMVcvYlJUTU1hbXA1M2MvT1FMdDJMaDFmbFNsOENTK0RTVlV3UUc2V0dPV2tzRUdGV0lNTExSdFBpSUYyOFxyXG4gIGVFR21YcmQzZFZOakYxN1dWYlF2QkVPUjZzVU9Ia1hLYkhoaHNHZDl2VTcxNXB1UXpxNHV2bW5Dc3VhY2YyWjNlSlVBQnR4eGRzR0pcclxuICA0RDAxZUlZRTZnYnZTRnhJTVUwdDh2eko2dlo2bWg0OFFmVTE4L0orbTdtcFllcHBYcUpkbTd2cDR2aVNqSTFnV1I5TTF3WHcvbmc5XHJcbiAgT3prVVp5Mll1WENJNWlmSDZiZi8rL2ZTRC8zRWI0dlpHMTUvc3lwZkFMenFWWHZGQVg3czQ1K2xSeDU1bXI3aDZ3dG1xSDJSQUxWWlxyXG4gIDFRN2tTOGQ1WUdzNmlZeG1lTDBYZ1RCR1NPd2pMaU5RUXpPaloybjA1R1B5VGdLSCtwWXU2dHo4S3BsWmxiNHZIT0Fjb3F5QmJLN0tcclxuICBab3c4V0ladm9ncTI3WFdqM0FMUkJUTHhncVkyZGlENmhtL0ZxcnArT25ia09acVptWklWWlBFZ1hHdGJHMjNadW8yYVZsOURzMHZ1XHJcbiAgOWFBaHp3Uk96TUVka1FLckNFa0NEYVdJYkNQRVVxOVpYbkNaaVBQVE1IVG1XWnJDUTVTTUhidDIwM1J0VjVGWkdsNEtGSldqS0FpS1xyXG4gIEZDNVVqMU5IbnBLdXZYaytQajNiYnpFcGtNblB5SVoyZGlScjFKSEFpYURWTU1XT0JJQk9rVWxybUcvc3BCdXYyazFUYzBzME9UWklcclxuICBTN09UZEhGd2hNNzI5OU91amQyMFkzMG5uWjlBYTJTMzVJc0FwNkk1MlJsYmtEVWNDUERyUC91ZDlCUHYvMkY2MTlmL0tNM1B6YitnXHJcbiAgVHVTT045NUNCdzRjcFgvNHlMMXk4L2FtTzE2NHNaWi9TK0N3bGZZSzZoaklWc0k2V0xtSzI5ZGNWbkVrZW83MXE3U1BuTVFyR2FuZVxyXG4gIGkwRmxiS3AzSHJFTndMckl6a1BJd0tmbEF2SzJpWm81VE1FZE8vc01IOFV3UGdESDBkcTdUVjRobXNuUXdMSWs2NHlOWjh2VDVqV3BcclxuICBaRzNES1hyNnFXZlpLVFR4VFVBbmRheG5wN0JRVDFkdFdLREJ3VUZkaG1SNm1pOE1MSytPS1pqTnRHN0hMVFJQc2VNb2dCZm5TbDBDXHJcbiAgczZyS09HK1VreXd2dUVSVXlDZFN0Yzhjb2tQMnF1RDZ4a1phdGZkTFpQSEVNcFRYRG95OHN2L3BlMldRRysrRWIxa2RMMXhZQ1NHZlxyXG4gIHFYUFArU20va0tLVmduR1NQUEw3M3RRd1NQc2YrNXpRMDBzTjFORGNMRy9qN0ovdEZSbW02WTV6L3F2MzNTR3YxWTJodWVsMmRMK3VcclxuICBYUlUvQjNMZERWOUxWMSsxaS83cUwzN1pKQzhNZHUvN0tqcDArQVQ5L1lkK2pkNzVOVjk4NXhJdWpmdy80U0FPWkpzK1JCaFh5cDYyXHJcbiAgU2lSc05OYXYwajV5RXE5a3BIb3ZCcFd4MFYwR2k5Z21xY3JpY2dwWTYwV3huZDhJMG5JQmVkdFlMZTkzNWpzVnZJZkRBZlBnMi9odVxyXG4gIHFsRWNCNUJreUdBK0kwcHpaUWliVFFlb0xQZnppbXhadEs3aExEMzExTk5pandmZCt2cjZxS3Vuajg2Y09rVlRNek8wT0x0QXRZME5cclxuICA4Z3pEdW8wYlpScngyQ3ljUjBGK2dCZm5TbHlBeUdKWjQ3eEJUcks4NEJLUXp3T3ZXblhMNHBmdVkvU1FPR0M4REt1aG9ZRzZkcjZlXHJcbiAgajNIZTl2SktXQ2wxK2VXNkhDNDlaUUVLTXR1MmFwRWVldWhoV3B5Y29IVlhYOHFpa3NDU2RBMk9uMzJXWmdlT3k1R29hZXVsN3UyM1xyXG4gIHluRXUvZzFCdW1hcG41N2YvM25qMUpIZy9JWWoyWDhXa2lVYU92NG9OYlIwU3Nza0MrUTBhbXQ0WlI4ay9KWnYrMGw2N1BFRDlNVG5cclxuICAvOTRrbDQrUmtUSHFYb1Vwdll0MDl1UmRzZ1RLRnhQdy81U2ZWK1pBa2lVMC9NVmlGVW5ZYUt4ZnBYM2tKRjdKU1BWZURDcGpvN3NNXHJcbiAgRnJHTlQ1bXpZWERDSUlsMG1RcytMUmNRMityR1NmQzJ2NG56ejlFQ1Z6WU9tS1dHOVlHYU1JaG45bm13TEJJcm1STXdJcGtIeS9TYlxyXG4gIFFVYmkyUnJhMG5LQkhuMzBNZUd3VGhYNlhHVTJIZDg1eXhPLzdGU2FXMXE0MVhFdGpTOWlxZXg4N29Jb3p4S0xDR2F4ckdHeFFTSXRcclxuICBaNVlGSHRMVWhSM3hJT1VjelUrUE1WMGo4LzFuSndZNDVvdTBKcHoyRGEzb3BvM0hwc3B4N3BsL2xTNi9SajUyMTExM1BaMmE3S0dGXHJcbiAgdVNrK0wreEdndmM3eS90SGx5VW1UZUN0ZjNqdUFlOGx4L0hIdnByd25NSkxpdVdxNFV0REgxb0FqejhweDNiZEZjNkJYSHF1dU5iR1xyXG4gIHVYVy9PSHBPWmtYaFZRVTZZNnRTcnFwWlhYdVJEajM1a05BeHJyanVWam96MzB2amZBM2pIT2xZdDljMEFXNFJ5S0luMFgvMi9SK2dcclxuICAzL3J0djZJekorL202eXB0eFZ3cUhuamdjYnI5OWQ5S08zZHNvRU1ILzlta1h4ekFsVm4rWC9CRjFkeXpYVm9nQ2phWGE5a3FrN0JSXHJcbiAgK0FyYlpCbDl1Rk5MOVpHRlZ6bmkwcHlIMmdTSlVSSmxwYndOSWtiRVJBNW9ZVzVhV2h4NEZhZ0hWeEl0ZmR0MGpFTjR2NGxnZkNTT1xyXG4gIGY3R2dNQjJnc295L1l4U2xCNEo4Uzh1QUxPZU9ZNjRPWkZFY0J3QisxNjVkZEg1cFBYTzV6QlZSbmlVV0VjeGlXY084UVNJcFozSkFcclxuICBoWXgzbzJDWmUxcEM5WUlId3JUUFhHZnpaTEJzMmZMSUp0bTdlcG8rL2VsUDg3a3dSODJ0cmRTejgxTHZzb2xtMkxITWp1TlpHejYrXHJcbiAgN016aGNCWVgyREd4cy9sQ2RERFZ1SUc2aVNOMCtzZ1JKdXBvM1pWOGJBb1RWWk5UQ2d5dVQvWWZsR20vK0U5YTErMlRwOGNkaW5OY1xyXG4gIG9wR25kVm41OWpWYjZPSzVjOVJjbzYzTEs2KzlsVTR2OU1yYk80ZVBQMEtyOXJ5QjZockRsUHBLRGdTQUUvbVpuL3RkT24vbVBscTlcclxuICArb1g1cjM3bkEzOUQzLytmZm9uZTgwM3ZvRC85WTZ5ZDljV0I1UWZSVzNya0JKZS96cTRvcVZLRU5nSGdLMXR2NURhQ0wzem5BY0lZXHJcbiAgSVhVUHVLaXg1czRrMzdGZ3JSK0hwdTZOMUxueFdyMTdoU0JzSWpBUFVTU09mM0hRUlRJUGx1R2JxTUJrYklYTnl6dnFKdWo4ZVgwU1xyXG4gIEhhMlBoUVVkbzJucldrVWJ0Mnlud1Jxc2hwckpDL0Jab2FSSmFRdGd4ajVORVp3eUdPUWs1WXc0Q3R6Uno0eWNGWWNoL3dIdTdsczZcclxuICA1WjBPYUZXZzBvWFR3TUo0Q0FLWERZZkZ4WGtacTVMWC9vNzA4NTNuSExjZ0orVEJUdVFQUUlkVlpWR3A0RUUwZEdVdElNeE8rVERVXHJcbiAgZjVqR2h0d05CTHBhTU1OdFNkSzZWd3BqQUJuMDFPQkpzUUpkNzhvVUFiSW1jUlpjZHZ5R3RoNmg2N2tpZzNPWmtqV2hzRllhOGpvdFxyXG4gIEwxU3E5VGR5THphaWcyZkJuUXR4aUxHbWVVUldMcGlkbktSVkd6WlFiWXUxeG5NSmNvSmw0V1pzb2RWZnc2M0pCVGhmanB0NzlGVzdcclxuICB4VG55amRPYVBSSnEyOVpRVDhzaWpZN1BVTzNTTEYwNGQ0cTYwVnZidlVXNnNVWk9QY0hIZWNMZmdMaEI5UC8yVTk4cmNSWVlUTWUrXHJcbiAgM3ZIdnZvL2VmTWV0dEdVTGJzUXVEN2ZjZkRWZHVEQkVmL2pISDZhMWEzcm81cHV1TnMwWE5uQWN5bThKdU1uZDNJTXhrQWIvNy9ncVxyXG4gIEphN1pyTEtOak54RzhNWGhQQXhDNmg3dzFqOHNweDREVXd3eFh1QUc0ZkxsZEdCWkpJNS9yYUJTT214enFxTDBRQ29IZDhNV291ZWZcclxuICBQMHhIang2Vlk0KzNBalkyTnRPcVZhdG96Y2J0ZEdZeWZYcFhFT1dYMlZNQnpLS2lZVjZaU0FvWVZPWjRVaGxkVHFFMVViRHNoU0JrXHJcbiAgZ0c0aXh5SVBwRUUvdW5aTDFlVHlTSFl0eUV1S01Iam9icHJoQ2hJdmpzTFQvUXRkMTVpbU9taXJZMEFtVjdndU0xZmVwcUpXVXdZelxyXG4gIGJEczdQc1QyM1JKM3JDc1lYRjc1RGY1bFFuYzRmdlp4bXNIWUdqdlZWVHR1RTlteXlKVjErY0xqZUdIU1NzM1VDT0ZGeVhnZ0Y5M0hcclxuICBnaWg1VVU1OWRJNmVlL1lBMVMrTTAvUlNFelUyMU5PcmIzczFQVGZVVE9NMmNJL25SNVpyZ1RqOHYzKzhoLzdkTzMrUS92YUR2MDVmXHJcbiAgOTdWM212VHljTXR0MzBnUFAvSVVQZkhvaCtqYWEvUGRhMTlvd0pWVC9xODVCMkpqSUtIaWppODRwdVhyZEg0anlEa1BnR1dSUmFSU1xyXG4gIFFwTUVpOWltYkQvT0praU1raWdqelpiZndXenh5bGgwVitHSlZvZTZ4alo1L3dGaXdFemRKZ09XUmVKY2xieE11bFJUWUNlaXZCeVNcclxuICBQYjNqZE9MRUNSb2NIS2J4OFhHcXI2K1hGc2p1M1h0cHBESDdBaDJENVZld3B3ek1vcUpocXN5WmVnRWZaMVNJRXdPRXBWeXdiSDI1XHJcbiAgczFEQUhpM0MrZWtSY2VEMXplMVV4M2ZtZFEzcFFudFo1SXRiSTExZmNGWU8yb3FZa3RZQVdqaEZHRHp5V2RicCswOWU5YXBYMGVGK1xyXG4gIGJzbHd1dG9HTFl0RE5jNmdDT29nTUdiQzZmbXF4RjJ4UEw5VENMMXN4L29Qc3YxcW4yNUYzVi9sVi82S3NLMW5tajU3MzMxOGQ5VWdcclxuICA3NFNocmxEeFZiMkxuR0hsbEs1YkM2amxsbWozenR2RFdHMG1hY3p1VzcxSVR6L3hKRTF3cXc2WXFXbWs5ZXZYMHRYWHZZb2UrUHp6XHJcbiAgMG5Kc21KdVF4UlFQUFB6N1lsTUpqejMyTE4xd3k3dm8xMzc1UitoSGZ2aUZlU2l3cWZWbWFtbHBvT0dCQjB6eWhRdGNXK1gvRkJ4SVxyXG4gIHI3VkEyRlF1eEd6bHExK2xKUXA2U2VIWm9JOHRzbnBOSGl4aUc1K3l4Q1pJakpJb2xpWkdqSWhoRXQwYTQvMEhhSEV1dklmQURaREhcclxuICBUOG5LTm13aU1KOFJ4Yjgya05sMEFGdm14TG5NREtuY2NmdFdUY3E3eWRGMXRiQ3d4SzJPUnBxZG5aVjNLN1J2TDFpOHpSSW1aU3lFXHJcbiAgTnl4QlhwRklqRkdITVNoUDRpL096WlE2akhtdWxCZTVNb2R6d1pQTEdCL3c0eHFsWlZCSWEwU2dEZ3JkcjNENjhiVE5TNm5nYTRZZVxyXG4gIGx4bHM4aWZ4WGZiNjY3N1NOT1ZBaXdOQU9YejVHYTZ5YjZ4eThGNWJMcG9HY2R1cUhmeDczSFRyRkZORForUjR6YkdUYmVwWXl3NnhcclxuICBhTzJ5eXBXem9Bb1RoK2FaWTNUMG9GYm1OOTUyRzUyWnlMNURJMlJXVmJZNW8rSlVPRTlHano2RUF5UVdUWHlkNXBaRktTYXBkLzRNXHJcbiAgSFQyZ2sweW1sMnFwczdlUHRtM2JSdWZtVnRPNXB6NUttM2RkU1J2WGR0QmRIL2sxYXUwcU9vWUJrNU5UMU5aMUMvM01UMzBQdmUrblxyXG4gIGk3dTlWb0xISGp2QVR1ay8wRHUrL0hiNnAvLzNPeWI5d2dRdXgrSi9CL0FPcEZHdjI3RFJXTDlLUytSMGtIZ2xJK2hqaTZ6K3BYSWVcclxuICBpNHR6ZkVkemlPYTR3b3JSMUxVaGVzK0Eyc3MyYkNJd0g0bVV6QW9pM3NNc2M2cU1vQ0M5NDI3ZVhtZXRqa0Zaam1Sc1RCOXl3MkE1XHJcbiAgdWhVd2hiZDJiYlFXbGlWOHNSMEhIQUFxU1BlcTJ6S0hnUXBXeGh1NElrRFhWVnpaQ2pLN2NVNUNCNkZEdm5uSGtDK2ZWT29tZHBVeVxyXG4gIG9ETzM1c1haeUJwbG1hU0RSL1g1QWxwWXBPYTJObXBkZjUxMGsyRzhCTE90QkV1TDRpQmx2TUphUmRWMVRXblhWblBYT200VnpVbStcclxuICB6WjE0Z3JzY1NETS96UzFNYnZrc3pFeHlTd1ZQdytlQkZncFdRSmdlT1ZmYzVWV0k4aXFoU0RYVi94amZMZk8xczdSRTY2OStpMG5MXHJcbiAgRURLb3NKZUFuRkUrMWNTRkl6U0YyVnBNNDBhaGIrOGJvNGsvWmg4bGMyUWZuYVVqVDRjcHYwdXRuYlIyN1ZvNmYvUjVhdXJ1bFp1dlxyXG4gIC9YZjlGbTIvTVg0Z3NoeTFEZGZRKzE0Z0ovSjcvL3R2Nlh1Ky8rZm9GMy91QitpLy9wZnZOT2tYSG5DWjVQOFJCM0VnMjduSjdzWkFcclxuICAzRlhGc1g2VmxzanBJUEZLUnFyMzI0eitwWEllMDBNWTV6aGhuQUxyZjhsaWh6TDRHZVVqWkpLUmdXV1JPRmN4TDVNdTFXVHNQRnRzXHJcbiAgZGUyR1JYcnV1UU4waXUrTzhXd0NXaDE0UUJBdEVIUWZ0clMwVUc4dlh3eGRWeWQ1WmZhU2dXbExqZklLSjVGV3hpU2UrTVhnZG5IbFxyXG4gIEtUYUZYVmRSdmthaWtzY1VXUXllT3p2a1cxUzBtZWdHSUhZT0RsVzFQSW95WnVIWkovNlJMNGQ2THNjY1hYSDExVFJjdjhOMHl3TjNcclxuICB5cWprWFptd2pEOWE5WTV2NnVCeUZWeUZydVVocjJDOWNGaHRTNXd3TU1hdFowd2xueG0vd001aW4wa0RGcmpWTnptQWMzMVIrdnFyXHJcbiAgbmJvY2tDOWtWOTBJSFhqeUVYa2pJOGJhMXU1WjZWc1pRNTdsRlpFaE1jaGJEeDY4bDJxc05kTG9XeU1PWmg4bGMyVE54Y2RwdUYrN1xyXG4gIHRPQkVhaVpIK2NaeEE0ME1EZEwzditkdDlEOCs4SE9pV3c2WVFMRnA2NXZvdTc3ajYxNFFKL0xlNy9rNSt2MC8vQkI5K3A0L285ZStcclxuICA5Z2FUZm1FQnZiMjVmMEx2Rnhuc1FGcllnZWdZaUx1eU9OYXYwajV5RXE5a3BIcG40Y1NPZUNtY0I2Ymp5dnNKb241d0FHOEJiTzdlXHJcbiAgYUZ5VWo1QkpSZ2FXUmVLa2F2WmtjVHJOTTBaR0lHd3FDMXdOWGIrMWhwNTRqRS8rNFVGMkdyTlVYMThyclE2Y3lITnpmSGM4ejNmVVxyXG4gIDdGUjI3OTVORjJ0MXZhYmNMaE9ZdHRTb3VDeXAwMEFGbDlwQkw3T2EyQWswdEhTWmpVT3doVlBCM1RkYUE3REpPZ0JZemt4bzYyTnhcclxuICBmbGJHTERBTERyaWtjUWZPY0diTWRYa3A4SUFvdXFnazMyZ3NaUERRWjJSMTRubHUwVjE1emRWMGFxaEd5b0E3M1FiMzFrZ0duR0pkXHJcbiAgdzhxZkQwQTVZcWNIdW5YVmRzMHJjNFhDVWNCQnVGaVJHdUVjR0QrSDhSSE5yK2o0alBVL0wwNFJyVDdNYXJzVXRNOGVwK2VmMSs2clxyXG4gIG0yKyttVTVOOHJISTFTalZJaVJjTm92RUlEQjQwaHhQczBPQzdzK2VYYmVyd2lOS0dKRTdlaWJwODUrK3h6ZysvdHdLeFlPaTMvMzFcclxuICBiNlF6UTFQMG9RLyt1bW1XeDc2cnZwSysvdDFmL29JNGtXdXYvMXA2OXRrak5EUDVxRHk3OVlXR0dyNEh5ZjBWem9HZy94OHRrSnE0XHJcbiAgdjVWclBiM2s3Y0tYeUVrNE5uRlc3eXljMkJHWDd6d2l1WkNCVDhzRDRLTG51N0R6ejBsRkFaWDc4VmgrcEdQRDFkRmRtU2FVYmRoRVxyXG4gIFlENGo4dVVGQ3RNQW1pN1ZaT3c4VzJaVlExdmJSK2pjK2JNMFBqcEc0K09qTXZ0bHpabzF0R0hqSmhxYTQ3dW84Uk95cUIzZTdZSDNcclxuICBlRXkwVnByUllUbG5paEdRTDRlMkl0aHB0RHVuQVFRNzE4clFMcW1pdStZd2lDNVRvZm00WngzR0xEc0x2TXhzZXZTY3owTWUxbHdHXHJcbiAgMGsxbFFFV3NBKzRkeklYeXlWMi9SK2tQRjJ4dU9VOFBmZmF6OG53RDMyYlRtKzY4azU0NUh5L0Zud2U2N2ZEYkFPOFlzTndOT3lYSFxyXG4gIHAyVW9CbXpoWERCdU5EMThKcVNMcmxyM2U5RUZpR1ZyWkNKQWVsblQ1TVZqMU1qcHBvWk9GYlpPNEV6UVltMWJ6ZGY3Q2xvbVk4Y2ZcclxuICBvUEdSRVhtd3NtLzNHMWlTN2xkUUlGb2VJVkhGNUlreU1CZWUvaGVxNDVzUjFHWE51ZFlJRUNVMDhtcStiengwNkJBTkRBeklkWU1YXHJcbiAgcWYzaGIvNHc3YnBxbjh5MkdoN2djNkJLWEhYdFY4dGJDQy9YaWFBN2V0WGExOUhyWG5zamZlSmZmMS8rb3k4a2VBZFM2TnY0NHEzdlxyXG4gIDJ5SE5iY0ZsT1ErRy8vRWFYNzd6QUl5U0tKWW1Sb3dhbVpJN1BYVFNpOTBwMUxwNk4xK2c4Vnh1dFpCdDJFUmdQaElwbVJWRXZBZkxcclxuICA5QnNoWXlkc21VVU5YYmVwUnQ3YmdSbFc4OXg2R2gwZTRWWkhvMDNSM1VsSGg5VFpOOVhOMDRYbjdwZnVySFhyMXRIU3FxSWxxUzNuXHJcbiAgVEJFQ1VzV2NjeHBvYVhUa1d4SExPWTNnZE9BRUZyVlNOZUJaamZtcFliRUp6c0xwOHdWMGxTYkdJREJvWEdjdjVVcnV0S3Y4WFE0eVxyXG4gIE00dHZNSElZZVk0R0wxeGdCMUlyWFlUdEcvR3lvZ0E4d3lGUCtWOEMwTnJDell3OHc5TFFMQlc4T29seVI0bGpPTU5PRlRPMEpnZU9cclxuICBVOGQ2VzNPS1d4MkFPelp3UGtVdEZEeFBBNGVDV1dobHpnVDJIZXV5bFc2S2x2b0ZPckgvUHBybmM2eUc3OWJYWFZrMC9oSDI2MUVnXHJcbiAgcWd4TnNHeXl4QUF0c09kb21nUCtiVGdSUDkwM1FaVEl5TDFyNXFSTEdDOE1XeHdiOHRONU1jYng5Qk1mcGl1dkRBOHhWc0xlSzcrS1xyXG4gIHZ1RS92TzJ5bmNpRER6NUZ0NzcyUDlKUC9lUjMwZnQvNXZ0TitvV0J4SUhrTGl1K0tPcThBMkd0Zk0xS29wQWlOMTNYOU40aXEyZWtcclxuICAzcFRwWUt4azJCalVKa2lNa2lpV0prYXkxTE43R3hwK3AydGhvWW5idnU0Sy9uM3h4YThKUTVaUlJnTG1JMUgwQ3hXRmFRQzJ6SW1YXHJcbiAgVHh1NEd0cmRPeVhPQSs4NHgvUmNxbG1rbWFscGJtRnNvM09MbTgyT3dZbGEySUdjZk9wdTZjckFHRWo5K3V4QW9PV2M3aTZDS2pDb1xyXG4gIE8zWHhhSEFLM2w2SnlrNERyWXlMcGwrbERzUFN6OCtPeTdpR2N4alE1WXVpRWxTSVN3dnpNbVVXTFVVYzh5SUhGV2VBMzQyOEFhenlcclxuICBpa29Ud0g2a0JSRGQvZGZXTmZHNVVQNUNxUFA3UHlyNW9Rc0J6My9NZFY5bm1oUnpreU44dk5RQllSKzBoSEt1a2pmY3VmMXFhNnUrXHJcbiAgb29Od21CbTdRRmlmQzJud0lDVmVqbFQyTU9IWTJXZXBwWGV6VEVNTkRrVXY3ckgrWjZsOXpWN083NXdNcUN0Q3hZbXVNUEJaWjRKSlxyXG4gIEJUT2pGMmx1ZW94MStRSDRoYkhUTklZQjdMRXhXcnR4STlXdUtqNHVLY0orQlJsMmVXaUNpc2tpSmNhRFJvNThqbkRVTUNtL1ovZnJcclxuICBwQnUxR0piUW9xMmRZL1RNc3dkbzA0WlY5RHUvK2dQMHhqZS9sdDc0cG0rbDczN3Z1K25kNzNxYkdpMkRIYnZmVHUvNXBxKzRiQ2Z5XHJcbiAgaDMvMDkvU2QzLzErK3FzLy8wWDZocTkvaDBsZmVsVHBRUGl1bHBXcU42dW9OcXplZVFCS0wrczhnQUtiSURGS29sZ2FqS1R5TzM5SVxyXG4gICt1ZngrL0JENWNmeUhTc2VCbXpxWEJjblpTZ2oyN0NKd0h3a2lrcXFLRXVEYlNJdVNnZWtja3NwMjdYMTUyU1dGVm9lNks2Q0E2bXBcclxuICBYYUk5dTNiVGtUSHJnN2ZrS0pjNGtLZnZGanVNaXpSdmZvMHFnMUVKVklIS0Y2MkNsczYxd2dmNzBQVlU1RFNjRGxOSTBXMGtkK2FXXHJcbiAgRmwxU3NjTUFzc1hBc3hBQUtuMDhnVnhwYkFOaklQT3pFMUl4QTVLblphZ1ZkRGIzUzhQWnh6N01MWVJHT2U3WFhYZGQ0cXpESGxhK1xyXG4gIEx6aUlXYTdnM0xFUXg4WjBKZWVpYVp4RHVoQ2NSUVp3S05DTm5kSFlBZWt4Y3dzdGtBNitlUUx3TkwzRDFQQnBlWkF6MjNJWjYzOU9cclxuICBuQmZlOHVkdzl2R1BjYXNNdjN1UjFsL3o1U3BjRWNKK0JSbTJNb0p4eFdTc3hMamF4TmxuYUdiZ21QeEwrUUgyTEN4SGpyWjFUMUovXHJcbiAgZnovMUgzcVdQdklQdjBWM3Z1TU8rdW1mK1YvY0dLMnQyaWxzMlB3V2V1OTNmczFsTzVFZisvRmZwLy81MjM5Tmp6M3lvYXBiUVM4MlxyXG4gIE1Fd29Sd3U5bnJsTFFCeklUaGxFVjUxWlJMVmhYR0hIK3RnaXEvKzNjQjZ6Zk1jMnlYZk8rSGtRK1ZZSFYwcDZKNmRPTVVBWjJZWk5cclxuICBCT1lqVWZ3TGxjemFBNW9tMVdUc2hDMnpZSXEvR3hvdjB2SGp4K1c0WVdvaFpydHM1RHUrbmJ1MjAyTnVBcG5sNDlJMjFTM1J3S0ZQXHJcbiAgMDlUVWxBeWs5KzYxN29XUWVRYXFRTE1manNIUDlqRjdkUXpvdmlwM0dxcXpDaDlsNVlvT0RxUzJzVm1uNkRvZHd4VURyUXVrYiszYlxyXG4gIExuZmJaUTVEN2RSUkFGTFJkbVlyMnVJZlZ5UmRXdVFXQ3BjWndNMEZLdVBhaGxaNUtBMzJDTkQzTkU3SXNYZDF5dFp0MjJoa3ZwTmJcclxuICBRdXEwSWNhZCtyeXRrZFpnWXpTMWpkeXFzVzYxR0piTnNwZzRmMWk2MDlSUlZIWXMzbGxJbk8rU2dxT2RIdTJYRmwvc1RCYm41NlFMXHJcbiAgRGZrSHVaWndacFFkRys5dm1xK2owR3BSWU5wc1YvMFVuVHgrakEvVWtvNS83TG5EdEplS3pKR3A5a0FKMUxoaUVsYWlwVFZ0N3hwcFxyXG4gIFdiMVRIZ3d1UjVRYms4TlAvek5kY2RPTjlPWXZ1NTdlL0xwcjZiT1BQaXVxYXAxQ2U5ZHI2TWQrNUJzdjI0bTg4VTNmVGs4K2RaQUdcclxuICB6dDl2a3BjV3VFN2tTTVh6ckR6Z1FGYnQ1TW8yMGtxa2RGeGhCMzFjdGViMTZoZWNNTlVIMGxNTXRRa1NveVNLcFdxRWh3QW4rRVJCXHJcbiAgZDRmVHdubWdHMDZYV3NjQW85b0dLSk9XTFVacUgvOUNKY3ZUcEpxTW5iQkZGaWJqYUV2cnNMdytGZDFXVFUxTjRnendYTWVGSlYwSFxyXG4gIEtKaW0rUUIxZzAvSVFEcXc5cHF5dDU2NUZzVWczNVh0RHJrWWdXNFozTUZsblFhbTFrNFBueXAwR3I2VmtSa2tScGJPWVdCcUt2citcclxuICBpd2JGWWFOUGhrLzZ2SDNsbWZ1WjJWOWVJM2ZacnF0eVh1N3c4YVEyMzNselhNdkdEUlh1OExOWU92OHdYYmlBcnFRWnZoNXFhZU9yXHJcbiAgdnRvMEJjaVZqWThmbHdWWEdNcUVDaGtYRzhvR0h1WFEzeFVxcTBEbElhMFB5WWVkeWxoYzZhZFl6cUZBbm5WSStEOXhVNFdaaVZsblxyXG4gIE1uWVdYVnprV3lXUU5vMGRvT05Iai9HNU1VZGJkKzZrMlk1S2xmRktrVGtLbFE1S2dtQllsZ1RQemd3ZXZFZTZ0TEMwNktwOWIrTFdcclxuICBaYVVKRVZGT1RNS1JBUC92STc5TkR6ejhqTkRWT29YYWhodnBmVC8xN1pmbFJDWW1wcWk5K3paNjUxZS9nZjcrYjMvVHBDOGRjTXJMXHJcbiAgRVNweklQWHNRS1FMQ3hBRHRYSVZ0c0lJMHpzTEozWkVyb0tPSElXdkJoTG53V0ErdGdwUkxHV2F2OVBjUkozaEpqaUFpMVRYYU9XN1xyXG4gIDFjNTExTHBxQjk4Tld6dkxKNDN5RURMd2l0aFdFWmRHeVd3YWdLMXk0bXc2SURWU3ptUWNyYTA3SjArVm85V0I3cE8ydGpiYXZuMDdcclxuICBQVDhVTFJqSW16U1hnTDdGNC9UY2M3b3dYTjhWMlpmVnFPTkFkd1ptS2NWNTRNNWJXeFFZdDRnZGh6b0l0RnZWRVl0STh2Rk9BeFYrXHJcbiAgcGtDcXQ3dG81MndpbzdoMWthM1lCR3lhWmdrbmNWSC9ZeXl3eUdXdGJlMWg1MXBmNEJ3eWhha0M4UkU5L2RqL3BTYSt3OFlhV0MzdFxyXG4gIDdkeVNlNnRwTGdkcDlRWW5nenQrbEgybHptWHN6RFBpbU9CWWROcHZmbGtYdEJqUW1sSEhrT1pTNUV6R3poNWtaN0dYc0d4TUdITUpcclxuICA2ZEFxd1g3bjJLbldOVFRRNXMwYmFXaW1sZmR2NzkwWEZKWDJVcERKcCtwczFiRElITWRpOU9RVHREQjZUdjdwNWJ1MEFNdUpvODFkXHJcbiAgVTV6SkZMMzMzVjlHaDArZWsvT2pXcWRRMDNBVHZmOTkzMEUvOWQrKzJ5UXJ4d2YvNW1QMDlkLzRYK2lQLytCOTlLM2Y4alVtZldtQVxyXG4gIDR5ZEhwdHlCN0pLN2QxV3FoYXV3RlVhWTNsazRzU055RlhSVXcvb0x0c0FtdGdwUkxNV0twZU0weVJmQ2dnMlNBM0FlY0h6dGZOY1VcclxuICBCczA0blU4YTVaSEpVeEhiT2pJcmlIaUJXU1hpakUxQnVzQXh4ZDlYYlNaNjd1QWhtVUdGSmRoSFJrWm8xYW8xZFBYVlY5T1RaL2p2XHJcbiAgc2dUeDBVbWg4dFUxcCtudzRhTXlCdEs0TVR5Smp0bEdHSlJHaFIvbjRMcDB4QWw0V0t0Q0hFcHdFTWdEcTllV09RMElGckJ5S2wrc1xyXG4gIFdhY0JoNEhuY0xSbGszY1lZaFUyVXFGaWFaUEYyUW1xWjF2OHg4RlI1SFpjQVpHdGtVRlNuTS9wUi85T3ArOHUxVkJIWnlkMTdscEJcclxuICBWMDFTZXlYTU1naTI0MXhSbzF2TU9jdG1OeVpsTnRsY1k0ZFMxRUp4RGdPenZ1cWIwbFdDb1FQaWRCaERBV0xaMnZxejlOakREL0gxXHJcbiAgVlVlZFBhdXBiWE0wUWNNS2xQKzFlY25La2NtanFpelZxTWgwOVBSVE5ITlJ4MFZhMklFVXo5TEt3bkxpcUczbUJQWDJOTk9YM2JxSFxyXG4gIEJvYkc2VS8rYVBsbDJNZkhKNm1qNTNYMFYzLysvc3NhRFArcXIvNUIrc2Qvdm85T0gvOEViZGhRZWRXQ0Z4TTRkbkpFY0orUnU0VFlcclxuICBnVFI0QnhKZGFwNjJXS0tvT3N2bzh4VTAwOFplcnZPWUhqcE9NME5ZK2xwYkhlaTJRR2pxWEcrdER1ZFNPSjFQR3VXUnlWTVIyNExNXHJcbiAgNkN1a1NhVVpHMkdMTEV6RzBSVnJacVRMNmx6L0JabjFnM1dzMFBMWXRXc1BmZjRFTjdvdGp6U1hHQ0d2MW9sRE1nQ0lHVVJkdTE0blxyXG4gIHoxUFUxalpJcFc4bWdzbkJFN28wZXFhaXg0Ti9mdXpDak9GTVpMa1BlVXFmNFRKaDRJNFZBclFFVW5DTHdWb1pwUTVEd0JSLzVZNmNcclxuICBiUnM2VnBtendBVVM3YWdRcHE5Z0ZsUXhsVW1RWWM4ODhXRytZOFh2cXFYZGUvZlNWUHRWcXFnYTVSV1loMWRXdFBJWVA3T2ZuY29hXHJcbiAgUGs3bjViVUM4UXl5TkljbDcxQUE3UzRNRm5BWW1MbUZGbWgyZGhkYWpWamEzamtPaktOZ2lSZE1UR2tZTzBCblRwNWd4MXBQTGEwZFxyXG4gIFZOUGN4eTJXdFBMRk9iYzRQODBtTFFXL3FycmZXUmxSSGxWbHAwWlpVeXp2UDNyc1lUblA2dms4Njk3K2FxYXF5VkJ0cmx5OVFQTnpcclxuICA0M1RUbGV2bzRhY08wNmZ1L1hPUlY4SXp6eHlocTY3N09yci8zaitpMjI4dm1sNWZIZW9hcjZkcnJ0bEpqK01tNXlVQ0xwZlNveVVQXHJcbiAgRXJJRGlSZHVrd3RPTGpLNzBvdzJqa2xIYVh4SnpnTWF6NWJZTEM3U3hObW5wWUp6TGtKYkhRM3l3cG5HNk9sZ1NaZk5qL0dGNWp4V1xyXG4gIDFaeVNRVyswUElZR1I4UnhZSUczazFPOWtWbWFSMERJeDZGMjRHbnR2NStib1d1dXY0WE96d2ZITWNzdEFKa0I1QWZGSWMyME5td01cclxuICBRMlRTUldWVGNRSGJEd1poOFNwZmRKMUV1eGJFcTh2R1RpUFlLVFhINVlCZFBlOVA3WnhGTmtlQVpRVmlGUlhaUjVDa3NDbXh5NGczXHJcbiAgTnB5aWh4NTZTTjVBeUNjV2JicnBhMDJ6RXRqbFZVV2RWR2dpd2txSmw4VGh5bzNUNkhtcTc5bHNUNVZybWpnbG5FbkhoaXM1M3MrT1xyXG4gIDRVcVRLckJFT3FZTFo2ZjV3c20wOW0xTHhnbjZuL3hubVh3MXoxZmVUYmZmU2FkSDBEVmNYRWFNclVtWEo1N3NCOWdzYjFtY3RqcEVcclxuICBhYXZLUm8xaVU1eDdZOGNmbzFwMmVCZ1hRWGV2ckllMmJJWkJYek8wbjFxYWFxaTd2WWtlZmZodlRWcU8rKzc3UEwzaHpkOUJ6ejcxXHJcbiAgZDdSdlgvWEw0c1M0KzU2SDZFMTN2cGYreS8vM0h2cnZ2L0JESnYyM0JTNlowcU1rRGdUdnZyQXhFTG40L0VWbUJOZkNYbFNnTDV0eFxyXG4gIDVWTkpsTm9zNXp6bSthU2NPcWNEZTY3VkFlZlJ5SGNRclNodjhpUXRwOHZteDFpeDh5aTBCelJOcW9rNFR3WlpRaG5UUEhHQWhvZUhcclxuICBxYnU3VzVZZ21aNmFsU1ZJam81eFpXQTJTWGtTZUlNRUMyY2ZwWXNYdFZ0cTEwMTMwdGhNalQwTU9NQ3RzNjF5NTZtSjFISE04MTFtXHJcbiAgSzkrUnVud2dnM05BNnlUT0hPbWRZMENJZDF2a05JSmVLVlI0MHhPUlRYS09BSTduT0tOU05tdlBFRkZlSGlTT3NqaHZtcE1OSGZnWFxyXG4gIG1oZ2QxUzRzUHRNMjNmaE9WUlNoWWwzamxFVTdkV0Nid2p6aVNiWUdFUlFhTTVabyt0enpWTXZIZG5iNERMVnZjQzBtdFhlcEpzNGZcclxuICBvcGErclRUQnR0bXVMamdUUUoxTTJBOGVXdXlxSGFiang0NVRZMk1EemM3TVNNc2ozMVdXTHh0YUxxaFBrdnFBemZLV2VVbjFpTkl1XHJcbiAgbTQwYXhHWURCKzdCQ1N6L1V2T202L2hhd1BJLzFaUkhiYTdiWEVmam8zeHVqdy9USXc5OVNHU1Y4SzhmL3h4OXhWZjlBRjhMbjVQSlxyXG4gIE1aZUNIL3JoWDVWWDdINzIwMzlHdDk1YXpYTTRMeXh3ckVxUFVPeEFwUEx5LzcwUmZESjRVWUgrVXB5SGZaWDJrZEpvRms5ZlBFTHpcclxuICBZenI0aFFESHNjVGxSUDhscHVoYUtnTnpYaEEwTDZUenlOVjl5NlFMSEZQOHZYcjl2THpKRFUrOVlxWlZaMmVuUEx2UjA5MUhGMm1qXHJcbiAgenlQTkpZYm1Fd090QldCZHk1UXM3NDcvb1dQanRWTHh0L3V1QmlTeVFYR0dhMjFnZlNkTWYvWmpHNVk1RnVLYkdqd21NcFdIM1pZN1xyXG4gIGpWQXd0RExtMmFhZWJhUkxLcWdNTE1nY3pNSmZMYUlDdVVEbHdTUzFTOCs3NVhIeW9RK3kzNmlsK29ZR2JzVXQwT2FidnM0MEswVU5cclxuICBYMlFGbDFraUtyc01XVjZZTkNNVXRpZ1BkR1B0cDZiV1htcm9YQmRka3lFSDF6TEJZSHZicXZET0dJdzk0Zi9FUTVoNDJoOXBPbVlPXHJcbiAgMGNIOVR3dmQwTkpHcTY5NGk0eUhTYXNudC91aThwU0FUVlByRmFUTklVcTdiRFpxNE14R1RqeE9zME1uNWJFR0hWeDNTd0JWVXg2MVxyXG4gIHVXTHRPSTBOWEtDSEgvd2I0U3ZoVjM3MXora0R2L2RCT25aWVg3OTdLZGgzMVZmVHdNQWdYZWovbEVuKzdZQ3p5UitaM0hYRmQvTE5cclxuICBxM1pMRjFZNDhTeVd5RjJTdkhWcUp6RzlJdFVIbFJjeTFFWWxrZHoyaTJjRXBzNGRCQ0d0RGhRYXpxTyt0WWRhK1UvR1ZPTW9GY05uXHJcbiAgeGdpYXRGd09zUzNJaEhHYkROZ3FFV2RzQ3RJcFp6S0xtc2FmbFJZSDF0NkJBOEd5SXp0MzdxUm5MK2hzbXFRc0NkSjhBRXhSZE04T1xyXG4gIEFGMnp4K2pFaWVNeVdOMkRlZnBpcXdtY2s4bDJVN1d1M2lISFV1MWNsOVpGbVl6Z0FFM3FOTlRSYU02NlJkZld3dnlVNktHUmNUUkFcclxuICAxUXdtSWpwTzY1RWU0QWdtajlUeGNWSXFWdWJ0SzBNTlQzLytiL25PbWM4eVRsL0g1ZDl3ZlZFTEpLNVlsdG1CbU1iMkFTcU5kSjRzXHJcbiAgdHVkYTNRaUhqRXNSSnA5MjRzelQxTmk1bGhZWGw3eXpqOVBDbVFCd0tQRStYS3VrWVdGWUpuVXN6RXpUdHAyN2RKWG5CSndtdDl0OFxyXG4gIE9iUkxOSjBhN3BITElwKytPa1RwbHMxQ0RiQkY2Mno4N0xOU3orQlZ1bTNyMkluNDlNdGxwUHJiOTliUk0wL3ZwMy80UDc5Q2U2K3FcclxuICBQRGovcysvL0EvclVweCtpdXo3eEJ5WlpHWTRlUFUwNzlud0ZmZXQ3dm9MKytBK3JXem40aFFMT2VIOUVjcWQvRFRzUWJvR0VxWUZtXHJcbiAgSVZGMDBmdUVKakc5aDY4SW9zczhxUnlZMXEvU0RteUR1NS9wd1JNMFAzSkdOQWpTWmNWM1JCZ2tiK3JTZDN0SHFSak1lVUhRNU1vbFxyXG4gIGlHMUJKb3piWk1CV2lUaGpVNUJPT1pOeGRNT1dlanA0OENBTkRGNlFsbFZyU3p0MWRIVFFLTjRhYU9uVEhHS3dKbEo2WitESE1sUTJcclxuICAzZitrZE9kaE1MNXQrK3U4SElnZEIrQ2NqcWEzbGdtVFFjNHMvMmk4K2hOTHdMaUZBTFdVb1RCNE1oei9XVU56Wm5WWEhMQmdadW1VXHJcbiAgQ2xGa0lJaDFpdUtqRXY4ZnNaN3BZbk5EVUdiTnRqU2Rvczk5N2dILy9NZldiVHRvYVUzWnExbzFkVnExR0ZkYTN4UW9SSlNYSjY3QlxyXG4gIGsxazc1aFBSOGc1bGtwMEpXb1AxYmV6ay9RR01uQWxtWmZHNTZaekpsV3VtdVpMN09GY0xkYlE0TzBzYmJzQVUwalRQQkxsOXByYVlcclxuICBMZ3gwcksrdzBDY25TVk9sWEhXSTBpeWJYQTNHdVRVMndTMDNPSkdtM2kzVXNmbTZUTnJsTWxxU2x0blUrUVAwN01OL1JsdTJSMHNOXHJcbiAgRlFCT1pHaDRrSDd6TjM3Y0pDdkQvL3FkRDlJUC9OQXYwVDJmL0FONVovdS9GWERXK0NPUnZZZ3crTldDUVhRL2dNWVdZaFJkeHY3RVxyXG4gIDAxaFpyMlV3YmF4UGxkaW9YamtuWXpDSkpSVW1zUmhhTkQwWHpvT2EybVVOSytuRDV4MUdxUmcrTTBiUTVNc0Z4TFlnRThadE1vZ3JcclxuICBLeUJqVTVCT09kNmErS1p0amZURUUwL0lxcDlMM0k1Q2w5Vyt2VmRHZytYWjMrUmdVb3VLSEFlQWRiL3dUTUQ1Wno0cGZhdkl2MjNqXHJcbiAgcThURU9RUjFFTkh6SEt5Y241bWdhU3pteDg3Qk93NU9NenVXdGpaMFQ5Z3FwZDFUQTlURSszUXZVbEt3M3N6VVVyZEI0SGdINDMxVVxyXG4gIG9JOUVTanFCeFJKbC82TVlrYUxVaGkrS3M1K2lrOGVPQ1kwbnJkL3doanZvd0xDN1k2NlEwS0dLeWthbHZNMnBNd0poVTVtdjVyMDRcclxuICBrNlpBbjFoa1dqRGo3RXpRYmRPeVBwNWxwbW1rVmNKT2RHTlBIUjNZdjEvR2hKb2I2cW4zaXV4NlVHelArYUxGbTF1ekt5ckh3dHlrXHJcbiAgRFZJcnhzN3EwK0VkNnl1ODhJclRweVZPdWVvUXBWazJPVllxR0tUaFE1L1JWVHI0M08vWmFUY1FQdTN5WlVBZTB4ZWZwMy80NjErZ1xyXG4gIEhWdFcwYTU5NWIveHpyZjlBTjMrbWlzdStVSERONzdwTytqK3ozeWU1cWJEUzdKZWJPQks4RWNoZDFsd0JkUE1kL242SG5EVEpoVTJcclxuICBVNTVSSXR6SkFFSHZVMGtVMldUell5d3RMZERVd0hHYUd6c25qc04xV2NGNU5QWnNvUllaM0dJa2FRSG12Q0RLVmNqVU1yVUZtVEJ1XHJcbiAgRTBINTVPZGxiVExwRXNxWXE5WXUwT0hEaCtuaXhZdnl0a0NSWFhVVjlTL28vUDdzTHdvd3VVVm9DZURKY1lVS3A0Wk9VejFYNE9KUVxyXG4gIGNHd3VQTWI3dWNCa0RiMzV6VytoejUrT3hqeDh5OEs2cWRnQllJa1gzRjJxdUlabVJzNFJGcURFd0xydXdaVU4wM0oxVEFOUGVTY1BcclxuICA3MFVIS0RrWGhNUW1rb0gyYk9hWHgya0Z5c3ZXTnBGRTRkSkVJc2VnVlRRemVsNW9RSllmbVJtbmhwYWVqTDNpL05NZlkxMnpQSWVEXHJcbiAgSmR5M3ZzYTk3em9ZNDV4RVpZbXhBZ2Z3dkpIeHd4aTY1dFZxZWV1Z3BqUjRNcEl4bE9OdElrNXRZdDdiKzZqQU5oS2xEaWkxeFhIQ1xyXG4gIEZONU9ETUI3MVJMMVAvMVIrVS9ucDZmb3pXOTVDejB6b08rQnh6THpjMVBETnVnT0xNbWdPWTVWbVNQUlowNjRkUk05S1krWFhaVzlcclxuICBXVEVCNTVHV09PV1dSMlMvVEZMOERpd05qdzdZSmI2UjdvMGZ5UFZwSzJlQzZ3dExCTzI2NFUzMDBULzhadHE2STM3Z01zVnJYdmV0XHJcbiAgOUJQLzVWdm9LOTZ4MGhkemNTblllZGMyM2tEditybzMwZC84bjE4ejZZc0xYQTN5NitOcnlCMk8yc1pXYXU3ZUpHc0VDZGdvWE9iQ1xyXG4gIEdKUllzZk9BeHJOS3pFME4wZVNGdzl6cW1QUE9RNllvMWpWU0c3YzY5TDBPRERaUHF4d1JSRkJHODA4VWpOUTJ5YWZNSHR0RW5FMERcclxuICBCRmxDR2JPM2I0YWVlZVlaR2hvYWtwWUJsZ2EvOHNvcjZUaGV3c05JZjArTWtFZFJxd09EbjQzK1JVMXFDN3ZtYWJ3VDVLdzhTTmk2XHJcbiAgVVdkb1pCMEhsckRBc3VDU2xXUlhRK05uRDRoZDJ0cEF4R240amdydnVnajk1NHpvd01odmNLekVNV00wUjduZm1oemNpTTdZS2dWaFxyXG4gIFpLTkdNcWZmQVk0UEZmYkM5S2hWMmc1eE9rdmpSTWpUN3N6UFBmVXZmS2ZOWjk4Q3V1T2FxSGYzbTBUdUFBZUJjM0Z1VWwrcjY3QXdcclxuICBPKzI3Zkl0V3ZnWEFZYjlZWVZjVzlHVE1qUGFMZlZQdVZiWWhyVks4VGJLTG1FeXJRcHlFRjhXNldHNTJEbEVlVTZmM3k0T2JEVmh6XHJcbiAgak1Wbm4vd25rZU90ak82NUQrbmVzdnpTMlZ0QWxLOEJTK1BJY3l1bUNvNEVNN20wQlROKy9oQjErSnVqQ3REZFJzanZyeklpK3dwSlxyXG4gIGNWTndmdi9INVAwaS9PZFM3NVZ2RGpjSVNicnlUSEE5VGc0Y294M1h2cGIrNTAvZXlhMlJOYlI5ZC9IMFhUeXQvdEFEZjBvMzM1d2RcclxuICBYMW9lSC83SVBmUTFYL2VmNlpQLytudjBwanR1TmVtTGh4cjJyTGxEZ01lbWNGVTFyOXBPOVUzV2x5MFhtYnVVZWVzdU9pY3h2U0xWXHJcbiAgQjVVWE1sZ2UyY2pLdVJlUHlBVXBUVVlMS0ErbUpPS2RIZjVGTjZ4SUt5QVJSRkFtTFpORGFwdmtVOEUrbFVhY0o0Tk1LZU10MnJkcVxyXG4gIFZtWkVZVVZkakVuZzVVOFlNRDg2anVPYi9wcUFrQWRPUUF4RWh6Zkh3UUVNOE4zZ3FNMmNZU096d3pnRW5FTGI2SDQ2ZkpTZFMwTURcclxuICAzZkhHTytqeGM1aU9IYmRDdUdLd1hTQWQ1TUZ4aEgxajJSQXNTWTRIMFh4ckk2ckFZMXZaQkJVRHZBclNZeDBiR1MxUmJLVlVmSjRBXHJcbiAgR05oR1dlZW04U0lqZHI0c1ZpY1JVaTVnVHYva3NGem9hQ0hnblIyb29MRU1COURjWld1SkFTR1pKNDg5OENmTThLMExmemR2MjBKMVxyXG4gIEcrODBUUjdsZFVoZ3NGKzNNQ0hLR3NxUmR6SlRjR3BXa2VPSjhzNU4xekJsZW0rbWhOOW01SUxJR1ZScWNSVGFBWkc4ZWVSSk92ejhcclxuICBjMUtCdHJlM1U1YzhrYjlFbytqZVlyT1ZPQkoxR3RDejAwaFVnUms3eS90aVZPeldpaEFWbFpIdWIzbEU5aVZKMFdJZE9Qd0FONVA0XHJcbiAgbktxcHBTNTVWaVI2ODZSUFY3NXZuSWVZQ2ZtZXI3bUozdnJXMjZpbnU1TTJydXVqSGJ2RHpEZmdxYWNPMGJVM3ZJdVc1aTZ0SytxclxyXG4gIHZ2by8wVC85ODczczZKOHd5WXVIR3E1U2tsOE1CbzFQb0tsbnF3eVk2bFVWWGRqK2l0WllXYTlOOUY2YXJURDBLelJlam9NbnlybG1cclxuICA4SzBPWUpGMVRXdDJjWVhtbG05Z1NLSk1KUk1ZaHVWcWRpbFMyN1JDODVzSWFwOUtJMDdJSXEzSkxMcGk5WnlNZWVBaFFUZ1B0QWoyXHJcbiAgN05sVHRmUEFIUm5lWVIzQXJRUnVFbVA5SHBjYUo2WnpITUp6QmJ0MDhWbVpNWU5YYys3ZHU1ZE9UV25yVFJ3SHdBY0pkZ2h3R3RvNlxyXG4gIHNSeDVJd3NCTXFGUGdnTXMxTjF4WkFUZy9sdUpBcTAyanJkWUVHeWNsWUlwendUNTlPaDUrWDJ5SkFyWEZGTHBtaEtyek9JdWZ1VGtcclxuICA0MUl4QStJYzRxd0VOZkplaTRYcGNSbmp3V0tFcUN5MTFWeEQ5ZXlZOFhJcVlFUERXWHJzeWNla3BRVmNmK01OTk5RY2xvSnh3SEwzXHJcbiAgczFHM0dJQUZJaHVhOWNud3BxNjEyZzI0eUszcFd1a0U4Uzh1Q3hlZFV0UEQ1bEJZanhZbFdqSHFYRlF2VGdXd21qTHBDZ3VaTVptVlxyXG4gIHhjcEFpMTFGbThpVnNPekMvby9TN1BRMDA0dTBlL3QybXV5N1BrcG1qb1NoQSs0cTh6TzZWdUJJWkNyeDZsQ2g0dTQvckNaUkJUaWZcclxuICBzSmQwZjhzanNpOUlpcHRjbkdkejdQeHhLOXQxQlJaaVRKZURDZW1LOTcwMGNZcmUvZFo5OUZ1LzlaUENIOXgvVUpZM3VlNzZxNmkrXHJcbiAgTVR5d2ZkZmREOVBQLzhMdjB6MTNYZHJNckpxRzYrbmQvLzdOOU1HLy9sV1R2RGlvNkVBYU96Znd4WVk1KzBVWHVVcTBYZ2phb0Vma1xyXG4gIGlMd2VFaXlQTUhueHNEeE5EajUySG53VnlvQ2VkZ2RZZW9uS0toeEFtWHlaZ05RMnprWEpZdnRVR25GQ0ZtbDVHNGwzOTB6UnNXUEhcclxuICA1RGtQVkZaNHpnTXRqNEhhVFd5V3BnL1FQTkFxQUxSckNxaVJabkI5VTBkWVg0cnQ0R0JROGRRM3Rjc0t0bmlwVVB1NnZUUjM0ak0wXHJcbiAgT0RRby8ybExjd3QxeVpMdXlEczREdTJEMW5MSWxqZlRnNmY0Qkd4bXAyS093LzYvZU91TkpRcXk4SnZBT0Jwd05tWC9ueExZWXNrVlxyXG4gIDNGUmczU2V0Uk5VTzNUN2dSMDQ5d1U2RGRmeWJmWEtqVUJGRFBuemlNVXVyMElvN1dLUGZIaXhlbVF0SG9JQ2ViMXBHbjZRVHAwN1FcclxuICAwanc3RUQ0aHIzdlZxMmlvVWJzQWNTY0tSNVRIRXJWMGI2QXA1QXVPblk4K080Rjl3NkdGeXd4THhPQjlKL2hqVUs3Z1BOUUJpcVZ0XHJcbiAgVUU2MG9yQmZJUDVOK0kxZG0xOUZJNGkzWUVrTTIwZkl3RWlUT3oyd3JETkpaYWNlK1hzY0xDNzhBbTI4Nld0cDZqU2VCZUh6YWlQR1xyXG4gIFNid2hPNUw5RW11TGhNRTZqRzFneVJUM3o0Y1dpajZBaU9PUC8wSEFXUVhIb3VNak9sdXJodm5xV2lPQ3VQZ1JWUjNNdmlUWjBQRkhcclxuICBhVzc0dEN6LzFMSHZEbnZRTm9KUGw4L2d0VGZ2cEtzM3pBb2RENVkvOEtrSGFXNXVubDcvcHZBT2Q4ek1PbjNtTFAzKzcvMjBTYXJIXHJcbiAgWFhjL1NHOSs2M3ZwM2svK0FiMytSWnlWVmVoQWNLb2lic0Jxck4wYnFkWXVCTG5BL0RXb3hNckdQVlNQaGZ5d2FpNzZmYkVuNU80Q1xyXG4gIDd2bXc3SFl6Qm5RbGIwc3JVVm5sQXlpalpvbUNrZHJHdVZnQ0lRUFVQcFZHbkpCRld0NUc0ajI5MDNUZ3dBRjV2bU1LcTdtMnRzcUNcclxuICBpQmp6U01xUVFQUFF5bElyRkdCMmZGQzZaVnE2NFhoTXhuZmxZTnpZQnh3SGxweHdMWW5hY3cvVG1YNTJYTXcxTnpYekhkUGJpaDJIXHJcbiAgWllpdUtrQWRCd3ROWHZ4Zk1wQlF2aG1aOENaTDlNSVlnZ3puQVJ3R1doSXQrTTJpcXBGamdOQzk1UWIrcmVoQzQ5OWxoUlZIMGJPQlxyXG4gIGh2bGk3dDU2b3prTzY1WmlFMVM4TFh6dXdybmlMaEhPQ0k0Sk1tY1RrREEwOU9RSGFYaGtTRTlHUGlsdnZPa21PajFqNlFvQXgxRVpcclxuICBlb2s1NXdLMHNPTVFubFZhYnJYQmc1eWpwNTZpenMzWGN1dEdCK2ZWK2JHRm1DenhiLzQ4LytZYjFIR3dBMUd3WEp6bUJyWmJ0SE5IXHJcbiAgODlSSTZVSm5VZWhNZ214SDJ3VzYvLzc3WmV3RDJIanoxM2tidk8wVGI0bjA5aVl2Y2lRSm1NMDZFbTE5N1BCWkJhZ0E2Nk9GaFRselxyXG4gIFJzVmdzMkJaWlJvUHN5OUlObmowSVpybjh4WjFWdmZlTjFKZHMwNG9TT0RUaFF6Z1FQNzI5NzZEbmNNSHFMbTVpWDc4Ly90MjB4QTlcclxuICAvTUNqOU1sUFBVRTNYcjJWN3Z3S0hYUDdobS84S2RxN1ovMGx6Y3o2Nm5mK1o3cjducy9SNkZEMTczSmZLU282a0RxK28yM3UyOEYzXHJcbiAgQnpZcTRhOHpKZlJhZHNLZ0w2dHdKRyt1OVBCdThpV1pwY0g3NEFBTDV6d2FlemJMdkd0Rm1rL0lpZUZxUFlIU1p1WTJCcVlqTnEzc1xyXG4gIC9DYUMycWZTaUJPeVNNdmJTTnl6Y0ZMR095NmMxeTZPNXBZV2VVRHdBbTFnc3pTOVFtWGlGQmloMVlIWlZhZWtjdFVWQWF4bHdvUytcclxuICBsNXdyWUs3NGNUaWM0d0JRZ2RhTkhaRXlOTlEzY05wYXF1L1pMb08wV09kS3dLYXd4b3l1cHRZZUhkK3dtd1hOUmJlNVl3MldaVjdxXHJcbiAgOWFLd2J5UVQwdkVNdGwrYW4rRUs1SUQ4THR4NXc5NDVEQ3l6MGlSbHREUWNZWEIxNUNRcVRGMThEclBGb0oyeXUzY0ZTL2liVnVpYVxyXG4gIEJ5cHJhUkZ3NVlwamcwb2JZMnF1bXdwbzZWRW5jZVMrRCtpSnVjQ3RpdlpXV24vanQ0azhqK1RTOGNCYi9ZQnBqckdmYk4wSnRMRHpcclxuICA4eEQ5a25jd0tQL1FzVWZZU2FEYlRCT1A4aDEvSjkvdFQ1eTNTcGJsbHN5YzZBMzZ1NnlGTWoxeVJ0YTJ3bXE2MmpvQjJOZ2xFbkFlXHJcbiAgam5ReUUvZ3RmK2RQM3krdkZZQURXYk4rUFRWdWVxM29MSVZQb3pEYW90RXoybEtKSFFtNmd2UmhWVU9VUHR1dGxXdU45RDhuOG83MVxyXG4gIDd1RzhrTFlpMkN4WVZwbEdFTmxta2cwZGUxaGVYSWNycHFkS0ovSS9mK0pPK3ZkZiswYWg4V2JETjczeDFVa0w0ZVAvZEJjOXV2OEVcclxuICB2ZWFtdmR3YTBiZUkzbnpyTjlLdi9mSi91cVNXQkxxeXZ2dTcza20vK3pzL1paSVhGaktJSGg4WDBIakNHOEJ5NkMxOTI3V2ZMNmtrXHJcbiAgSE90a2pFZ2ZWRUdQWnpxbWgwNUlkeFVBRFE2OGkzRVpONjNhU1kzK3J0dlNXajRoSjRiZkY2QzBtYm1OZ2VtSVRYTEoyUUpxbjBvalxyXG4gIFRzZ2lMVzhqY2ZmOENYcnVJRGU3VVU0K3VsZ0cvSW9ycnFCakUyaDVGRUdsNk0vUHRqcm1aOFlJYit0ejZlQmc4S3hGZlhPYk9oSkdcclxuICAxbkZnNVFESVprL2NSME5ESTF4UjFsQTlYN0I5Vjl2eTBXeUtZekdCSlV2NEppRXNMUUtwN2NsNGhTUXd5dWpNK1FEZXAzVTJpYzRoXHJcbiAgNkZCNTQrWUVkOHl6OHI1dXJWVEJvOXNHYXkvaHQ2Q2xnUnpDSGJ6bW9ZNGk1SXpmN21MWEdzRnhrRzdRWU1aMytYTXlvQmtMMFFwQ1xyXG4gIE54Rm1IWjU5N1A5U2ZXTWR6UzhzVWs5WEY3VnNUWmR3bCtzRmpnZ3RhTnp0OTJ3U09ZQXVSTmN2am1kcW1zMHBpWFBLVkNhWWRxMU9cclxuICBacU5jaEtBN04xNHRyVWlCN2tncXFwNXROMnRzVHNVZkMwNVkxOVFXSmxkSVBxcVRMakhMWTVKbGFPVjFSeTBXcDVQSTg0QnpUaW80XHJcbiAgOWVqZk1jbjB3Z0s5L280NzZQQTR6cmRnNzEySlJFWUxnazF3SkZmeGRvbkdUbWRhS0F4WlVzVmFJd25pTEkxWm1OUFZnUU1TbzNLRVxyXG4gIElqR3FUQ09JYkNNU3JiNlpvWlBxUkt3N3F6QlhFM2JWWHFRREQvKytNZ3k4WS8yMy9zZC9vV3V2VFIrbXZPK3VCK2o4MmZQMDVXOS9cclxuICBIYlgzOW5GRmZjTWxEYXAvN0Y4L1ExLytGZDlIRHozd2w1YzBxMnM1U0JWbnRFY1ExT2h5MFcycnBSSnlGNXpXSGVIaWl5c1RMelVaXHJcbiAgNXRyUDhNazdQNld2L0FSd3NKM3pBTEEvakhmVXV4VTdNM2xISElNNUwxQkN0bUZqWURwaWsxeHl0b0RhcDlLSUV6THdDUldacmEwOVxyXG4gIEk4OTRZSDByTjl0cXk1WXRkR1M4SnphTGdLbXgrVmFIUHVlaEp4WFN3UWJ2MW5CM3JsTkQzTUxnaXNvOUNJaHVLVUNjaVIzNzRXYy9cclxuICBTblB6ODF6SExWRmJXeXUxNzhITGtIaC9YSG5pK0Zmck9JSk9lVVdzczRCSU54eTVWSUVIME1MUUthdmM4bUNIb1VtNDljRXRDWjJsXHJcbiAgdE1GK0kxb2taNldpaEFPSm5RVitLN3A2VUZGMjhGMzUzTVF3dGZTNkxxWWFXYzdGZGNlaFVtNkpLdmhBVzdsaXNHaFB3M04wOTkxM1xyXG4gIHl6TTZqYzFOdEdYVFpwcnBlN1hrR1FOTDZQajNhU0Nyd2xvRENBb01DT04zb2tYcG5NNDBPeEU0bWVCZzFIN282RVBxQkMyNWI3RXdcclxuICA3MW80NHJ5c1N5NjBlczZ3azdtUkthM1doNDlwNjBSZ0RnSEw5Nk03cU1pWjZEYmxUM3oyci9nMzhrMUlmVDIzeGtMM2xiTTJ3a3MwXHJcbiAgV3FMWndaUFVpTVU1SVRBVnl0ZGtYWElBSEVucjZ2QWlMRGdSVEhMQU5QSHN1MGhTbnAxUTRaUHN0cVBsRUlyRXFES053R3lqSk9oU1xyXG4gIG5CaytwVTdraWpmenpVZlJFdllNRm1ZZENIRER6ZitlUGwrd2d1L0gvL2x1ZXZMNWZ0cXh0cDJhMmp2bzEzN3pyeTlwVUIwUEdKNi9cclxuICBjSkgyUC9saGs3eHd3R1dkKzYyeG9MNjVpNXI0WkE4cnR5SlJmUEV4YmF5ck1uQUhpWmJHRE45VnprOE5ReUJ5YUozanNDU3lyN2JOXHJcbiAgTjZSUHV6c3c2U3N2Z1FnTVNzZzJiQUtpTWlaNUZObUMxMitFaUJNeThBbGx6STFiYW1XbUZad0gzaUFJOVBUMHlFT0N6dzEzUkdsaVxyXG4gIHFQT0lIWWRNcDUzQTYyV0Q4eGcvcnpPdXdFQ1A0eHZQVEJ2dlB5aUQ1dTQzU3g0WTV5QTRzb3R5K052Ym02bW1Zd2MxOEw1a2pNTUtcclxuICA1QjFBd1gvcWp4dDBRZ1plS2NoQnBmSnBlUUJ4aGx0TytzQlVjQnFZd3NxVkI5dWhDOU92OGl6SjBjSXdKOElWcCt0T3dybUdPM1hjXHJcbiAgMmVPNUMveDIxZWsrb1ZPYlU5NDVlQ2RoK1RxZ3NxNXI3cFFYWFUzelhXTnp6MmErTWFybGVqaDBZMjJzTzA2UFBQSUk0UTJRZUZZSFxyXG4gIEt5TFBieTU0SGJEUE5yMThwZ2IxM1RTY0FkdmdiRi9pNjJjajM2VnlhOE1jUjNNdmx5OUpwZ3grQTlMMzduZzFEUjU1VUg1bjdGalFcclxuICA3OTY3L1JiUjlYQWMwckdUNUdPR0ZvcDJlMm4zU3MrMm0yUjFnWHBwRVhGTEJtTW5CZDFaUTN3WFhkWXlxZS8vTkIwNWNvUXAvQmFpXHJcbiAgTGJkK2c4UlpKd05JSzBVcDNYSTBkZm9wb1Z1NFpTVnlNOEU1MnREdVZrRmdaTklxbE1ZTmtLOXpZclV4T04rYXU2S1ptb0xFc0J4c1xyXG4gIEZpeXJUQlBiR1RsMC9CRlovUmhIcWZmS085a2g2aFRmYkk1ZE5Ya0hBdHg0eTd2bzBaSVZmT0ZJZnVWL2ZvZzJyRjFGVzdhdG81OS9cclxuICAvL2VicG5yVU5MeUtmdXMzZnBSKzhBZSswU1F2RExDcy84OFlYUWlaSVZGWEx3OFRhaDh5bnJURkgycXV3RjFJZk1IZ0xnM1BjZUJDXHJcbiAgd1VOU2VEKzVBNnpkZUlkTGdsVjAyN2U5V3JvcEFrd3JVVnoxTStXWlNHcDJLWUp0bklPU3hiYXBOT0tFREh4Q1JXWm9NWnc2ZFVvV1xyXG4gIFJrVEYwOXZiUy92MjdhTkRJNTJ4bVFjdTdGaytWdkdEWTNKUnRhS0MxMm0yYzJoMThESEVEQlprTXQ3L25EeUZqOWxXQUNxT3BZVlpcclxuICBXWlliQndKT0F3UHByYjFiSlkrK3BnazZmMzVBOXIvSWQ3ODl1NzVNdXI1d3pIQmNhdkN2NEgrVWd3Z2hRaTFIcWxVK0JKR2JYdE5wXHJcbiAgQUkrbmwvRUFLR0g5dE81MU1yQ0tWV0J4Q2FGeWcxUEFZbzk0NXpic0cva09YdkxEekI2T3NaUThCa2hidVlKRnR4MmNJaHlCdkRlOVxyXG4gIGM2MjByT2FueGlTTkxOVEl4dzl2bXNSRGFZaHhqQkJqbWk2NlM3RVlIdFpKbXhudUZ4dVVHM3AwZTRESGNVU002YnVTaDRSdUdqMytcclxuICBFSTJOalVsbGlBYzlNZjE1cklFcmZONnZ2RkFkY1JLaVk4akI1OVhXclhGTE40dDUzNXkzN2hPOEhrdGNKL2hOc0lOend6SHYzSGlsXHJcbiAgeEhqNkg5MVNzQnVDTTJGZUhBVTdIeHdYeUtlNEpZSGppTEVreU9Cc0lCOW01d0ZIczhESEVUUDJKaTRlMFpZcS95Yk5VKythOGFJcFxyXG4gIGRCVmlRQjhEOG9oRkNYQU04dmhUOTBwTEdyOFJzd2ZyZW5hb1RrejBOd3VEVWd0ck9tejUyOEQvWFFQZjdFeWNmcHFtdWVXTC94SnlcclxuICB0SjdSMnBqRlM3SGtocWFHZndkNFRDbkhOY0c4NkpudjVOWkkvd0ZwT2N1MXdla3hOb0lWSy9EN2NFNmpOZUxXWjFOb0taWUZtNkRjXHJcbiAgaWlyVHhIWVc0UnlmbXg2VkhwZnBpOGVveFY2aEhlZTJwVzJRL3U5dnZvZDZOK2JYeGJyeCtpdm9QMzdUajlPM3ZDZi96djJkZTdiVFxyXG4gIDlrMTlORFczUUgvMkYvOUNJNE1YNmZWdmlONENXUVcyYmQxQTMvMTlQMDgvK3NQdmthWDRYeWpnMk9YY2JsWUE1NEdsMHVFUTRDVHdcclxuICA1MHVsajhGMVBpblJuWURYamVJdTBVMDNqTUdubjkyL2hMK25odk5vMjRUMW1lSkRiTFJFZWlJcW1Jck5qTkdraVlJUmJPTWNsQ3kyXHJcbiAgVGFVUkoyVGdFOHFZcTljdVVILy9HUmxreE5wV3FIVFdyMTh2TDRKNjltTGNSK3VBTzIyK0UrYmZqNGZiQUYyNWRvYWFPN1ZwajZ4aFxyXG4gIEkzZWZ6TUN4QU83NURUZ2YvQmU2SUtJV0JCVVF4a2I4RStKOGNIcW05OVBCWnc4UzM4QUpYdmU2Mitqd3BON1pTNlduaEgwMW4vQi9cclxuICBxQnk4U294WElZczFsanRjUDNpSUIwTDUvS2kzOWJETUJxdWJvbThZVGdSZE9IaWRiZHZxbmRMWGozd1c1bWFsQzJPYVc2em81bkV0XHJcbiAgREhRLzRhNGN6eEhnZ1VseHBBYjhYbFNtUTRjL0oyc1U0YzRkZkNnL29MVDhBaStPOVRGVTN2L0E3OG9MdlhBamdCZDZyWDl0TlB1bFxyXG4gIEtHbHlzZVF1SlFZU21iek0xdDk5QTB0eUV3QTFXaXBEaHorcmF6QjVHOWJ6TVFHTDZ3MDNJRzRwOWNHakQ0cmptTVN4a0dNSVcyMmRcclxuICBTRmNndC83MCthSGRTWDVqNXc3SmJDcnA2bUk1MHFEMzRJcU56ZkpDTFFGZXFIWEwxMk0zU1ZxTk5NNjFTaUk3SjhaclpEdWtOV0lDXHJcbiAgeVBoR28zUERsV29qVUhrQW1FVGcyV20rUVhBenppYTQ0bDdrY3lrTXNNZklwQytCTDNLVjlva2RrMjUyVmozWGo3MVh1YlhDekdid1xyXG4gIENmcjBCMytTZHQ2aWcrTlozSFB2US9TcFR6MVNjY2JWcCsvNUxIM1puVDlBLyswbnZwVmVkL00rUDF1ckdyeitqbS9uZTZCRnV1ZXVcclxuICBQekhKNWNPM1FDb2RycVhGT1ZrU1luR09IUVRmOFM2d3M4QmRJazQ2Qk56cFNCL3hVdWdLY0VDcncxVlZQdWE3c3JhTmVMcVc5KzR2XHJcbiAgU2lNa2lxdisyQVpRUnV1SlJNRUl0bVlsVzBGU3NUaWdJalJTRU52N2pTQ2hJclB4ODRmWmNWeVVsMEdoMndNdmhNS0ErVE8ySEhzS1xyXG4gIDdkZEhmN1liS0VYTEJYZkZya3NLclk2cDRWUDZkRG52UjFzZFc5bGU1NXFqbFFFbnJhOHBEYTBPVk1neUh4MWw0eDgxd1hkb0cxYTFcclxuICAwTm16ZUtXdEpLVyt2aDZhcU1VZEhQNEovQTUxQkZyQldvamxGc1RlWW0yQjFOTEl5U2VFUi9jYnVxZmdKR0FyZDdxdzU3dDExMXFwXHJcbiAgYittUXJqcmNhTFQyYnBRcHRWaExDNVVaRzBzZWFJbkFTZUQ0b0JVeVBRSUhzVmxDUFI4ZjE2ckFYYnc0RDZ5WnhIbUR4ejRhMnJTVlxyXG4gIDRjcXNnWGxyNFdoUU9yRmhmWnl1LzVsN0pNWi8yZExTUXUxYmIvRzY1WVBseFdlNnA3MDhzc01uNXAyZVB5aWphdzJCZDcvUHRWYjBcclxuICBHUlJ1b2ZSdGtoWWJ6aDA0V3J5dkJUY2kwaEpyN1dUN00rSlljT2VPMWtrRC93Y1lmOEI1aFdPTWx0ZlFzVWZsZUxSeEN4Wk9oa25KXHJcbiAgRytrd2RmajRrL2RJZHl5T1JYTnpDN1d0djFwc1lJWXlDWUdOQ2tybHl2R0hTYlJBaERZWnZ0b0sxeGFIM2dCaHJUVStyOWtoT0I3alxyXG4gIEgraHF4TTJLam9Vc1Njc0RQTmJ0UXFzY3JiR21EajRmdWRXU2ZkKzc3RWhDWmZqaVYybWYySEdFYWVKVDZMcm5HNnQ1L3MrYVpjYWNcclxuICAyZ3ljMmsvZjk4MXZLMnlCQU51M2JhVDc3bnVZRGg0OFNqZmRpTWtHZVd6ZHZwbmUrUHFiNk9kLzRROW93OWJOOU9uN0g2ZXAwV0hhXHJcbiAgdWJ0OGZTMkgyMjk3RmYzb2ovK0dwTi9HKzNvaGdQcTlZaGZXcFFLSHpIVlpBYWl5NEY3d2pFZkx1bjBzWjQxVEJvSkpQYms4N0FSVVxyXG4gIEtDM2JSQTR3SDRtU1hEU0JrQUZza1lqSzdSTXFNbHRYMDArSGp4eVM1enpRNWRIVTFDUnJXejAvckU5OHg4RDd3akcxVXU4TUZUcFFcclxuICB2a2VkQStjTDU0R1dDZTZvWk5COEZ0MVg0Y2x5M0hIQ2NXRFdEVERPbFlQcnJwSnk4USthdW9ncDB2UFV1bW9iZGRZTTBlblQvZkk3XHJcbiAgRVZhdlhrV1RkWHkzeGt5b3NDd1lMWEt1eExTN0J2OWFrS0diYXVMOFVlbWlRbXNDNDF3TnpSMVNHV2tYMVlSMFVVR21NNTgwSGFac1xyXG4gIE5yR1RRUE1lRGhGNXR2UnNsbTRhZEd1aGtzUCt4R0hJdUFTM2JLYlk5dXd6VE5kVHZYVUxCV2NSdW9GQ1diVzhUaWJkQjU0M21kR3hcclxuICB2Y1lhdHM0L0l2MzlHQ3hlV0ZpZ1ZhdFdVZFA2NnlWTnBjQWJDOWlIQzZhUGpwK1hPZDUwdlBIQnlXSWJ5SjFUY2QxMjBBMGYrUncxXHJcbiAgOFBVazV3bmZsTUR4SXQwUXQwVHduOVRVTnNoVDNjZ0R6a1BQUDNVbXc4Y2U0ZGJLemVJc2VBZHlRemh5K21sekpEVTB5czRhZC9RNFxyXG4gIERzQ0dEUnVwdHN1ZUVHZTlGQXNmamtHYmdJT1VXUExJeXBVTC9PVHAvZHFGQmFmQ01qZ1MxNjJGOHhjOEhHWmRmWk9jNCtvc0xzbzBcclxuICBiemdNektURFRaTjBZZlVmbEdzRXkrM0FlV0QxZ3R3RGZnTFp1WkpsUUJFUkhMT2N2Y0JzT01KcUVMaXhSSy9DSWwvSFRYeGVBNnRiXHJcbiAgSituSGZ2dzcrZm9vdXJsVVlDbjIvL25iZjBtOVBWMmxsZnkyYmV2NWhuVkNWcGw0N1MxWDBLTlBIYVA3UC9NNE85MVIyckZMNjRzaVxyXG4gIDlQVjEwK2pvQlAzWG4vek41UG1UeXdGK2RhWEd4eVVCbWNKNU9Eam4wZEM1WHBiODlpZVJ3Qk5DNnVubmtMZVRiZGdZbUk3WUpJK2NcclxuICBMY0FXaWFqY1BxRWlzeTFOZzdLMjFjallzUERyMXEyaDdkdTMwNUd4YUdEUUlPK0ZacmpCY2hua2xvRnlOTFUxWDd4cTF1djVwSXVuXHJcbiAgNW1MNkpaNTdjRjFZZUdOZ2ZYT25YQ3hxZ2pzMm5WblZhR01xT0FhcjVwNmhKNTk4QnF0dkMzYnYza1ZqSGJZa2h6OEEyTDhkTVNlVFxyXG4gIHE4Y2RSYTU4ZVA4WThFYVpvTUtnT09UdTZXNVVGcWlnTUp0SUtxcmhzOVREbFJPZ1BLYlZibVNIb1lQYm1FR21YWFNieEdrZ3o2bkJcclxuICAwMUpCTkxUMWlLTkIzN2JzSDBvSFQyZktLekJhWkVHdUZHK0RpSkV3SGczSFAwejc5KzhYQjRLN2JyUWs1N2JqblJmTGdLK2c0aHlCXHJcbiAgNlBJUzBzOVZNakRuQmJHdHN6Tlo2RnNwMVdGTUJGMTVQVHV4aUI3TCtEdDQ1TFBVdStOV21wU3VMUDYveEZRSDVERTFHRFRHUTlDcVxyXG4gIEJUOTRGSVB2bU1WRmRPeFR2eTgzUmpLWjROYXZwdW5hYnA5ZUkydzVGTWs4YlJwVkNwL0lHYklLcjFXeVlzUGZhUmtiV1MwV3VISEJcclxuICBhc1p1U1JRNEdaMyt1eVJPSkI3N2tBRjFqTE53UW93TjRacEt4MGF5MERKVWdoV1hzYnl0Z244WkorcC84cU5VdDRRdTJVMTB6ZFc3XHJcbiAgNkhXMzdhWmYvb1VmTkp2S2VQMGQzMEwzM2YybnhoWGpqVy82YnZxWm4vNTJlVDdrTS9jOVNKLzZuRDZZZWVOVmVCQXhuWG9lbzdYalxyXG4gIEZ2cXhIMzBQL2V6N3ZzOGtsdzZjOTlVZWxhcUFTZ3pCd1RrUFBDQ0lJQmRhNFlXdm02Qmh5ak5LbUluYkdKaU8yRGdISldOYkFCV2VcclxuICBrWUp5KzRReTVxYk45WFQ4K0hHWnBvdVhRVFZ5cTZPenMxM1d0am8wNHFZaEI4QlJ5SU43bGg2dER2RHFMSFFXRmxUZzRWZ3dFS2NQXHJcbiAgaW1rQzNGVnBkNVVDZzhzZGVEdWdxeWo1aTR1b2xublhyU1VwbVc4YmVZU2QzRkZxYUtpaHVia2wycktGV3czcjNETFJTT3VPbHVZalxyXG4gIGVVWXkzTVhoRGhVdEhraUhUM3llVzBjMklENDFMRThPQzg5M3YxaGxWUWI4V1llMGNnY0t5dUxnTk5pUjlLRDdDVEtibVlTQlliUXVcclxuICBOSUhZaTRFS01uSWc2UHhXOU1xSG1CR2xVeXJXV1F5dzNZWFAvQzhaeHdKUWFkNTQ0NDAwdXU3TGhTK0dPMVlPMGFXVVhGV3VxalNFXHJcbiAgR29rUnA0bnRtQkttU0ovUkZjaUhEajlBN1Z6aG9pVWlZQnZuVE54c3FaRlRUMUtYalVkQWhpVldjTGVQOUh1YWo5TEhQdll4MFdFdFxyXG4gIHRUMnZlUmROTExWS1BnS09zY1lYV29ncUMvdld5R1NlTm8wcWhVL2tqTWxUVDFGck5ENHl5aTBVak92cDllQ1NxaTI2Tk5GMTI3SGhcclxuICBDdTBLNVJaWis1cWRvcHNadGNGMkJxNnBtVkdzdkZBMExoTER5bFFHVmdlTFpXd0YvS3VXRnFuL2lYOGlUQkhxN0Z0RnYvVFQzMHJmXHJcbiAgL3IzZnJPb3FnR2RFbGh1dnFHbTRrWmJtSGpXTzZKNlBmNW8rOTlnaG9XKzZaanU5NWUxdkVEckdmZmM5UW05NDg3ZlMwSVhQVUhlM1xyXG4gIG5SK1hpQmUwQ3l0MkhyaXdDcDBIdHY2cU0wS2krR0tNYlFCbHRDNklGYWxkY2pubmJBRlViRVlLS3Rzcng5dElQTmIvdkx6UFkySnlcclxuICBnaHI0VG5WMmJwYnV1T09OOVBTNWZMTjBkbktZSFFQR0JKU1g1amRYbE9pbVFrSGdQTkMxQXg0WFFSMDN2ZjBBTXQvbFkwRGFPWThaXHJcbiAgOE53a2x2Y2x5SS9RVnNjTTMzVzJjSE1mVFhyOGZ1MDZVUDAyOWxISGo1L2t5aEJ2ZHRReGtJVld6TmdLM1NtZ3hWNWtLcC9tQ3hCOVxyXG4gIHVDM2QycFUyd2MxeE9BMjBJdEJ0aFNDemFWRE9VVHk3Z1hXNDJ1U2lubUFIaDd3YXVlSkNTMFM2cHpqUDFyN1FaWVd4REpWdGtiRU1cclxuICBuWm5FNWJCdU15bWJqRTJnakJrNVl1WmRXUkhJWmdsNVBlS01qZGd4SDdxdnNLN1ljWEhZc0VNcmErREl3OUx5QU9UT2U5dWRNdEZoXHJcbiAgY3BEdHBrWTBzS05FakxHL3hkbEp1VUh3T2c0WUE1cEF2a3pyVEtGRmFtenQ5V1hRWU9XUy8wdHAzdWh2RUZtUTYzaEtLSFBRSzEwbVxyXG4gIGIrWmpMWk1VK0RQTWpnUEhHZDJEem5ibzZPZWsxYUV5a3VkT01KYUFNU29Jbm52NG8vSXVGT2RzWnBjYTVkeVUxTmduWW5tU0h3dEZcclxuICBzaE1SR2NUUVM1YVJUR21OdkRLVjg2ZUJXODl3R3JoaHdTUWR6TDdDOGNTQ2xHaWR3azZXUCtFME90NmhOMHhvR1l1ZGpIMjBjV2lWXHJcbiAgWTQ5dVZKeGJhSUdvTGpzdUVrTUtWUTRVMTVzc1l5dkFjY0RNdjI2YTRCdW4yYWxKdW5yUEpycmpyZFcvNXdOakluLzI1eCtwK0liQlxyXG4gIDE5eDJIWDNIZC8wTWZjdDd2a3I0N1R1MzB1dGVlejJmbnhQMDBCT0g2VE9mZTVJT1B2WWs3ZDJ6aFJxYmRkeDEyN1lON0VRK1QzL3pcclxuICBvWThXenZwYUNWNFFCNExEeVpkbTRqd1FZdWNCeUtuaWo3MFJFdWxKcElodEFHWDB6MHNVakdBYjU2QmszamFjQUVCbGUrVjRHNG0zXHJcbiAgTm1OTTRiUi9FUlFxaDZ1dXZvS2VIOWJWVngxdzBhSHliTzZLcCtnT1dsTWFlWEtMZ08rTTREd0FtUm16YnErT2hiQWVyUXg1dUlvZFxyXG4gIEMzWVBIb09mZWdIZ0tMUHpHZTJYYWFxNGlQRGI1YmU1SDhneEx0VEJ1UzZhSHpvby9kaW9GMXRhbXFpMmE2Zm9wREtWZEJ4UVdYUEZcclxuICBpaFlIWmtFMWQ2NFNKNEVXUTl2cVhWeHhiQkFIaHY1MzNOSEN1VWhmUEFkVUtqZ09BQ3JiVnY2dlpZSUZPNVBnTkhRQUhHVVBUcVBIXHJcbiAgS25PcktCT0h3Y0hvMkJFNCs3ek85TkNKamNyaElGQW1xU3k1akhFbGovMGh4b3VRMEZkOVpjZFo2WklFMElXRjF3czNyNzFLN0RtM1xyXG4gIDhMSDlZVi95dTJXLzNOcGJzME1jUE40VnI3OERnOUVkL0w5dGszMjVNazVlUE9iTDRCeE42bURVRGg4bWZKQ1AxK2t4UUJsVWJvRS9cclxuICBLZ2RsdGh5YSthWkZaZXBNUUhkc3VGcTdEODBPRXlGNnRyOWEzeTNETGVTaFl3L3B5N1FZZlgxOTFMMzNUaG8rL2dpZkU1Z0VFaHhKXHJcbiAgVFkwNkQ5Mi81c1dDU0dabEFrUWxFclV6c2VqbHkyVmxKd0xuTWNQSENROXJRcW9ENTg5SWx5MzBjQkxveHBWemlLR0Q3NUMzeWtRQ1xyXG4gIG5aU3ltbThPUm1ocTRJVFFTSU1icm5xYmpGSU1LWm1TSlFqRlh0NFdrRzVaZGlLNGxoNThjRC90dldJSFhYVlZ2TEoyT1RBR2drRjFcclxuICByTmE3WjAveElQbk9uWnZvbnovNkdYcjIyZWNUUjdOOTV4WjFKSHlqKytEVEoraUpwNC9RaFZNbmFldW10VElHODdhM3ZrWmVnWHU1XHJcbiAgQStvNEF0VzB4MHFCRFBoMDlvZlNIZGFxbkFkZ0o1UUgvaUVQcFZXVVdER1lOMUdTUXdYYklJMzBRa1k4UXpuZVJ1SmRIYVB5RHZQaFxyXG4gIElSM1BhR3R0bytaV3J1RFhwY3Q4Vnh6djRCOENIclBZMEJMQnlZNjdQbmtJa0hlRzdpcmM4YmVqaTByU1l1SERBVzUrdTRVUHRkV0JcclxuICBOd0cyYmREbkJRQzlhSVd5THphUTFWQmQvMzJ5RWpDNnNGcGJHNm4zMm5lcnBlbnh4ZDAzQ1BTUlkvWUxadWwwYmJwT2JIREhYY01YXHJcbiAgdExSdzJCYjkwZklTSkdid3NCcG1uYUNQVjZmY25oYUhBVjdBTm5CSStsWTZWK21KUXZKV1JMS0lGcGhOVGg3eCtHQ3dGNFBGRnc3Y1xyXG4gIFE2djN2VkY1bThVR0dxYW9jUENhWDVjMlhqSWNXRDN3Y2I1WTd4TWFYVFpyMTY2bHJsdStWeXBVMjFrcDBNV2lkbm9wdVM0WGdZaFVcclxuICBQbkhoS0R2eldabFVnTHQzSEV1MFVQVjlMcnFZSU9BdXlEWjVFTk54SE12WGVHc1pwSEtsYlNNM01rcTREYnBWakdZQ1hVQllYcWg3XHJcbiAgaDc2cWRSRHZ1MkJzNzEya3h4OTcxQStnNzd6aisybjR4QlBpT09ENDRGeVFEeDVVZE9YUWZWa1FFZmFsT3JXeGtpZDJrQ0VXQlRZaVxyXG4gIGs0Zy9zdjZYTEgyaXdGZ2d1bXZkbEY4ZC8xZ3Qrd0dONTBRd05vTG5qOXJYWCtIUE1lazZ0V1Z5TUM3U0lkZGJOYkF5bGNDS3lxaHNcclxuICBCOHljK0RRTkRlcTdqdmJ2LzhkU2gxQUVkR1Y5NklPL1RxdFg1OGRYSGJEVXllT1AvQis2N3JyeTMvYUpmN21QSG5ueUtLMVozVU05XHJcbiAgYmZWMHovMlAwOGZ2K2l3ZGZFWmZGSFlwd0JGZS90ZVhBSW16emdOQWhxbnp3TVpwQWFNNWtzckJRd1FHSldRYk5nYW1JOWJua2JNRFxyXG4gIDFEWklNM3BoczFyZVJtYlhiMWlTTndsaTNHTmhmazRXSjl5OGVUTnQzTEtSbnJYWGVnTG9kdEluclpWSGhZRzdkSEVtL1B2UjBzQWlcclxuICBnZURoT0ZDSnVNRnl0RExjdThpUkhMTktRUHRXQ3dkVTdwaUJWR2RQY0NOUDNSVnY1YXQyZXF4VnRtcjZDVmtSZUdaR0s0UE50NkVQXHJcbiAgVm5Wd0hPakdnRE1Ec0s0UFZyYkZoWWQrWk9Tak0yVHc3SXJPSU1OWXhzeklHYm1EeGV3WFRLbEZPZlZwNTNSY1EvUEZ2cmhrS0JNQ1xyXG4gIElMR1YzV2lCNlVXalNnMHE1aWpJTHh5NGwvcDJ2WlpxRzNBc2NHZC9GQXFoQVhUZnlIOWh3TU4wYld0MlNpVU5pMURwYyt1QjZjNHpcclxuICBINkhQZlE0dGxTVjVjRzdUcGsxVXQrUHRVcm5QVGd5eEl3MUw4WGh3ZWRFRmhNRnJkeFdwOHdpWDFMZzVCY2phVnJsOUd1OGNEZThUXHJcbiAgNXdwU3RhM2VSaU5ZalJjVklKOGZLRGNVTHNmZ1ZGUm8xYklaT05wSllSREx3QXNqUVZWd0pDZmtkNGlNUDRPUC9nV05EQSt5SHVNY1xyXG4gIGk5SXlnYTZYWTgxRDB3OGRmVmg0dHo2WGZvTWVYNUZrK1loMmNaSk9SQnFqZFRqVi94eTFZZGw0QVZ2Nko5T1hhSVNkQlZvZm1OS01cclxuICBGTTZwNFBweURzWEQ4c1JEaDQzdFBUb0paVmxZZWNyQTZtQlJiTHU5YTVLKzdaMDMwRU5QSGFZLytzTy9vNDcyVnE1TDdsL1JBMzM3XHJcbiAgcnZwS09zQ09wd3ozM2Zjby9kQ1AvQm85eGs2a0dqaG44aFAvN1Rmb3IvL2lsK2pyLzBQQmFndFY0Sks3c1BEM2xUcVAzcTNzUFBRdVxyXG4gIFZPVzhkUWFPa01ncUVVSGV4a3pjeHNCMHhNWTVLSm0zRFpKWXh4QTJxK1Z0Wkhiemxqb1pXQjBkSHBZbDJYRjNpc29GUzF3OGVUNjhcclxuICBrUXl0akhpSkVGUzRtTTdueHp1NEpZRzdjL0NnTVVWUmRKeGcvTnhCdm1QYTU3dXM0RHpRNnRCcGlMaUxYNUpWakJzN1YxdC9NN0xFXHJcbiAgTHhjaW9WMVFXUzIxekoybC92N3owaXVFNjZkcml6NjhPWEx5U1hrdEtSd2NIQi8rdDNhdTBOQlZoYWZJc1d3SStwQngxd2NiR2JRY1xyXG4gIE9DWjNiK2o2d0FXS2JpNDRDWG1vVkxwMEZ1UU9GUVBpYmx4RHB0Tmk1NzY3eW5XdFFNYkI2TGc3Q3JiZVRycC9hdWppUVc0ZHNCd09cclxuICBHRjFUNkJyQ2NVUUxDZnRFd0lCclM5ZGFhZG1oTE9pZXdoMCswcnR1SStoWUlEckVDT2hLWE9qL3ZQelBzQVYyN2RwRmRSdS9qUGxhXHJcbiAgcVlpa2dqTjdGOUQxMU5EY3J2dm4vZWg0RjNUNFhUZ2VXTzZjeTRKV21Od3NhSmNaOXRHK2VwZkVDREo5dG04TEg4OEpLWjl6SHF4VlxyXG4gIHA3N3RSaG81OFRoWDFEZUlQYnJCa0Q5dUFCcGIrM3creFYxYlRxYTBIbWZIYThDMFlQQWk0OCtacCs2aXhhVkZLVDl1bE9yNjlzb2lcclxuICBqM2hRRWMrWDZHdzZPRTl1ZlhadmtpbkJVelpGblhPUi93ZmRTOE1uSHBWenk2MXRKc0J1OEFFckloRUk2Y29sRUFGT2tYb1pHOEhMXHJcbiAgMG5UcEd5MnpXeTRlNXdIR1RFYlBQa1BOZkgyZ2kwcWRDRHNWRGpoV09CY0IzSUJCajJkRk1QVjVibXFVeisyQ0ZYUVRXRUhLd0NwWFxyXG4gIDVESzdpY0hqOUw3dmZUdDk4M3Uva2M2ZUc2QUhQdnM0L2RNLzNrUHZmYS8yQmxTRGE2N2VUYi8wSzM5VStxNTBqR3VjNngraVQzM3FcclxuICBZWHI5NjlOZWtTTGd1WkhYdmZaVnRMcW5rNzc5dTMrRzNuajdxMmpiRHIzaFh3a3V5WUhnTUNHaE8xd3U5czdERm5nRGNMSjRBMGRJXHJcbiAgSkJwRGJBTW9vMzlNckVqdDRoeVVqRzBCTzFFOXl1MlY0bTFrY3RQbVducmdnUWY4K3p5bVo2YXB1NnVicnIzMlducjBERitZQnZTRlxyXG4gIFM5K3FwY1ZKSzNmZjRMa0E0akNzU3d0MzhPN0ZRVENBbzhHZEtFeGhKek5Mb25kMXlQdmgrY2hpZXE0ZVMyd2w0MERqUjhvUFpVNHFcclxuICBqMUJwMUk0Zm80c1g4UTUycmEvM3JXK2lpMk5MMUw1dXQ5emR6WTROeUlVL3gzZlpXTzRFM1ZQSUE5MVlxQmhsYVpDWk1YRittTGFMXHJcbiAgd1Zib3dUZnloVG5KZDlTNEdNVmg4RTYwa2tLbHp6c1R4NkcwVmxhT1p6cVNKelpNb3dLU0J4V1pidUl5YUlYVVNlMXJkbXYzRkxja1xyXG4gIDRGeFJQbFN3YnZZTkhCNVdHSGJqSUdpQm9Hc05MVDdZb3ZKRUJkMitkcGNzd0Nqak9qSWR1bzlPUGY3UC9ua2V0RUR3UE05NHEzWTdcclxuICBZbXF4NUpFSm1QVEFtZktlT1NCbVd6Z0xHZWZnL2NCcFFRNUhqUWtWV05nUTZhUzgrTjJzUTRzRU01L3c3STg0Rjg0TFpVV0xhcFo1XHJcbiAgM04walAzUVhRUWQ1MjVwZDB0MkVSUk54elBDU01kaklxc1hNNjNIVUdQdVJqOFhnVldiSDIyVHk0WGpML0JOMDVNaFI1dmd1bjMvWlxyXG4gIHJiZmRKc2NCVC96RHBtL25iWWtqd2UvRmJLd3VicEhDa2N6eFRRV09MMmpPbUozZlRlSkk2cHBhK0JwcHNmM2ozd0lwZTFlQWNEeHNcclxuICBWR0N5R2o1R2pUUjU1bW5DVzByeDMrTUdEQTRYNTBZek80cG1iblU0ZTdTRzNVT0pjR1Q0VDdFdnBNTWdQTkxDQm1OV1V3TW4yWTViXHJcbiAgK2JMalNxaHNnQ0tyUmQ3dS9Jbjk5UDNmOUdaNWdCQU80TS8vOGgvbFljRXpKL3ZwSzc5S2wzWmZEaGluZVBUUi9SWEhROTd3K2h2cFxyXG4gIHZkLzdpM1RycTYraURSdkMrR3NsM1BMcWErbnVleDZrQ3dNamRPV09EZFRSMmNHT0dyVjdkY0RadnlJZ1FaeTlPMXpxUExheDg3QlZcclxuICBReGx5T3Zqam1SN1loQ3RnNUJ6S3BJa1JuWHBtbHJWbGkwUlVicThVYnlPVEc5Z0gzdnZwVDlMSTZBaWRPMytPLzdoeDZ1em9sSmJIXHJcbiAgSTZlRElRYVVhMnI0aUlnSXptSlErOXFObDI0cnJqUUEwRzdWV0l4MUlMaTdOclE2QUYxcEZKSWFtdWcvd0pYRmJuMjJRODVRdlpna1xyXG4gIGptallvaktTQ3Ryc2xPZTc2eVp0SmRYVzEwdG9hOE5GVE5JMWdZc0krNGV6d0RNY2VGSWM4KzFkWHBnSTBOS256MnFnM3h2UGMvVHVcclxuICBlbzNNc3gvbVNnU09vNDByUjZ6RmxUZ05wQWNmeVhDTVBDL0hTMm01MHhZWlY0N3NQRkVob0lKZGMrV2JaS1lOQnByaE1PUmRLSmJIXHJcbiAgNU1YallqL0JGU2NjR2RKUHNSMTBXS1lEUEdKTVc4VWJOZUZVZE4vWUx4OVhyclRsd1VUK3paTVhqNGgrZEZSZlp3dGdFUDFjM3pza1xyXG4gIG42b0M4dWFBZkthR1Rnck5OU3ZyYXFpRHk0SHVLWFFUdFhIRktzdUk0SGR3T3NoQjR3YmkvRE9mNUZZZk8wbTI0UjhydjYraHBVZWNcclxuICBnOXZQOE9rbkpZOExCKzZtTlZlOVJSejJ3S0g3eGFGZ3FTSFlvS1dHR09uZGZ2eHZsemdFc1hFeWxKbGplWE1tMDNVNFh6ai9SdytQXHJcbiAgaWFQdDIzMjcvUGVEUjgyUjdJSWplWWlkdytlNU5iVlR4c053WGtucmlmUEJZbzk0RmdpdkNZYnpRMHNKK2N0WmkvTlQ5b2VZZVhINFxyXG4gIHhuUHdOZ2pJVk9oYWF0dDRyWng3VStkMXNnTzZWOUV5UW1zWWRyREd1Qkxzc2FZWVdvNElLQTlhSlFDNnRPQnMwUnBCRnhadTF0ejdcclxuICAxeVdEaXJEeWxBSEZkRVJrTjhjM0pqRSsvaSsvTDJQRWYveW4vMEMvODl0L3FjSXFnQ1ZPZnYwM0tqOGI4cjgvOEJQMG5tOTduM0hWXHJcbiAgNFFPLy9WUDB1Ly83UTdSbTgwWjYrS0duNkpFSHEzK1hPdjlyMVFHSEE4WnhBbmVJZ3ZQUUI4dUFjUGd5RUVXc3pkUHhOb0I1RSttcFxyXG4gIFloQXlieXZubmtlNXZWS0pzZURRb1VNME5URkhMVzBOZkk3elhXRmpvemlQUXhNNjh3TkF0NVVzYkdoNXdrSGdEaE04SEFsYUZCMXJcclxuICArZTZUWXdRZExOZkJVandVcU9NZE5iN0xDbmRNQVByY0ovcWZwZmIxVjNGZW5KbjlHSGRSeWU5M2N2QWl3d1dJZjhmeDBQR0YzTlBEXHJcbiAgRlFGWENIVjhGOGZoVS9mZkx4VW43dWpnT0RRUHREalExYkJKN3RxeEdKODhGYzUzbUdoeGlPUFkrUnJKRTA4L1k1Wkw3NjdiNVluelxyXG4gIHVESnl0RmJVcUx5MHdoZTlWQmhsRlZxZE9BN2NYZGZVMVhzWjdneHhsd2lIZ1VvUzZjUUd2NDhyV2JSSTBHMkZWZ24yandvWk5xaWtcclxuICBVWm0zY1l4RkF1WEpZS21zdFRXQWJqamN2V0kvNjY1NUIvV05QZVFYd1VRWFpWZFhsL3hIY1VENWNMZU4vUUk0ZGtGL1dBSmFuVkkyXHJcbiAgRGhqb1JWbkdNWWJCKytuY2RCMmZDM3RsbjVDamZKaE1BUWVEQitsUVpreVZ4akVhT1BTQWRBUGlnVXJ3YUMyaUNZbkpDUEs3MTJJbVxyXG4gIFhSMWRlUFl1V3JYdkRWSWhPaGtlQnJ4d0VNdXgxTEV6dVZmMmh6eGlSd0ZkT1BZYVVFYkVtR1hvVmlmR3pVZnY3dGZKZWVIMGZmeS9cclxuICBpeU01OHFDY0Q5b2llVWk2a2ZDTUNSd0pnc3NYclRkTnE4Y0Z6NTZnMVlpMDRGbVo2S1gxS0E1RmVaRWhBQkxYVU92YWZld1FzRnkvXHJcbiAgeXVGSXhpL2cyUWZNNGxvcjNWdlFvNldCYXdxdEViUlMzSEx3ZU1vZGdMTkhtcHdUc2QyVm80SUJxMXh4d1Z5eGRwNTI3dGhFNi9ib1xyXG4gIHhCaGc1ODdOZFBUNWo4bUwrMzdvaDMrWlB2T1p4MVJSQmZCY0NBYlZ5NER1cTNkOTNWdnBsMzc1ajB5eVBLNitlaGQ5MjdkOERmMjdcclxuICByL2xCdXUyMU4wcDlVUzN3VTFIL1Z3U01FT0pzM1RFSzNWWlJQeWNESjBoZ2paQklOSWE4alptNGpZSHBpUFU1NU93QW5IUkdDcEtFXHJcbiAgYmlOSXFNaXNiLzY0ckt3N1BxRXZ2K3JwN3FGcnJybUdEZ3lGS1lEb2YyN3V4R3drdnNPWTRydTAwWDYraU5IbG9jNERRTXREV2lBZFxyXG4gIGEyWHdHNUQrV1Q3SnNidkZoUVd1ZUE0bFhWWVlvSzZyYTdKM2RiQk14UHFiOUppcW5jcEFPNW5HYXFONjNJMXRiemxIVHo3eE9FM1BcclxuICBMbkNGWDBjYlZxK2w2VlczU0dVSVI0STMzK0Z1RVJjN25ranVrbjcyT2hrSVIzNXdKSGhIT3JxeGNMZUhmSFcvSUhXL2NUbDAvMUZRXHJcbiAgaWFjbkJyamluQjZucnMzWDhXOC9LZzZobGUvQU1mNENSNEN1TUhUaHdCN2RZNmlnMFFMQmRHSUEzVHJEWEdHQmIyZW5BajNlQkljeFxyXG4gIGdyWFh2RTBxa2c1MkxBQmVad3NuYys3cGYySGRsOU9FTFIyamtGSkpoQkx1LzVBK0lUdzN0MEQ3OXUyaDVodi9rL0FyUlJnZ2poRUpcclxuICBtTVR5L0VEN21qMDBCcHBsMGpKaEFtV21wU1Z4UmhjTzNFVnJybjZiOE9lZS9sZGFlL1dkZkQ0ZDVuUTdKRWRaZjR3ZENod2tiQ0E3XHJcbiAgdi84VDBub0Q4UHdPQnVGWDczdVRPQnM0WWZ5ZnNrTzJkekVveHgvNzVHL1E5TlFVTmZBTjB4V3ZleGROTjZIRmJQWmlhelFvanVBTVxyXG4gIDBPcW9yVzlnWHVWaVovVFFFVjJNRVYxWjBrcGhPWjUweCtyTHN1UTV6QzJOTVJLSHZDTGVhQUh6NDl3aXErZHJTMis4ZE5ZV2FJeDlcclxuICB6RTRPeWV3cm1jWEZ0bTV3ZlpTZGliUm9NVzdIa0tmYTdRbDNjVG9kMFV3bjIxVmxWREJpMWJyR2MvU20xMTFKdi9KTFAyVENnRC80XHJcbiAgdzcrajcvNmVuNlhHaG5xNmVPRXo4czZlYW9DcHZmZHlxTFRvNHA0ci9oM2QvWW4vVFpzMnVlN3l5aGdibTZETzNsdnBpVWYvVGw1dVxyXG4gIE5YaGhnSHBYYTg5SkplQjJxdUlZaUY3Mnl6Z1BUSkVUb1dxMEVoR1M0UWttclRJUnhEYUFNbExQSklyVUxzNUJ5Ynh0a0VRNklZczBcclxuICBURVZtbUs2TDFnZWNCMlpicmVwYlJUdDI3S0RENCtFcGN3d291NmZMeFZsZ3VZSSt2akNaeDVQbXVFalJQWVRuS25RZ0hldENvV1doXHJcbiAgQSszWUhaNFhtSnNha2twUUM0Qm5RL2dFNW1OWjE4eU9TdTdDSU9aZkxNY052Tm81bWZBU29qczQ0M0dob0N2b0lyZWVweThlb29ZV1xyXG4gIDNObHpHV2JtcUdQSDdkTDFob2Y2Y0tlTXJpcmM3YUw3RE12dzQvZkpzeG90WGRMaTZOaDBqZHpadWJ0SzNaL2JaOHd6alR0MGRFdEVcclxuICBza20rMDBOTEFIYm83c0JLcjR0Y2djaHY1enh3QjQwN1lwUVhZMG00UzBiM21NNW8weTRuSnZqWXJaTFdVR1BiS3RtSGptZnM1bkoyXHJcbiAgeWwzNithYy94bmZCdDBrbDdHYXdvWXh3R21oRllxYU9sRW51dmtNWjF3OStoQTRleERMenZCdkc5dTNiYUhIVmpWTGU4dUNPZFJwY1xyXG4gIG51Ny9rSStYYVVEWENjckhqSlFKZzdxd25XRG53TGxJSytuOE01OWdwL2QybGZQdmgxT2Q0L09uQTYwUnZoclA3Lys0ZE1mZ1AyeHFcclxuICA3eFZuTE9NOG5BSE9UVGhtdEpKVzczMmo1SUZ1TWp6SGdVVTNNZGFDVlg3aHVKR1hLMmZMNlkvS3F0TElCQzN1dHQxdnRmS2pWUGI3XHJcbiAgSW42ZWo3K3N0V1VQRXNZNmw2ZDdXZFlzWHdzb3U3d0FpM1dZeW94WDI0NmNmRnhXTDBBcXlBWFlsY1dPQWFsNUc1aHV4QUtrODdOOFxyXG4gIG84SC9kOGM2YVhIb3VJaU9RV0pjUkZaKzRCczVQQ01DSjRUblNERGVoMEY1R1V0QkMwWEdSVEFBMzhybjVvRFk2ajRzVkVRRkExYk5cclxuICBjRm5lK2RicjZZWmIzUHRXQW02ODRVcDYvSW1EOU95emgrbmpIN3VmdnZPNzNtV2F5bkRQaDJEUFpjOXdYSHZOYnZwUC8vblg2RnZlXHJcbiAgODVVbXFZeW1wa2JhdUdFTi9lcXYvWWs4WE5qQ3p1eml1UXZVMmw3cHVSbWNQUldBQXNJZ05uSzBPSStlTFFYT3c1TXBXRllrVmxqYVxyXG4gIDBzUUtuSkFlSmJaQlVwNVBBTnRFWnJ1N1J1alE0ZWQ4eXdOMTRlWXRHK240TktiU0tqRHJCMzNWU09kYUdycXN1dktvckpBbHVxeGtcclxuICBUUjR3L01Pd2lHRGNaUVhJUUR2QWVqemZJUmVFMllOd0Y2RmNPSW5NS2pDT3BWTGlqMVJxektQVmdTZDN1N2pTUjk4MUxrNzRvb1dGXHJcbiAgUlpxZm1xZXBxVW01RzhNQUtOTGlya3NYS2NTWXh4bHhmbmpZRDQ0RGQ3ZTl1MTZyKzBEK2lLM3JJKzBTTVo3dGMxMGtIR01xN09vclxyXG4gIDN5d09BbnozbGh1MDY0a3ZMclFRY0dldHppU2tsKzR4cG5uRGQ5UjNpak5EUlNyZFFPYWcycm1pSGIvSWxhN3RhOTIxWHlFeDNsQW5cclxuICBaY0grSlNCZkY0eVhvSG9zU2djc0xtTGRwMXBxYm00T3RxWEI1ZWVDeWVOOUp2dkZNZEhqa2g0clo2dmxic2ZiOVppVzM4SjZ2QU1kXHJcbiAgLzYvWVlaa1J0a1dyQW80VFRnQ1ZNcnJud01QcG9GV0QvTkhhV0p5YmtUd1daaWJwUE1aTitEamlOYnlZeVliL0ExMkRyZ3hJZzNYQVxyXG4gIFptZG03TUZUak9HZ25Qb2ZhRG5OMW1MTUtzT1NLY05jRGlkM09yUk0wTFVGR3ROOThSWkU2T0RVY0E1amdzSG9xYWVreXcxTHNrczZcclxuICArWjE2bmpQQlcrUVZlSkVobHBzckRmVmNobzZOMTlJY3hrR1kxM0dSYTJReFNCWklGN0tPZjNCYS9pMnVKWUl4TmN3d0JQVFpFVHpoXHJcbiAgemhVcFg4dHdJc0k0UkdReHlnMHdwdlNHbTEyck40OS8rUHZmb3F1dTJVT1BQbjZBZnVTSC9ydEpsd2RhSHovK0UvL0R1RHpRbFhYalxyXG4gIGpWZlJQM3o0a3laWkh0LzVIVjlIaDQrY0ZPY0VyRnFyWGVxVmdGOWUyQWFEZ2srSDVOQ0FoN0U2ajgzVTJJMitVV2lDRmY3MndCcGhcclxuICBOckZWWUpRd0U3Y3hNRzFzbkZySjJBN0F5V1drb054ZUtkNUdKdDNOaXpSNDdCRWFHc0pzSkxtZTVIMFF0OTEyR3oxK1J1ZHJvd1VoXHJcbiAgTFE4RzNzbUFhYmVOZlBjSXdIbmdUZ2ZsMU9kQnRIc0xBK1VnY0tlSkdPKzhFTWNDSlFPRGVYZ3dNSXgzUUlyZm92cHdBWWtVQXVQQlxyXG4gIEJSNTJlTmlyZSt2MXN2L0cxbTdwbDhZRk8vVDBQL0x2cVpVKzE4VzVSWHI3bDk5Sm4zbCtuRzF2NG9zWHIwS3RaY2ZoWGxLa1hWYzZcclxuICBpOHlWSThRaWkvYXJKRGFvUEZTSGk3ZXVvVlZhWGxoU0FuZS91UE1GNG54TUlHa2NEZDM0aGNNMHlhMElUQ0JBeFRoKy9ubXFyVzhXXHJcbiAgeDRhVFQvZUhJSW13a2RobjZXUmU3MnlBWUtmZ0Z0Q0R2MElIRGp3bjhvYUdlbnJ0YTE5THc1dGZtRGUzNmNXVnZjU1k5eUt6a01nSlxyXG4gIG5kNTBHVjVYTk9iekV3UHVMRHIzMUVmWkNiOU5XbDdvbnNGZE43cXYxbDUxSjF0cDl3L0dhT1M1RTZaZGZ1ald3Z3pDMVZmY0lmSm5cclxuICBQdncrUGdaY0tkZlhTNnU3ZHMrN3pCYjcxWHdrSVdLZmo4b0duNzlmVkQyN1hrTURoejdETXBJeEVYMTc0czNlRG5sZ3RXQThiNlQvXHJcbiAgaSthQm14ZDBPZWs3U2NSUzVFNnZQTE5lamdoeGtHTWhSYlJDbkI0T0FpMEw2REdXaGdkaVZhNExOUUpvcVhkdXVFS3k4RysxWkVhN1xyXG4gIHMxd1hqdVluaU1oaUJJTk5qUmZvb1FjZnBFT2YrUUR0dkVVZjFpeERaOCtyYVhKOGt2NzJiMzZEdnVhZGJ6RnBaVHo5OVBQMFAzN3JcclxuICBMK2lQL3VEOUpzbGpwZTlTeDR5c24vNlovMFgzMy9jWEpxa00rSVFFN25LcjZEelljWWp6eUVBdVhKOG9UdTB2YVVac294QTJiQXg1XHJcbiAgTzBIT0RzaFhDaDRaZTZWNEc1a0FNeGVmbzhGQmRSNEFsckxBc3dCNTU4RVZIRmRvYUUwRTU2RXI2ZUpYNHVueE11ZUJkYUZrM0FSS1xyXG4gIHMrVjd6M1N3bklPclpPTTR0RHBpWGdNdUNJeko0T0pENndOUGg5YzF0WXZ6UVBjQjduYm51UVZDODNpZlFoMzFuenN2TTJQMHBVeGJcclxuICB1R0xlTExROFNkNjNWWUxjSmVPdTBBTDJFOSt0aWx4aTNGWFh5eUR6eFFQM2loMjZBdERhd01VSXg0SHVGQW5jNHNCc0l6eGpvT24xXHJcbiAgemh0cE1LaU1iaG5jWGVPdWNkWGVPNlRTUTBYWXNYYWZ6UGVYTy9VNkM3WnZuNDh2cjlIQ285dk9iRVN1T3Q1WTRMSnpQRGs1eVhvK1xyXG4gIHRBeE1PaGpaK3MxbXUxeXcvY2krbUVkK0xFOWJHZ2lxMDNLWXJlbGNHWUpkckRlZDR5MFBqSmxoUWdab0hLTjExNzZEQnJrVmdOYnZcclxuICB4TGxETWtsQXhsUTREYWFONDVpanBYZittYnQ4Zm5BZVdHWmp6WlZ2a2FualRjYy9MSk1JWkZydXdqelY3ZnQ2TFQvc09kWjBJWGdkXHJcbiAgYUE0WWJPL2Q4MXFtTVVQcmRnNnZvZUdUajFQdnpsZXpTTTlyQkp5VFRIQVNOMW1DeThnM1BGTXNsOVdCSlQrYzMzcWV3MVo1MkFZZVxyXG4gIGNad3ZBbDVyTzNiNmFhOUhhd1FMS1lMSEs3a3hJd3VBazVFMTJoam93aDA5OHl4eWxmTlZXaXZNcEMwUkJFTkVGaU1ZOVBmM3l3RDZcclxuICBoaXY0K2w0Rzk5NzFKNFJIZmQvOTdoL21la2hieE12aDZxdDMwNWJONjN5TEFWQ25HbkQzSjM2ZnZ1cXJxMXNCR0xqamphK1dsbmljXHJcbiAgWnlYd0dSckdRTnhQaHpBK1R2eVhwczdEbmpCWEk3VlVNazVsTkVmNCt6MEtiRlNVa1Vkc210NXZER29iSkpGT3lLeUd0NUVKMEROM1xyXG4gIG1JNGUxU2VaM2NLRFc3ZHVvUXMxT2xzamRSNzZmbklNR2dJNHlhU3ZIVG9iLzBEK09tVjNxMVNtRUtDbElSVXp3RDhZczZ6d3puQU1cclxuICBBTXNCa0lDdjB1N2lTQytTY01FNkhSd0ducy9BR2xYb3NzS3pBTGhJTWFhQkN3SnJGelgvLzdTZEI0QWZSZlg0My9WZVV1NlNYSExwXHJcbiAgQ1FrSkpZVkFRdWdkNlNJb3FJZ29SWm9GVWV5Q0ZiRWdBaXFnSW9LQWdOSjdTV2dCa2tCSUliMjNLN203bE92dC96N3Y3WHkvZXlYRlxyXG4gIC93L2YzWDZuN016czdPN3NlL1BLdkduWkt2WDFUWHF0TkJQUjVPWGt5cTZPZk1udDc1c3p1ZCtxWWFiQWppT0djQzFIWGxFODVFZDVcclxuICBpQ1lRNnpIelJSRU9rVUI4MHRibW5sMGhyRmxGZzRTOVRFQmlXc2x0OXJVK0lpa3N2b2l6Qnp3aXFhQ25TTTNJdER3VCs0VStJYnJTXHJcbiAgT0cxWVgweVV4YUhsQ2EyY253TXgyN2xJM09YbHdwRnE3NGZaS1I0QTZ0YThKWTJOVFpvdk1uandZR25PR0dpVEFwdWxhaWFMRXBuZFxyXG4gIEIydTZjR0NCQjJkRS81a2hNemFZTkRBMkdxclg2ejNyTThqSU1TSkl2dTNua3RjbmVzZCtINkUvNU1YN3FJMUc1OE81Nk42c2JsUk9cclxuICB5NWlKdU1aNWYrU2hYOEZvb08rb3cyVDd1dm1DdDlxZ2E0S284eEhURnU4THF5VE1odUZXMTgxN3l0WTYwVDRtdkIxNnoraW1qR3V4XHJcbiAgYS9rMU9jL2gxNC82RXYxMUw1ZWo3ejNFK1dOclhqZ2VKanJrQXBpSEZ5cEJaTndDNU5ldHc3dXNja0k2cHFsSHV3WkVvekFrdXFlelxyXG4gIGlrcWxmdU1pdzFVUVNGLzdzZFRlWlhwbXZ0NFRKdHp1aUpIRmg0UVcxMmZCdUtROFJJVFFkU0x1b05IQkx1UkJGTzBkL0dTVGZnczNcclxuICBYdjhabVRaejc5dlBEaHBVWXM1WlgzN3RYWG5weFRmbDBuM1VoK0QvNnVKTHZwZHdpdWpQT3dramhwZkpuKy82ajRZRDk5bm4xZWhSXHJcbiAgNVhMVnRUK1RyMXorNlNobjk2Q2oxQ0U4RTRoSEhDalFLL0V3aUhlMmw3Z0ZleTRULyswTmJBQUZzR2k4ck1iOVA0TFlPWXYyZXFZTFxyXG4gIERNbmNMSnMyYlRDaW9ST3d5RFg3U0tuTGRFc2VKeDVZWnFRa2lFZG96SkZNSUI3TDlCd0lVZ3paMkF6UkNqcm5ZY2dJMEJmY3BnTVVcclxuICBWOXYrWWVpaElTL2V5a2VocHgySlVDWitIdVFERWtCSmora255bVM0RU51UFE0bUltMTM2Yk05OFUrWG11UjZrcVYxYUdscWx1YWxKXHJcbiAgRWM3UVBYSWNka1I1ZHIwUWowSXphOVZybUY1RFExZUVwOW5LNUladGE2UkZPYUxLajE2eXNpaTVJUmFZdEpJMlRrUFRQRXRtejY3WFxyXG4gIG9OMW94aDNGS1p1WWhaTVhYZHZ6UXp4Tjc0MTBWTjdxNmFIbmR5cVJZTHZXblZzUlR5blJJTlJ5dkN0bW5oQVArdDdZNkh2M013YUtcclxuICBpb3J0bk8xTkhsMFRpNTFDUmNUaytUSEJEbGJyaDM2Z0ZNYmloN3EyZjRzKzhJNjJScDNkcjdNOHJzUENUVE01MWpvUXNGMWJWOWc2XHJcbiAgaVpxVmIxdS9hS2NMUjJMM2s0eDdmdXcrTmQveW9uZ29HM1JCZllaUFUyTHluRjJ2Y3RIek5pNHhCYTVZOG9KWmEyRzFCbmZTVUx2UlxyXG4gIHVEQXNyL2pTUzBwS2pETXAzZjk0TXduZXR2ejEyTFg4R29uK1JFZDgvSVI4ZERRY3hHdlFxZW0xaTRZY21DaUQyRW9qVVJ6ZGlOWlJcclxuICA0c0czQStkTWZ6WFR4ajNQejh1U292MTRPam9mNWVXWEgyaGJyWnA0VnZNd0RzSExMOFh6K2tNNGZkOE0zaGRFeE9QT2lRQVFFdU9VXHJcbiAgdER6Zk45K1pKUXhDcUJDTDlnU2RKTmJYeTFGVEhZL3NDM3ozTzVmS2pCa0h5L3dGeStUNjYyK0pjdmNPRHo3d0svbVVjaTY3ZzZlZVxyXG4gICtKMWM5NjFibzlUZWdmMUYrdmNyM2ljdWhPZjhJNTREaDc3V0xrQTZFSStNNHNHU1pjUWplbW9XZUp3WEdMSmpFWTNhbVFoNmxySGZcclxuICA1RThFR28rUzhkb2VqWmNER0RoUjFHRDM1VDJtdjdFaWhkbWRVckZ1aWIzb29QY29MVlgyTnNmTit0eFRLdXMrOUlQdmhYZ0VwYmdUXHJcbiAgRDVTZktUYlR0TVZ0V2dldWd3VmtpY1dCZXA2dFpuUHdaMlFkOTd6RTRDZk9YeXdkUHNhUUpnN1hnUldKT1Q5VWdwR2xyTHR0V2FxRFxyXG4gIG5nOFByaUN2L3pEalF1QXVodmZwbFBVYk45bDdCRnJaZzd4Z2NBL0NrVUFJY1FUUkRWbEFPSmpaWWMxQ0hPNkRXU3lMQU5tbkhlc3VcclxuICBPQTIzVXRQWnJNN1NXWE9TcWpOeE9CUjdacHJQck55dFkvS2phL2k5T2FJS2NRMDVGK1ZweE10cDJqaU9xQXpuY0xPUEdUSVdUQkFHXHJcbiAgeElNZ2lHMHJYcGYrK3gycDU1ZTVYeVF0R3pnSTJrdGIrMi9iOWhmZ0V2bVR2bWp2a0hVRDFuNTBNQWxBenhYcTBqNnpmMGZvOU1VUFxyXG4gIFpyc2FTUnltb01Wb3d0cEJxZXVpSnhadDd0aUl6bXFLclFmQktnK09hT3NIVDloNDRSNFF0V2lyVnBlMnJDL1IrUEQ4Ym5tVVM1ejNcclxuICA2ekZtUXdneTVEd1RIVXlBeVlOYjdGUDlzcXhmdDg3TXlqTXlsV3ZNU0RlQ0FwZUNHQWl4SzNvTjQwaEtzZHpTYXlldTB5MGVoZnlaXHJcbiAgQzNrTU5FS2NpWTNHS2NQS2Rsem1RSmhwZ1VrR3MzM1d4V0RlaXk0TzR3c3Q2a0MxcUc0eUhRRVJ1MjRVMXg4NGU3d00xRzlhSkpuNlxyXG4gIGZYQWZtUGt5RHZrK2NiaklPKzZORXlIRWlJTm5oS0dBY3pINlB1ejVlZnNKaUVYalVOSzVRYkl5T3VXNjZ5K1JUT1g0OXhYT1ArOWtcclxuICBXOFB4OXRzZnlORkg3cHVuM1B6OFhMUGtvaXU5bGNmbjF1Yk5WYkowNlJxWk9uWHY0alFBVi9KZnV1eUhjczFWRjBZNXZRT3ZvOU9IXHJcbiAgWFZjZ0x4Q1A5TUpCa2cyeUNhVXM4SGppTnpxVmlGaFdJbE1Uc1hpVTcxbmQ4bVBKUlAwZTVRQTkyeVdyUzhYd1krQXgvWTBWSVpHMVxyXG4gIC9RT3BWT1RSNW40R3BXK2ZRbk5oc1hSN0gwWFFEUW54RXpvUHhDc0JBdkhnWEgwWDRnRlNJZCtKQjBnbVNUeTBIb281bEhva0xJOTdcclxuICA4SkMwZjRSRWsybENTOXM1NVNyZ05JcWNjSEFLczBqV29BVGlRQmtVNHVhTFMwUDZrcjcyQ1ZtNWNyVms1V1Vvc3Vxd1djUGdZNi96XHJcbiAgTm1QWDhPc1RkK1NUeU5jL0xLWkkrM29ORnVWcFhCRU1NOWhTbExXYXhuVzJMOUxTOGxXc1Z4aHRNMkFXOUtIWHdPUVVLeUJIYXRHb1xyXG4gIDR6TDJ3L1dUY1EvaWVRVFdPeUlXQm1zMjBvaHFUSmF0WlhqbWxOaXgxV2VVUUtGeWZDQUtEeitLWnB4TFpOTnJ2emIzRUJrWmFiWUdcclxuICBaT0s1TjdzQlFRTDBTdEhsQVRoU2pDZHN5OTRZbUpJM0F0cE5nTEkxNFZvQUNCTUlhWnNkYTl6eXRRbmI3NEw4Z2VPc243N0liYWtoXHJcbiAgTWN4ZTBRVzVtRnQvUXFoSElpK1czMTNKVEhycmgwOGI5d2x4WmNjODhwczJ2aXZiNjJydCtXWmtaTXFoaHg0cWRRTlBNMDRSd0dMTFxyXG4gIEZsSHFIMXdsRjBQeGJ1MTNvalNNcmhWZHI3YzRuZ0tZVFBVWmhaTDlEWnM0c0s3SVhPSXJ3S0dndTZNOGU0endEcXl1dG9FVkYvN0FcclxuICBhTWVPMEs2R3BJbUZmRThUV3FZZHV6WXNsTHdoRXkySmlEVXRQY2UrdytEdGwvSXNQbVJzQUluM0VjVnQ0cUd3Yy9OU2V4OVI0eEhFXHJcbiAgNHJGbzY2WjM1Q2ZYbnkrWFh2dkZLR2ZmNGNtblhwTXp6cjVhRUpLM3RDNzB6SDJBdlcxQTFYL0FzVkpkOFVxVTJqdlEzbzkrOEJYalxyXG4gIFNIWUh6TzNpMzRkQkYrSlJvRE1RSXg1eGlOZUlmMkJSeElKdVpSTGc4Zmh2QW1MSmdDcDZCejNYNVhTWGl1SEh3R1A2R3l1U2xkNHBcclxuICB4UzNMWk9OR1JielJTeS9JejdFdGFTRWVKZ09OaUFlemJQYm1DTEN2eEFNdzRnRUcxSCtzaXN4Q3hEcWlkeGVRTkllbHVXUFMva1lTXHJcbiAgNThpUHpxRW9oK3VBTlVkbURMZUJsMWlJQ09mWmk4TVcvbTJIZUpTYkFwV3kvZnI2NnZtTzlnN3AxRmttSDUvUCt2VmE5Q09LMjVFUVxyXG4gIHBTVHo4WGpLK2czNllhYTNTaEJRaWlOdXdmb0hna0k1NU9hSXBsQ0V3MkhRRnM4SHBFdDd1QThCTVpKdjdkc1JpV1FZaWJGNE9KSWlcclxuICBuVFRaK3Y3akpvYUM0ME04VmFBZlB6b0l4RWtRRS9vRVFpQytVNTgzY2EwcytmMUhHZ2ZCN252aC9yQzRJV3hxOHIxZEFqQnhZSk1wXHJcbiAgeEhHTlN1eDJWSHhraEdobmRMQ0dCUkZkU0hPT0k0ak9RUGEwMjZrY0JpRm0xRnc3UEV2dWhRTXpaa0x5T0t5ZTNXK3EzUmYzeDMzUlxyXG4gIEpxNDY0Qlp4Z01uekNPS3ZaSnQ2N1NnZW5xZTFiWGwrTHFRSEhYUzZpWkZJRHp6b0V5YnV3bVJYTXlROVBVTUtDdkpsZVkyYk1mTnVcclxuICBTeWVlSkZVNlNhaGUrcXBoQ3hOdFRUakJYT2V6dHFmTHV3elg2U1hPcG1kOXg4elVlSXIwMDVDRnBPUlRIOTBJSzlvWnU0d3hpQ1FUXHJcbiAgSU9MNDFBcFdYSENZbW1tSGZSL2FaN3NHZjRtMHBaSnBQUkJwdFNHRzBxUk5jRFRFMnpRRURHL0psQzhzbTlpTE9NczlDZ1NSRnliV1xyXG4gIGlFTzkzUUN4ZUN5SzY2UGpwanNSK20vaDlOT09sbXV2dnRDVTZpZnNZZFY1ZC9qSmpkZklqMjY4dytKNFZxaXQ3YXFNZi9UaFcrVEVcclxuICBreStQVW51SG0zNTh0WHo1OGoyN1NrUUEwQVgwdFNlSlIxNS8yOFBjSVNyWi9Ya2wwdkdXZUNVQk5OYXRqUDBtQzBTUXpJalg3cld3XHJcbiAgSnVPbEU5Q3RyTWYwTjFZRXlHL2JhQTdqQUl5VGNyTGRQZnU2bGpMYnhOLzFGUkNGR21XemNTNFdXV0w5RjhURDJyREJMQ2EyeXROWlxyXG4gIHR3RjVPdWdKN2RBU0RIWWI4TkVSRUFEdEVZZnJjT0l4V0pxVXVJVjFHMWl2MEI5ZnY2RmNoeElPaUFmbitTakQ1azJOaWlRaGtMZ29cclxuICBTTStKVmd4cmZmdUFDZlhBekJka0U4K3ZaNTJBaHNXc0dqZkM0ZTVFUUNST09OeE5CNFBGM0lqUWppSkd1STJTOGNmWU9kWTI5R2N0XHJcbiAgQ2ZVMDdRZ3VRbkloTDdxZTVlRkdnWFNFNkszTjZQemdLWiswYzN6c0hNam1PenJhckEyYytYWHFESjIySUJRb1poMHBwMG05em56WlxyXG4gIGZHdUhwakVyUnZ6RmdyTmRpakI0QTBDWVNMQitCdEVhNWRCUElBb3FHbnlBSWhzL01DM09WV0lhMHVhalM4dFFubWRQL1NLZDdlSTRcclxuICBrSGZhb3NnZnNRbHhDSk1SRSsxdlozdWJoY2w3OTJmUFlXSXdiVFVRRlRoT1JJT21sOUh6dTdRTjRoREtpc1V2V2wwN0RKbnJZYytPXHJcbiAgdzYzUW5NQkU2YWlNcDlNa2ZmbmZJeDJRdTI0ZmQvRGhwcGVDKzZoWTRtMFBtSGlLcllpdld2SnloTVRUYkUwSkhneXNyWGk3SEltNFxyXG4gIDM1dG1hSmdjMTNnMlFEZEN2R2JWSEhPTG95ZHR6RUpFV3BWVHRRbFEzUmJwTXhJckxsOVhBaUZCeDZjM0dMVkpHUDl1ZUp0UldzUEVcclxuICBONldRb2U4ZklrSUtrUzhSSm9wdzBVNUVJQnhkaVloWlpPa1pKb0pZY0RGdWNBT1BxTTBhU0VBc0hrWExCdmFWUVRIM0pmOHQvTzQzXHJcbiAgMzVhSkI0eVZWMmZQbGYvOGU5L1djaHgrK0NTN1BMb0xUTEg3OUNreTQ1QUFSeDAxV2Jsc1A3OHZNSFBtWkZ0Y3VLZnkrZ2FTUUNJUVxyXG4gIGo3U2NZc2txVllUQmlmQlVMSWppQnZGNEJKclZKYmVYSXA0WFA5RzlVZ1E5eWdFNk1LTFlubUIzWlNhV05ralYxazNDWGpuWjJlbVNcclxuICBybU85ckt4TUt0TkdHWnVPN0pQYU5tdFdBSmtBdHZxOE4rSmhzbkRQaHowR2tzUWp4WGJpeTQ5bXdwN1hjOUNIZ1cveHFGdzRaNHBFXHJcbiAgelRQaXNaMWREZ2RhaU5ralpjM2hJVnlIaWF4Y1I0VmxGUitsNzgyeFNkSUdUNWUrZmZzcVF2UWQ1dHJiTzJYd2psbGFOQ0N2NUFmSlxyXG4gIGdadHI1TjNXcndTQ2c2RDRDbCs0akZDZTJUaG10ZVpqU3A4SmN1dGR5bjM0QmxUZXJwZDE1SklrR2hHQ3NUUklSK05LUEJ3Qm9YTllcclxuICBKbHZnT1BSWmswZDYwL3YvMGQ2ek1LN1J5dlFaT2MzYjBHT0hJbFZiMEVsWmZlWndCeUR6WFNhT21DQ3QrdEZEQ0xTaXJheTNjUENCXHJcbiAgUmxTNVRSYlBZWUVYMm1PV0hnN3JhM1N3VWo0akN4OWczbi9jZURqUk9NQ2VEZTNTaDNDTlRvNjJWa1g0QjVvK2pmcmNDMFFHZC9nUVxyXG4gIE5hWnh3VnFzbzdYSjJ1TCt2TC9PMWJDckhTWXU5SUc5V0dpREdUUXVXaWk3Ulo4TmVpQjdqdG9PNWZRbjl2Nml0TVg5SUw1cXpRWnBcclxuICBVNnlDN2dOeDB1WU5QaEVZY0lCeUp3ZWNxb1RrZVZPNlc1NFNrWURRUTMwZkp6M2I5VGp2bStma1I0am42QmpCN0pjeWNDT01NeWNrXHJcbiAgTXl3UHF6QmZoS2djeUlZRk5pbnJxOFFxN0lab1lqTmVtaDcyUjF4RFMwZjU0ZURQNGhwQ1JGcU5pS1E0RVZFSVJBUlJGYVdjaUxqb1xyXG4gIEUxRWw1KzJlRklpYkJhRVdaREpwa1FUNE5ZQ2k1bFZ5L1ZmT2x0emlwTis4L3g5NDhQNWZHUmZ5cWZPK0pzM05MWjY1RjJDQlllQkNcclxuICBnTldyTjBwRmhVOXFnZHR1L2FhZXZ5dEs3UjBRWVYzNzlWOUVxWjdBZk0rVTZEeWlRRHhTOWVQUEdjaHNSeE1HVWNRQ2ovdUxzYWhDXHJcbiAgMS9PSmJHTGR5bmlSWkFtRFdEcGV1MGM1em5iSmlwZE4vQmg0VEg5alJValVWeTZYclZ2ZEhwd1oxK0RCQXlWbndEaHBhSFdFUUJtY1xyXG4gIHliVTIxWmxkT2NCZzhlMHpleUVlRWJlQ3pKOFY2b0Y0VUtkcDI3b1k4ZUNmajR1SUgwSFJ5Wm40d0NmT0gxd0hDTG05cWQ1bW9DZ2hcclxuICBXYlZMaUQ4cHVBNFFpM01nbU9RcUVWR09BM05jUkZlSVBZaTNwT1JLZnROYTIrOUMyRnRFQ1VoeGNaRzA5Wm1nMzNyeVkwZDhZMjBoXHJcbiAgR212Y2Jqb014RUsrZDRZN0tVeEp6ekNycjdDZkJ0d0d5a1VjQWpvbjVzcEl1NDhFTXVPK1FYNSt2NTcyL0VSYUQyYm5MRWlqVHBIT1xyXG4gIEFCSGhtT3NYVGJQNEVyTlRsS0h1TmlaRnRuendoQ256MlJTTHZtN0hoYmlXTFZUa2pIbTE2NXg0aHgybUxPWmE3cEtGY0tDVWJuM1lcclxuICAzTllFN3FPa3BMLzBPZUJzYTRQMjkzNzRmU1RTMFh2MGd6NlgydlVZUjM3TlVyUG9JNlFlM0c1S1o0cHhUTXhxUVZnWUlqQ3VzUHhxXHJcbiAgVXU0RlJTOXRrNWZKUGkxNmdGQlpSOEZ6M3Z6K1l5Ynk0aUROZFNBbW1CQ3pENGYyeFBxUzZGc1Vrazd0YkpNMWMvN0ZyWnZqeEx5OFxyXG4gIGZCbDR6TGRNTjFKZnVjTGVMZm9yVzBPeTZEbGI0RW1jTnVnVGY5d1BlcEVHNVVERFdoOU1mK05sTEs0UXJtdC9GaGVwWGZHbVRjenNcclxuICAvVVRsMElmMEczV1ltZkdpVjJOZEMzb1FpTFhwWW5UQ2dva3k0bHdETHVXeEtCN0xDTkhvQitWNnEzNVhadHlSbldlY0tPYlZiT1NGXHJcbiAgcFZaMjVGdkxQRVBvTjQrQkErY1poOFI1TDB3eUdlL0JLS0VyNkdTdmZhdjgvamZYL1ZmSzg5NmdwS1NQckZxMVFUNWN1RnplZkdPK1xyXG4gIFhMU1ArNWVqQU1kWDFzRUhqNVBTMHI1S1JEWklibTZPdVNzaC9laGpyeXBuMFhlZkZQU1VlZWpoNTZ6TjNzcWJDSXNqRUE4U09iYXdcclxuICBqUVFRUlN6d2VDemFEY0lRQURUV3JVenY5ZUkxWWlkN0s5Y2xyM3ZaWk5waitoc3JRbUpZemxiejlRUENVQTdQTEsveVNzWklWWU92XHJcbiAgVVBVS1NneXFWL2xNUjZHSDJFb0hNeDlHa25qNEJqcnBjR3poWTRmRmJXdFc0b0h5alg1d1owbEUwK1ZEMW8vYlBuRDd5Sk54M0ZNZ1xyXG4gIFAyZldIL3dKd1hYa0doRkpjaDBRQ2lNZWhQMGpseVRLZFppTGRZMTdlMm1TV2p4Q1d0dFR6S1VKME5URXVvZm92Q0p2WnBKWXdvUTRcclxuICBDNjl3ZkFqUm9ELzRtcUtzY3g5Nk42a1o5bUhUUDZ4VlFCcHN4UnZhOUJrd1JNTm5uVW1pNFlRYUt5Tm0wZVIzdExkWUdvSXhlT3E1XHJcbiAgU2p6aWhJMytwZmxNWGEvTE00ZXpvazFFU0p4dmE5eXBnN2RUU2cvQ0JUdlBGUTdpQUNVa2VwUWZvTThQcytiUUhuMXhrVXROVFkyTlxyXG4gIEFTQTlQVlgyMjg4dHBQNzd3Ky9KK2h5T2VMNGVtbW4zd2ZNbHpqazRqS0p5T0J3M2IyWG1UWjlCWGdVRHgwc3pwcTFheDdnb0xRdmhcclxuICBnSGc3TVYxazdkb3oxelpCaE5zM0xyQzhzaW5uMmtKUnU3YldyMTcrdWhGYlQzTjlub0gyWmNNTDlreFJFdmVmY0tvTVB1Z1U2OXVnXHJcbiAgZzA4M1hjbldoYzlLaFI3VUczQ2djeVM0UmVFZStDNXduVUljYm5QQWhKUE1tQUlkQ2VYSnQrc1JKN1RyZHN2VG85L1lJMDFNakZpTFxyXG4gIFBCWkVzaEFSc1MyT0dOR05rTjlYT1Irc0NsbGpnK05NbkRNeTlwQU02TVVTN1JGcUpQbDlhUmpTaEtTTkU5bFpZWG5PaWZnT25FdzhcclxuICBkdkJjeWRkdm1mZmdla3NIOGxqckJSU1c0UkhZSjZKMmpRakswcmJJSjA2ZUlmbDlYWEx4ZjRYNzd2MjVEQjR5d0VSWlA0MXhGbnNDXHJcbiAgbE43My92M3hLQ1hTdDIrUk9Vc004T1RqdjVHVFR0MzN4WVZ3SVhHdUpnNUdRQUx4U05WVVppN3lmbnZjM1NDZTAwdGNnNTUxQWlUTFxyXG4gIGRDMjFtMG85eWpra2MyTG51cFgxbVA3R2lnQ0RNemJhYkxPbHhWbEIzSFlQSFRaRUdscENRUS9OWERleXVFSlpHWWdIamc3ZEhYdFhcclxuICA0b0g1SmJNWkp4NUtjSlI0cEhTMlMxWmtzaGlJaFExZTR0M0RYczRoNXkwWU1OcENYMmVCdnNPSkI4cEZPSS9BZFhDdXFXNmpFUXhmXHJcbiAgVGI3Uk9BOXJLL1lSTnhRZkxMNVB0SFhibm9QbFY2OHpoQnpLMnFJekhRZDUyb1pHOUQrSkJKbUIwbDhJQnlhZWJnbzZPb0hFS0VNN1xyXG4gIDRXTzJkQXlKY3NEMTJmb0xMUWZCb0gxTWdCRXpwVVpsdlEwWDNXeWE5NWlKcEZqcmdRd2FWL2R3WDNCSVRpUU9OS1FMWndRM1ppSW5cclxuICBRNUI2UGV0VDh2cUd3Rm5zby9uOVZ0OWhIcGNoSEFDcnNOc25memRSdHNkaGJlM3A0RHJ4YTRVaklxU0p3NGxYdkcrYThMSlJPNlhqXHJcbiAgajdmemlJeklReHhHT1pBbDR3NVB5UVdJdDdSTXZZNVJGM0VWbWE0bHZDODRFL1FzMUc5dHFCRmMzUGkxL0R6SHBsVnU0Y09ZYmF1dlxyXG4gIFVrVFR4NjdyNVdLRVpGR1NrS1RuRmxvSUVVTjhocTZrMzZnWnlvVUVYVXlxeGwrMmtIMUxhTWROcmIxZER2cHQzd1h4S0E4bE8zbjlcclxuICB4eHhoZVV4aUVHbjVaRUhIdnhKVEYrTzVaMS9HUDl3WVRqZDl6VWIwRGNXK0owc1RSbmtXaTlJWnlvRW1pVWlwV2JpaGV6RUNycHdmXHJcbiAgNVl5SXNGQllpVWl3bW1PY0JzTEJEb2lNVFFmYVZacThZWU9NSGxSazhZOExacjN5TjhQUFA3cnBUaE8xN2d2RTNiNnp0bTJXRWlBM1xyXG4gIGxuRDQvbmUvTEhmZjgrOG90V2NJVmxpOTZVSlNBL0hJenM2VUlZTWoxNy8rTEJTaVNDSk5WQk85bm84VjZxVk0vRGNCc2FTLzNnRGRcclxuICB5bkcyZTlaL0JTbFNYVjB0ZFhXN0RGRUFPdFFsSlgrWUtQTnE1d0gwSG5IaVlhSXFQV2ZpZzRoZE5mdDhpSWRXZ1hnQWdYamc1Yk96XHJcbiAgdFZFeUl5K3k4Y0diU0JOR2VZa3dGbWQyaGI2RGo4aTVEdHc4Yk5hei9oR1oyeEVqSHVXbWRJVE5oMkNBVkNBaWJtV1MvREFEUXNscFxyXG4gIDM2N1JORk91OFQxRFFIelYrQ2hqeFNBY2NCeG1vcXZYWXRFZmVnMWI4S2NoN3NTeG9LTGRoSVdWenBJRFlyVHJSY2lITU14eVNhT2tcclxuICBSS3hDUGpzc2drQ3lsTHZhUEIvaXNOUkVFNkV1WWl4MEh4QTJQdWJ5YVovV1NVMWZpMk1DeXJPQ3F6RFhNVndyY1YyL2xpYXNmY0xrXHJcbiAgZVQybjk1N29ueDdjZjAxdHJjYjFZU2kwdExSNnZlallyalBSY0lUMmNCRWU4blpXNmt3MFhuYVRIM2I5Nkpra0RpMFR2emFIbFl2YVxyXG4gIDlieXUvUXZuaWJzZUpsVUp5M0dXaHBERHZUQU82RDl4RmlsaUZHQTZDZHBseEpnaVAxVzV1ay9adUFwamdmTzUyK2RMeFFaOUY4cTVcclxuICB0VGZWU3ZvdWZmZUY3c28vK2U0OFB1aWdNK3hvVjA2UitwaG1WeXgrenR0aTdDcnhSdEZPbW40UG1IaVM5bU9OS2RyYjI1b3N6OHNtXHJcbiAgNzRrOHk2ZXZkbzd2QUE3a1RRdlJqYkFnTTdlL1RtUTBqWDZKblJEaDFuQzl3dVFwTXlJb2ZDZnM5bWp2a25iNEl4NTlVeUhmam5CT1xyXG4gIER5Y2lyaE14STVSdDY2dzl1SklrRWNHbENSWmJFSTVnSUtPY2lPa21JU2pLS1dvL0hWS2txcXBLVGp4Q2lmdkhDQ05HREpIZi8vYmJcclxuICBwZzg1OGNRdmVlWStBS3ZVUWZvUWtGTk9uaWtQUHZSc2RJWkZpMStVTDEvKzB5aTFkNEFMK2U0UGZoK2xrbUFFaElmWm50b2hXMnY4XHJcbiAgQWZHWXc2OEhYWEo2aFM3bnVoV01OUkdEWkFZdk1BRzlsZXVTMTcxc011MHgvWTBWSWRHL2RZVlViTjdLZk5yTXJ2S3lNNlIwb0E2WVxyXG4gIGxFSTdEOWlpd1VoaHpzd2ZheHVBR1U2UWRVSTh6QTVjcTVpTTNUZ1JKeDdjQTZ1dnplUlpuNmZkVXpSUUxSM0NLRCtSdHRBdHJWZ2dcclxuICBpTDA3TXlyeUlSNXdIZVpWVndjNDZ6cDhmWWU3SUdHR3hrS25MbHlIZll4ZER6N2Fwa3hsMWV0V1MxTnptem1WMjFwWkxjV3Q2eUlpXHJcbiAgb3NSRFAvamdhb1RGWENBUTZpRVR4aU1zUkFUQzRYNllJbEZWK1BnTktVU0l4NjdweUJBUkZXNUFVSHE2SjFrOHVQYlRqM0dpTmgyNVxyXG4gIEFOYzhySW8yelgzRWxKZUlhZ1pQT2RjNEcrdTdIbGlTRWMvclA5SkZQdEYxT0JjUVV1S0lwVzMySDkySDU2V1o3VC94emNVbks5Rm9cclxuICBrOVpvRVJBdVhuWnM5SE1XNm1qQkZRc2hhUTViTGExcERoVGpJWjkwOGRCSmlzaUdtQnlkYTNCc21ITi9GRjlzN1FaQ1E3KzlQM3AwXHJcbiAgNno5OVRaNzM1eGp1TnhEa29ZZGVvTVgwZWVnNEdLaUluYnhHQ0llR0JhYnJTWldNN0NMWlBPOFI0OXlzcmo3cmJjdG5XejNTSzk1NlxyXG4gIFNOdlQ4YUxUUjVUb0EwcExrMzJKUW8wazR4cWFxMzN0eThDRFRqUHpYd2hKeVlRVGJaVTdTSlNKQW1JdFRId1p6OVMxVmZsYTM3aVJcclxuICAwSDdzc0d0RTQ0QjR2N0ZIYVpnaXRXeXFwUk1wVnNsekh1SUJwNE9lanhYdGpGdmJBMThuVWhBUExNTGdaUDBiaUgxYituWXNIb1dKXHJcbiAgYzFFNlF6bXBRRVNZcFBDK0FIUm40VHQwVGdSeEZpdlVuVmp3clNRNEVTVTRUTFR5R3BiTDJQMUdTTWtJNWVJL1pyajZxZ3VsVDU5Q1xyXG4gIGVVMDVpWHZ1Y3IzVjNnQ0YrazkrOW1lTHM1aHd3SUIrOHVKTGIxa2FlUG1GTytXNzMvOURsTm96d0lWVVZ0YVlQaVVPK3RaRTFxekdcclxuICB5aUpGU2dxd1FOb1Q4TkNqYUloWWtNaFU2Q1hlVzVsNE1rQ1BjZzdKbk5pNWJtVTlwcit4SWlURzVGZkwyclZ1SFpXUmpvSzhVd1lQXHJcbiAgR1NZWmZaSUxJekZITlQ5UW1rUk00TnVudXB3M1BTdkh5akZnQS9GQWh3THg4SlhOL0tkRTFsYSswamtNVGovcEgwZzgzd2QyOGdPQ1xyXG4gIFlIRXUrTEVDRVFYaUFjSG9NK0pRbTIwNjhXQjloK3M0OEY3S2l0M0FkU1EreWpnQ2lPV2hLR1hDME42bWlGTUphVkV1KzIvM00rSmhcclxuICBPZy85Q0NqYjNGQmovWUZ3WkxEWEJBcFZKUnJCZ1IrSW9VdmJVWjVmSjkxRlZORTUyb1h0UnhSaUpxd1ovbXdoZk9XSG5LLzNpcUxYXHJcbiAgeFZOZXh4Ryt0eDhRcUtkN0lLQUlvWVp6ZnA0NlNpZzJLOUxXY01NNzkxdVo5WXJNclp4ZWJmdW1oVEs4MlJkVVVVMnpKRHNuUzRuQVxyXG4gIHdVb1FGbXA1VERmSFJhYTIvcjQ0MlB1Q01rWUFsUWpIK3dMaWNRVzlwL0dFWEtSbGk4cjkySzd0bXU4c1JYNFlSR3hiOFVhU3VHZ25cclxuICBOczE5Mk9xWnFFNzc3U0k3UDhJenNDTzZSN3NYamJQYW1qekVlVU9tSlIwZ3RyZnNraUowbVZGNmlENXJ5bEtQZEZ1MEhnaUNrcE9UXHJcbiAgYlM3dHQ3enZlcEpBZERpWGlFZGh1RDV4TE1zZ3NwajlzaFlKamhVOUNYcVEvbU5kRkFXaWhTdENQMkwxOWRBZkQ2TytlWjYzSGZyWFxyXG4gIGQreVJ2aHBkeC9rMjlDSktQTndsdkcrREFQTG1tK0RBTWd6aW50dHZoSDQzVHJDMDhlZzZmR3ZSZHhlRjNkTVFFYjR0MGhBUjRnQnVcclxuICBnaEtjU0tFVGtlemlnUm9tT1JIVzZ3RG9EemR1V0M5ZisrS3BrdGZuLzJaOXRUdEFsSVVRNnZLdjdONzdibmY0M25jdU5TNEVKWHFiXHJcbiAgVHBacWFuYll3bG5nMkdNT2tiL2QrNVRGOXdYdSt1T1A1Skl2L3lCS09hUysvLzVqaVYycnFuYWlrQUo0eUNId2VDemFEZXcxUktDeFxyXG4gIFJNSWp2VmFKUWJ4Mno5SjZkbThOS095cHlPclZxNlc1aFkrRjhhb3p4ZUlpMlprelNtcGJJQXhpcTh6TjFYalVDTWljV2JJNTI0czRcclxuICBENGhGZWxZZ3Jpbk9pWmlDM0hxNEIrSkIvd2xqSDBrMHVEM2Y5UjBnVUlpSGk2OGdIcEd5WEdkeEVBd1U1TlExTm43MUhQMVFVSm83XHJcbiAgMXhGWS9IajdGbzhoMTVEbnZvNlVnRVNyZjZ1MmJ0QjdkZGNpTE43Q3ZRWklvQTMzSkVvd1RFbXVySHFZNWNZLzhFUThRZ0xFemRjVVxyXG4gIDhlZ2NiRDhybnpHeFJmbEpXZXpwTituTTJFUW55dDNCZFdrbEtSaHlVS1MvaU5xUDJrbWtZOWV4bzh1NU5DTzhHK1k4WVBjTnN0WVRcclxuICBSZ3lLRlhsVEpvU2hIWE5md2l2Z1FlallLQ3dzaU9wNSs0aC9pb1pOOG51SkRoQVlIQVFtd3NaWlJlK1F3NGtFQy8wMHJ0d0l6NVRyXHJcbiAgN0ZCaUJlSmg5VDJiYUhIZktNdHhxZ2p5cFYvMHMyelMyUkZCOFlQcmRlRlc2SGQwWURzWlQzdGVSR3hEV3E5Zk9DeGFyS2Zua05YWFxyXG4gIDE2eTFaNCs1TkNKZGM1cW9FNnJTQVFNbGRiOXpaZENrMDJYekI0L3JvWVNFZXRHekNQRndPREZKay95UzRlWktIdTRkQjQ0bTJ0SURcclxuICAwMS9Lb1I5aFcxMXJRdzg4QU9QckNvSVNmMy9odkljOFQwK0hzWTFleERnUm5aeWc2eUh1eXZVVW5ZQkVFNnJJcUNTSWZhMDlQUHRGXHJcbiAgYlJGYVBQb3U5Y2ZDa0tiZUxuMVhwSWxqQVFtWUN4VGxISzJjUXVCRTRIWm9BL0VxZVJQS3N5UW5PMDB1K053WlZ1NS9BWGpmWmJ0YVxyXG4gIGVPWjlYV0FJNXhBVTRJaTAzcHU3U0o1NWRuWkNIL0xBZlQrVHM4N3B1VnRpYjBCYmNFQmJ0eWJOZ2xQcEZGQStacXFGWGNFZm1rTXZcclxuICBjWjY5eDNZUFZxQmIzU2daWG9wQnZJaEJzcHhEOTdMZEsvUXNYMWkvMlBiM3dGWVpRUDh4YXRRb1JhQTZzQlJNYkdVK215eXBYTVlHXHJcbiAgKzlDeHFnSjVoaFBvTm95WTZFQkRaaDhuSG55WXZSRVBReURSTENpZVJ6eUV3ZlY2NER6TVhZUG1PK2VobkVqeElMUDZnSERRQWg5S1xyXG4gIHY5RXo5UnpFQTZWajlGRVF4ai80Ym5rTWRqN2Fnb0k4U0pjZnFTbjJQRXlCcm1Vd1EwNVRwTGxMdVE0V1RySFZMdm0rY2p6V2JqeXVcclxuICBCL0d3VmtNeGkrVmhTNDkrZzNObStxdjVRVHhsM0FhL2FSbW12NkVNcTVJaEhzUzl6MDc4UXZzY0lXMkhsZ0hKd2xXZ2x5QVBWL0p3XHJcbiAgQitFOFlSYXU4eldFTUxCVjcvWk5IOXFpUEQxcE16Smp4L3pWMkFTRDU4bzVjM09oZFd6bE4rOVFFUkZyVHd3aFdUbzZ0TzF3T1BGSVxyXG4gIHhsMWY1Tys2WldlRnpWQVJjNUhIZWVJc2dxU2YxTEU5dlhtMitxemdYRGErKzZBVUR6dFlxbGZNVmlMOGxCYnBSbERzNEpsNy9maDlcclxuICBRMFRMRDcwZ1VZN3pob0I1N25yOWl1ZXV0eHZHa0FSZ2pSQ0ltSW5Ld0FOUE1RUzYrZjJJa0VURXl0NUxQRzdYY3YwSVBzSEtsTU1jXHJcbiAgZE9CcGRzQ1JjRjI0a1pMeHgvc1kwSFRwaEpPa3IzTFQ3R05pdXBxb2J4WmFlOGwwUEErZEI1d0lCK09JMENaUytsM0FoVE9oWXU5K1xyXG4gIEl5SzFUTDdjWWpFUUkydVRsMnhwWXY1ZU5KRklFK2JyR0d3SjBnRFdXKzF3SDJsbUFhZWNDQnltZzM0NytxMFlNVkV1aEhWVEgzNzRcclxuICBvZnoycHN2bDd2dVNlb2IvQmZ6ei9wdk45OVVyaXNoZjM4TUN2emo4NG1kZmt4OHJFY0dNOXd1ZlAxT2VmK0V0V2JiTXBUSXNMdHkrXHJcbiAgM1oySjdndjg1YTRiNWFjL2Q3RVlvRS9YWWNPS3VWRXNBcDV2QkJaTnBHTW51c2U3bFluL09zVEx4TUR5ZXA1STVzVE9kU3ZyTWYyTlxyXG4gIEZTRXhQR3VMckZtN3dSYk5ZYm5LUXk4ckd5eXJHc01nWURaUmFkd0dnR2lMZ1lnMUJxS0cwQ0RjaGluV2RZREJ1c2FKQjJhVkxzWktcclxuICBEa0k3WXlFRDEvUHNqekNLa3dkeWduQzB0ellseEZiRTdZT0JIVWRVcFRNcVJDbDhOT1lFVHZ2SHh3RHhzSGI1TU93RDhiaC9jTFNmXHJcbiAgUk1Cc0ordE82VkpreUdDVTgvUU4vTkZwSzVBN081VHJVS0xKNGordUZTeG05a2c0b2pqOTV2bUVmQWpIcHZtUFdodzM1cFRETkRLdlxyXG4gIDN3aWJ0ZHJNVmRzdlVNNGtJS0JBT0VLN2hLUUQ4Z2o1bGhmbGc5eDNHQkkrMkVRTElFd3RhT2NoRWdGUlk0WVo0aUFocy9NdnhtMTRcclxuICBxbXlyM2tiZ29NUURaSnJiMXkzWnpFeGEzMGVmWVZPaVBxUzQ1MTBOZDNka1pMTndNa3JySCs4WFl1a1gwWDVwR3NJUnZ5ZktXbi9oXHJcbiAgZERUdWZmVnpURmdvaDM1cjBLU3paUDNiLzdEN05aMkw1cTkveDBWeXliYWk1OU05THdvSEhmUUp1MGEvY2NmSTFncm4rakRsTGlwV1xyXG4gIGJ1alFiMGxXWGwvVGhmRXMrbzFtZHEvZFR1blVpUUFMRk4xcUxsekQ0bnBZMnpHaUFoSGN1b2cxSktzUzNFaEQ5U29UalNKU2hKdWxcclxuICBISzVSTU5wb2IydlZOdlZDdEdOdDgveTZ4cmtlSWxvem45VjQvekV6VGRkaUV5bDlOamE1MHZ5K3lwRzRTVHZmVWJOUHdpQWkvSEVOXHJcbiAgTFdQdncrSjJjNTdQalhLdEVHcGZUR3lsZjB3MitDNGNkQ0tBMnlBbElwdzMzV2NFaU9scXQxWEw0UWNObDY5ZSsxbDU5TEY5M3dYd1xyXG4gIHZ3V2tLRTg5ZnJ1SnNvNDVmdC84YkIxNjZJRzJMZ1RZYjcvaE1tSC9VYkord3hiWnRxM084bjcwZzh2a3RET3V0dmplNE9Jdm5DMS9cclxuICB1T09maGo4QWZhSzdBeDV1Z0hnOEFwNTNGRFhvVnNTU3ZWUUxZQzlzdDZCbjkzUTZBaS9TZTBGcy9PUEFQZzkxT2JnVzhQSm1jYVdJXHJcbiAga3lUaUt2c0lGTEFlQ1NhNjZFQmM3K0hFSTlpRTAzZTg0Ym9DblpRMlloMm0zeDVhZm5UT0IzRElWMlNTMkRtd1FtY3ZkWWFzWUw5eFxyXG4gIG1KY2tIanF6TXBIVk83YlFqQmxSOE45a0h4ejk1YU9JamhDUGk2NU1WTkRab1J5Vks4ZzN0Z3cwUXRTaFdBSVdsZzF2R0FKd0g0aGdcclxuICBtRW50QytFZ2psVVY1c3VrYmZVdStnMk4wMmZ5QmswK3k1elBrY2ZhQlkxWXZBaFJsVjRyUWVTNEZ3MUR1OTN6QW5JSitZalpMRDg2XHJcbiAgQjFMbUdIYjR4WTZJOVg3cUF1ZWdaUUxTcGc4UUszT0p3Y1piemMyU21aRm1uQWYwcDdTMFJPdFBObVRkZDlTTWlGTkp0VHcvcG5TTFxyXG4gIFR6RUNFdzZlV3lLdG5HU2Y0WlB0U005bWozZTlkKzBPYVNQUWVsZ2Z5UXg5MVA0NjBYSGl3MzdvZFpyUHVoaC83djc4cUV1ZFlUTXVcclxuICBrZzF6L21FRWhZTzg4SXlzWEhRRWJvNDRYRWxwMVgra1NTY083SG5PemZmcjU5WnM0VGxuNURwWE9HVHFwK3pRVEp2SWhEYTZ2Szk0XHJcbiAgWEEvY3h3dzYrQXo3WmxDMER6cjROSDB1KytreFZvcjF2WlBQSklJMktWK3o4blZUamlQS0RHM0UydzU1aEhERlRUWHJUUy9DaEllSlxyXG4gIEVTSmM1NkJwRDBzcVh3L0Zna3hXMVFjaW9nWHN2SlhUNXh6YVRPUnI2T2QwSXFEZkdXRklZOHlCR3grK2ZiNVJUa0ZFR21weGorTnJcclxuICBSWEozTHBiUm80Zko4a3JYTFp4eCtsRXlheFo3bXZ4djRNZ2pwOHFSUjB3eEJ2cW1mVndiRXN4Nm1TZ2h5dnJOYisvdHdvWFUxN2ZzXHJcbiAgODJyM2swODhYTDc1clY5Ym5LZllFM2ltRWZqRGpCSWhZa0dzVUcveDNzckVUd1hZUXptSFdLSkgyUWk2bFMrVk5WS3BNd0w5ZGd5S1xyXG4gIGkvSmxxeVJkMGVPdTJ6Z1BUU2JOZFNPQ2dlZ2hpc2ZGVnU1Rmx5cStKc1IwSWxvL0REYUxFZHJCSVBWNDF4RGl3U0tveVRaN0J3THhcclxuICBNTFBjTmU4WjhRQzVHM3VPckhmMDRmWnhROWlNOHdBWlJSOUE0QmJDaHhjT0JyeUxDSFMyajJXVnZtYk1jcHN5U3FRVFUweTdjcWMwXHJcbiAgTk95U2dmbnQxaWJ1MzIzZmt4ajNFbTg3eE9HU21KR3lpWlc1Y05FOG5nL1hZb1pHZjlFUldKMm9yNnp5TlU0alFqaHg1YmVsTGMvVFxyXG4gIDNmTkN1WkFQQWdHSkQ1dUpERmp6RGZFdXNMS0dnTFVmK0tGQzhRK2gyTDVCbjdlR2VzS1IvdkJEckN4cUlOYWRNSlVyeU11VmtuN01cclxuICArSlAzM3ZQd2V3bWNsSEZUdlIzMG1mdTIwQkZmSURpYTRYMndmaWlCMFg2eDFTcWh2MHQvbnh3UUZRZ0RpbS91Q3dKSlBtUEYyclp5XHJcbiAgTHU3aWdKaVFoK1VYNVJKOW9Wd1VrbDZ4d2hmQ01aT2xmcC8rK2gyRTg1U05Rc29TaDRnTW5IaFNNbCtQcnZIa1JDRGtFOEp4WU9yS1xyXG4gIFlrUTRranJsdENpRHdjcEEzSzlvR2RhNTlOZnh3c3B1OUNPaGJueGM2NCtGSERrbEk0d2J3Y0Zpbm40TGJjME54cFd6Rnc3bElZaE9cclxuICBSRGJycENEZFBDc2tpSWkxRXozanhMY2ErdXg1VmtiL2NQKyt5L1JobnNiNkRIRVZ4aE1zT0FUeWxGdEZKd1poV2JGOG1Yejd5blBrXHJcbiAgbE5PT000VTFTTHE5dzYzNy9sZncvRE4vTWk2RXRTR3JWcTczekwwQWhHUHAwdFdtUzBFaTgrRER6eVo4WmNHRm5QK1o2eTIrTjdqN1xyXG4gIHp6K1dQLzdwWVl2ckUrd05lS0I3aG1RSkhud1VqU0s5MXU2U0dTVXM2Rms2bVJNNzE2MnN4L1EzVm9URThOd0tXYjU4dWV6YzJhaUlcclxuICBXRzlRV2V6Qlk2ZElHanZIS1lUdGFFTzlqRncyaXdvRXc0a0VZcG5nMzhwMEhvb0VpUE9Id2p3aldnZENta0ZtTVJ1UXhLTUJHVHZzXHJcbiAgUTlCODNGbERQTmhYZ3JRcDZ4Q1hHUEY0TjJMRE4ydGZNMnhteFF5TEFXN1dLSmhueGo1MGE1T3d5NGViWm9RRDhRQWZGbHdIN0w2WlxyXG4gIDVlcDVab0xTMmFhelQ1enNhZDkwQ3RPNG1UMDA4QnJzYmNYYmpjZURxQXBSalVZa0k2Ky9QUnU0bzBBb3NHU3J4NVkrdXVkaUpScUVcclxuICA4Y09vZWtoSGZlZHdzWlFlbXhZcThuUmxkcGU2bEZYQ2c5djJnUEE2MnBvTVVRdy80b3RTdlh5MjFuRWl3WUxKOGtNL1kyV0dIL0VsXHJcbiAgQzBIYWRrOTY1TXovZ1d6WnNrV2FtbHFNQThuTnpaV0d5VDlOOUNWK3pYQ1lSVklzSGNyUWx5NEhlYkdqZS9uNHdYbWJJR2pveE0ySlxyXG4gIEN1K0dzR2pvUVFsT2hUWWdKRGw5RU5ta1dYNmZFWWRwUGdqY255blBkdWlNTDhUeS9IREM2QWNMM2JKemNvd0Q0K1l6cDMxSDg2UCtcclxuICB4UHBwMStTSTdpa2UzL0xCazdJWnYyUzlsTEZRMHpqZ1pES0c5UjBPTlNFU0hhM05SbFJ3QThJNkdvZ0paYkVDSERqaHBFUmJGblk3XHJcbiAgOUNjSzhZRjJxSEl2YndwNzRKQ0hXSkpuaG5rdml5TDVudkJFelRYTmNoRWlvdCtaOVUzTDBaYitlTnkrNFNnLytwNzV3NE92cmUvUVxyXG4gIGRCQmJjVDVZWXdHNStpN1NxK2JKMkxFanBHeG9WemNmeHg0elRSNytsN3ZELzE5QWRuYVdlZXdGTHIzc2h4YnVEVERydmVMS204eWtcclxuICA5NXl6anplMzhXL1BXV0RuZ2k0a3Z0aHdkekI0OEFBNVpPb0VJNWI2Um5wQ24xd2VKbytMQjJwUmhTaGlRU0t6ZCtoUkpobTNObmNMXHJcbiAgdk5Rb3VnZllYWkdEeTVwbC92ejM5U0dnSVBTdGFZdUtpcVNpTWRxU1VpdjYxclFPeUZVaEdyYmlQQ0llckxrd0xrVExvdU13SDFqUlxyXG4gIG9OcVR3cnhIWEEvaU51ZzFuM2FaUFpIdTZHaU5FWThoU2VLaGc1NFpsQk1QNTBDYWFwUlZwMTZYajlUYjliaUcwVGw4ZUVGbzRGYllcclxuICByeUxzQUdqZVJyVU84dHh4NDhaTGMwdWI0Z3J0Qnp5d3RQZG9xM3Zjbk10cGZZaXM1NE9NTUhtY2FNL0U2dXNmR3dHbHBydGJqZ1FpXHJcbiAgaVBvRzhqY2tGbTgvT2lBYTdHNW81ZlRBSlFjaXZKQ3VVNExDekpycjR3OXIvWnQvazNWdjNXdHk4S0E0THhsM3JCTUpiUWVpNG5XVFxyXG4gIGJmcDEvYmxoZ2RUWTJDdzRUOFNoSnNnMDlNWDZTOW1vbitFSTdkaEJHU3d6SXZsL3ZGeTRSbzg4Nm1qY0QrOVh2RThKSksvUHFYallcclxuICBWRDJmcHZjek5ib25QODkxNGFiVzZmMmpBN0lGbUhwdTA3eEgzZklyMXBmMWI5OW5MbDRxRmo5djNBbDF0Nzl5dmExa2JtMXR0YkV5XHJcbiAgWVdKd2I5K1YwSVIzeGRxTmpYTWZzWGoxOGxsMkhkdERKTEpBczJ0Rjl4V3VHL3FReU5NMHUwSWl5dUtkb21SblU2cENuUWh3UGpFMlxyXG4gIGRhd2lGa3EwWTRkZnc5cEtYTWVmSFM1UTBHc1JiOFA5Zm5TT1JZQllUUm9STVRHdzZ4SjdKU0xXdm9ZNmRqMWZyMkZ4emRjL1BEaTNcclxuICBSRmFDTE5hTUV4SHp5cUQ1dUczL3hxV25TMjRCYThyY1VpbXMyRDd2VXlmS3piL2EvZjRjLzFmQVl5L29Ic3VvZlZXb1gzakJhZGEvXHJcbiAgVDUxN2todzY3UUM1N3ZwYmJEd0FjQ0VYWGZ4OWkrOE5XRmg0dy9kdTdaMkExRFowOGhoM0F6emFBRHpzS0JwRjRyOEo2Slkwc0x3OVxyXG4gIGxZc2xlaXRMdWx2NVRadmN5eTVIYTJ1bjlPMWJLQ09Hczk3RFRodkJDS0lyZnRDQmdKVHdsVVFXaDh0alNiajVMcUlhN2hpZGgzdmlcclxuICA5TUZGU01IRVlMUTRnOXpUNFNNZzN6ZC84alRzTkthNlNlTHhYcEo0b01SdlpidFpaWS9SZDhDbEdOR2hUYTNmaGJYM01NUlpwOEtNXHJcbiAgQ2VLQmhWTlkwd0hYUVgzRWRJUURCOEJaaVdSbEk0WVJxZG1xSEVQMDBYZHZGMUdWdXgvSDc5UkVlMWFHWUxRZFBxaE5jLzlsaTduc1xyXG4gIGVZQlF0UTRLK3lEZVNiWUZRdkkwZFltRDFPQTBPRkFlOXhrNldmdmhpbVRFTlZqYWFHRWo0c3pNaHg3K0JVTUU3S0hOYkgzNHpFdTBcclxuICBIWDhlOFNPT1JPT0huM2RFeVE2VVd0TU1MQnFiMnFSZEtTbVdUblViM2hmMnVGZzMreTdUbGVBL2lwQURxeTlydTF2N2RldjhQQWNtXHJcbiAgc210bTMyM1dZYldhNXBxRUZVdGVzakJaTDRtc1FlRGVyOWc5Uk0vSURyMWVFSDlCVEJEWHdWV1pXRTdyUWt4dzloZVg3YTk3Nis4YVxyXG4gIHBranR1cmt5OE1CVGpTdkI0bkQ5K3ZWR09QeTU2Yk11WnUxVGRNM292dUpqQWJjeEdyUDNqQXQ3UFNsbGs4NlV3WWVjTDBPbW51ZmxcclxuICA5ZGc4Ly9FdWRhMDlEazBUUnpkQ3VJdnRoU3VXbVVpTEErc3M5QmxtK2FqakZuOXFPR1kwRVNodFJRY1dnOVplOUw3RE5YSjFyS0VYXHJcbiAgWVpJWGlBbm5NTDBsaEZ0RGxPWkV4SzJ6YWlPSG05WUdvOENlTmFNaHhNbW5mWTNyWDJieFFObWx4SnAwbkJOQnRKaFQ5NkVNS08walxyXG4gIDVhT0dkU0VjOFRoSU9zVC9GL0RQZjl4c1JPVDBzL2ROQ2Y2bFN6NXBacjF3SWV4KytORkhxK1h2OXoxcDUrQkNObTVNbXVqdUNiaEhcclxuICBkamhNVTBwaU80YmM5K2c4MlZIakMyalM4bjJESXY0ZG9vZ0ZkaWFDbm1Yc1hjUkt4TXZFYTNxMGF6bXZHeUJSS2Z3WWVFeC9rMWtLXHJcbiAgS1ZLU3NrRTJiZHlnczBtbnB0a1pxVEpzNkREWjFPRUVCTHY5NElJa1FVZ1VtT1hqdEJCd2l5dGZqUTBMekV5SkQ1TTBHMEloZy9YblxyXG4gIHdzWHBiL2Q0TlBCc2dDYnprZFd5WUk2WmZFSEphUE5OaEZMY2ljZGhDZUlCc1BDdXNYYUQxblE3ZUJ2UXRCZDlqSWt3NUd2N3VEU0JcclxuICBYV2N4RndzaHpYOVdXcVo5TUpSQmwyTitxM1FXV0xlejBaUmxIYzAxMHQ3V29VZUw5SnQ0UmhmRVFSeXV6Q0RLUXduTnpBdDNEeGdQXHJcbiAgTk5Tc3M3VU1MR0FEeWVPVEtsRS9DcDNnT1hJa2pZaUtEeEFGTllRQ1czdTRqV0lsSG5BVU9VVmwxall1VjFBZzJ4cUN6amFwK3VnVlxyXG4gIHF3OEN4ZFFab201dHhoQ0xIMXc3K1I0NHlJTXc0SDIzYnNNSHBudXFYdnlNTGFZeW1xZGNXTDgrUlRMaXRKOFlVZWY2N0FWT25BMndcclxuICBJSkNNSFpTeTFPMStjSTArSTZiYSs4WDZCN05zWlB2bVBVQ2ZQK25XQnQ5WGhEVDdhV3haOEpRK2xnd2ppTFJCR2U5dXVBOGZPL3h6XHJcbiAgd3Y2aS9PQ0Ixc1EyUm5EUjc0ZzlUMXlnWitYM1ZTNXRzVDZyeVNZZXMzcjZsNzM0MTdKczZWSjludDRtcHJ2OVQvNTk0ang1TkJSUFxyXG4gIDQ2Q3hKVEtBWUMyR2lTdWo4L3h0bXY5dm5ld00xN0cxM0MzcjlBK3dzeGIxY2lHR0tJdHZFTE5mOUFjOEl5WnNLTklISG5DeWxXTHNcclxuICB0aXJueEVacDZPVG9EMDNFMjNId1dIcHVzUkVSVzFpN2JZTzlNOHp1TWJQbFBKNFUzRnByaUJLbTVTWldoVFBCckRyUmxnYWgxV1RjXHJcbiAgSThUVHRVMG1UMnpsaktFTDYwTHdpckJwMmR0eTQzV2ZrVTkvL3BOR0pBTGh3R3N0UjhpNzkrOVBtUDdoZndIb00zQlJzbmxMbGUxalxyXG4gIFBrMEoxdDRBejdycjFtMldJNDZZWXR6THYvL3pzcG4zc3FDVWMzLzUyMk55ek5IVG90SzdCKzVSUHlHSHVCbXZQVUIvaXQwZytmb1NcclxuICBUOWZBSTJIUUpDRmVKZ1o3TGRlekVoOXd6MXlSakxST0tjcG9rS3FLellvVTNPTWsvZUFEeVNqQ29hR1kzb05GU0FENkIyemVBYng3XHJcbiAgQnFXNUxhSmpwcVJYd1NvcHB5OUUxQkVSTXMvODhJSFlUV3JNQm5ZODdtVVRTQ3pLcjJOeG9DSVhGbENGRHpBenY4Um11a25pNGYxaFxyXG4gIE5zcGdad2JGd2o1SGppQksydlE0OVQydFJLMTZyWmkzWGtYSXVGN0JBZ1dPQTdFQWk5VVFXVUU0ekc4UFJFSERyUElaMGxibmlsUkVcclxuICBmR1o1a1dqYmZWR2gyd0RQMEYveUlXUVlEU0JmWnFVdVNKZDg0ejYwWFVSV3huVm9QTjVmaUFkcFJGU2tiV0dlaGlpSS9YeUtjaEpmXHJcbiAgOURvYUorMmN5WWV5YzlOaVc0allmNytqWmZpUnpMalJZZmp6RFllM2tUeTRMcHlBUC9mM1plM3I5OWpNSDgrMDdDc0Jva2FKM3RyVVxyXG4gIHJHL1cxOEh3cHZMelhaWk9QVnpTMTYyZnAyMHBraDB4elJhdXhhK1pQUHo5MnJXVUtDVHl0USs0YVNGZXEva2N0cU9lbG1NTUVLY1BcclxuICBLT2o2YXI5d2lVS2RoZis2M3ZvYWp1UjFhRE01dmdqajUwanpiTmdLbDhWMU9QMGJwcy9VNlVSVVJ0dkhaQnZkQjF4ZVIxdTdwS2ZoXHJcbiAgMURGNVBwUzFkQlN5K3J2OHNBdjEvUjZVS01lM0FFZGlZazM5SmpGWUdOeUZHOEhubVhOVnpxMUc3V3BkajZlWVNNc21BM3FZeXhyOVxyXG4gIHM3R3E0NVl5Nk96UTQwRmt3bTZYMXNmNFFaNjE1MXk2aTNxSDJVU0h5V0ZZMzJURUEzR3dmaHR3UW5BaTlNSEZXVDZlTkJMRkdRM3hcclxuICB1RjhEazNUTEJ6U2ZTVVpoL1JMOWZsSmw4UkwzaVJXSVI1ejdDUERESDF3aGQ5ejVVSlQ2K09HK3YvM2N3bXUvNnVIZWdEN0NoZVRsXHJcbiAgNWNvbEY1OGptemRYeXEyMy9TTTZOMW4rOWNpckZ0OGJ3TUh3OUF6cTYrWW5GaE0yVjhRZlFIaHdpWmhEbDBTUFpBOWdrQ1NoWitsa1xyXG4gIFR1eWNSVU9hVHdMUWRLeEltdWJ2cU40b2RYVjFoaEF0THkxRlNrdExwYWtqMDhvbTlCNGF4d0xMRnN6cERKdjlPd0E0RCtUM0ZBQ0JcclxuICBKdlltMFA5V0ZndnB6TnZUZWhBTEF5M0VFL2tNT00vamdIaGcwb25ZQ21Sa2RiUU1pTDRZSktMOWhYZ3c2STE0MUd5MG1TVldIOTVPXHJcbiAgYUk4UHhldDZub3VzNEZaSVF6eE1kNk1mSHNTUHNzaG9pYnY3ZVVSWjQrd0Q0dU1iT05BOUQ5Q2tpN085VGU1ZEkzNy9tZ1pKMEJaZVxyXG4gIFVPRnM0RGJZM2hOckswd2x6YkpLeTRVUE9yUVQ0bkFjRURObXgyNU82eUlxVnhSckdSMStJSGFPb2RNL2E4OHFFQXRFVmtZMFl1M1JcclxuICBkamk2Y2gvdXFSWmt6VWRmdSs1OXU0K1JSMTF1NSszNWFvakYyNlozSDVTVzVpWjk5SjNtMmdFWU9LQlVrZlo4NmJUWHFKeU92cXZhXHJcbiAgdGZOazlXdC90TFVNSUM4UXYrMHRvdTM0Z2ZlQWNqT0xSdUM3K3JVL3VYaEU0N1ZLZ0NpREVRTjlnOEFFWFFaeEd3dDZudjVDaENFc1xyXG4gIHR2QlAvL0J2WmM5Rit3TWhZUXpaL2NZTzB1RUk5eC9lUmQrUmg1bVlDK3N6M2t2VnNsbFdadlBtelVZd1VYeGw2VXl6ZU1vWFRVL0NcclxuICBrV2hYeTN1YnlldDQyNzQ1Rm5FUXRTWnMwakprMnFlVlRqZ2hRai9DeE1PMkVZNzY1SFdTWWpvbktHazJEbEdpVTQ5SkRWdnJVaDVSXHJcbiAgRms0N1RTK2k1MnlMQUIyTFRrUkNteDd5L3Qyb3dkT0JpRUE4U0x1SnJ6c1k1YnZDUFpIclJKaFVhajM5cGEzUW5rYWlPR2Y4U01UMVxyXG4gIFBCSURzL1pTd1BmVnhvM3JaVmo1QVBuRkxkKzJSWHE5QVlnNm5QdktGZWNyWWZuZm1QWWVjc2hFNHhnUVpWMzhoUnM4Y3krQURnTkNcclxuICBkOGJwUjh1QkI0NlYyKy80cDh5ZDYzN0Evbmo3ZCtUbFYrWllmRy9BazB0QWo4V0VYWUNIR2FDWHVBWGQ4aE9uWXZueElnYThxQ2phXHJcbiAgQTVJblBLYS9zYklaT2g3VE94UnhWSzVYWk5CcGhJTzJzSEd2VHg4azJ4cWRtK2hONzJGK25UUUhmMGNRQ002MU5lL1U4WjJoTWE2VFxyXG4gIElyczJmeVFadXlNZUdpWUhtMzljSVk4LzFuaUFFUEdTNmdvOHQ2WDN4VTVZMG1ncC9maVlLV0VWWm9OY2tZa1JNaTNuN2ZHQlJHSHNcclxuICBnUE1BeVRQamduaXdjaDd6V3U2VnZvU0ZnNE1PT3MzS1F6eVM3YVZKLy82dUI4SGdBa1Y2U3NVN1hsZlBzMU1lOG1qejk0UXlXdHNqXHJcbiAgVFQ5TU02YnQ0dERRRmxmeUFkTm1hRHNXRDdvTjVQT2t3OHA1TElrZ0dKclE1eE1SRW8zN2ZoOGdtOUNPUGgrN2Q2NFpwYU1RN21MTlxyXG4gIDdMc1NCNGlZL3FOVUJqbFRqckJtelJ4aG95Vms1QmdWVkgzMGtqNkwvYVMrc1VYUzlEbHc3OHc1TUx2RU5OVGN5ZXNmenZtb3p6SHFcclxuICAyQ3VWVXpqRUZpSGloZ1hrSGc3MjY0Q3JRWTdQQ211cnd5NkovR2svTjczM2tCRmNUUm9IclpsR1pDQXdvWi9oUUJ6SStSUjkvM1VSXHJcbiAgcDBJN0lDN092My9mWmZZY0lIVCtqTGlHaHZhTXd2UDNQQ1BFUjN6Sjh2RGd1L0dSTDhqNnRldmM4a29oTnlkWHg5MW1XeHlKTW5wUFxyXG4gIGhDVFJkdlJlRUhreW83ZEpsYWFORzlIdmhQRUN4NHBoaGVYUC83ZUZvWCtoTGMrRGlMQmhuVTcvZEJDaW1BOSsxbndWZTRvU0V0OEZcclxuICBrYTJTSWNTVlMxN3UwWTZGOUVzUE9HRFhpYmd1QkoxSUlDS0ViRHJHTzlPSy9KdVNmVHNURFJMUmM5T0lIVnpmOGtPY2ZEMFAwV1JIXHJcbiAgdzJGWmxWSmVQa2dPbXpwV2Nnb0tUVHoxOXRzZkdNRmdINDQ0RjRMbFU0aXpzUGwvQlgrODR3YzJsdSs5L3ltZFRPL3d6RDFBNEVLS1xyXG4gIGl3dUZQZGhyYXJiTDNYOTVMRG8zV2M0NDZ6cUw3dzBTT2hBZ3JnZEp6OGNzallmbmdUNUtqd1AyVUFORVo1SS9FV2c4U2licTlpZ0RcclxuICA4SktpYVB4Y0wyVjkwRVFKaFlMTVpwMDFMNU5kTzNjcDhWQkVrSldoaUNGVjBndUdTTHAra0x0cXQrcmc4VDNkM1h3M3FmZGc1endhXHJcbiAgcTY5eVZ5RUE3c3dMVGFTbGJINUh1MzVIYWI0cVBUR0l1Sk1vak9kWnZ4alVVYjdHa2JIeVF2RjNWTHVXM2RSOFptYTdCU3JSSUF5RFxyXG4gIDI1VHNXaHBsbjdXanM2b3VZZFFtMThIVEtTS1F0cVpkdnQ3QkxLMzBXVUFZNjJzZFFTckNKOXhac1VMWXM4RDZaeDhhTThCVVpiOFhcclxuICB5Y1pORzZXdDFjV0M3ZHVXU05hUXd3d0I0UGFFUGlOL1JsekJ6Qlk1UFRvT1pPdUlNd0xoNkw0V0F1ZEExb1VBQVAvMFNVUkJWQUxBXHJcbiAgeW1wbWF1Z3BqUHVJdUEwNFBuTk90d3Nrak5obm5oSzlSdU15VEZlZ1I3aFBQL3k1K2pOMXhJbWlHNElHUWtjY0JoSzJSV1A2cnVBYVxyXG4gIDJPRVBxekRxb2orQmdLNS8vVzU3ajRoYlVJUkQxRGErODRCa1pXVkxhNXRPSHRMVFpPakZUMXY5MEE4NGxYRFFGdjBCa2Nmenc0Rk1cclxuICBuRDZFZXBRUDUyZ1RLekhpRUdNem5OQnk5SHZodzk4d2NTQ0VZc3NIajlzN0syUEYrVnYzeXNoanJyRG5RMThaSnliNkdqN1ZpQldJXHJcbiAgMFo5dm1STFBQMXMrNzlDZUV6SHJyOGZ0ZVdwWXUvQVIyYjY5VGpyYU80ejdnRHZ2TEJodWE0SVFFOWtpVFBNVjV1VjVQczdSUk8zb1xyXG4gIG43V3JJZXN2bU5XVEIzRnMzbG1oUk9yWXhNNkpudWY3NWJEejRwWUZUK3RZWkl1RXFDV2FzWmlIMU9NN1lleTJORlNiL2dKT0drQVBcclxuICBZaHhJNVNwN1RqWVpSQzlpWjd1MVJWODF3dk9xV1Q3YjNPTmdMZ3l4US9mRmRzdXRUZHR0OG9YeW5nbUQ3U3NTRVZJYUNiMEN2TzBJXHJcbiAgUWx4REZzOXVXZnEyZlA5cjU4cFBmdkZOK2VuUC9peWYrOXdaOHU1N0MyWC84YVBrNElQR3lkMzNQR3Btc3JmOTRYNDVkTnFCcG05QVxyXG4gIFg4QU9nVCsrOFk5S2NIcHpHL1YvZzM3OWltWDU4cld5ZVBGS1dmN1Jham4vMDZkR1ozWVBRUmR5K0l4SjhxOUhYNUFsUzFiSjZOSGxcclxuICBNbjdjU0JremVxaFVWMi9yZFJmQ09PaVhtb1RBZ1l3dlR5NjZjOWhMM0lKdStZbFQ4Znp1RUFaQk43Qzg1QWxpenY1NjJrRS8xSTV0XHJcbiAgVWxYQm5zWE04S0pzaFoyVmE2U3RjcUYrcks1Ym9JQU5raWlPbzBBRHJXUnJJQlJNRVd6clBSUzBUQU9tdlJGbllvZm0yYjF3TVk2UVxyXG4gIEZ5RThSMzdPZVJCSGJBWGlndlBvTytJd1k1OHA1N3NGNnFEV0FRenhvRDRJTU81UjEwSkYwbDNTZW9CazhIU0tySmp0TmtIUXR1V25cclxuICBFZzgrTG9nR0lnRTREb2lIM1krMTFiV2Z6V1VuU1dieGFPZ0FJbkhaMmRCa00waktzT05jYnNrSUUrdVJ4bCtUUml6T1J4bG1vb2tqXHJcbiAgNmljV1FldmYvbnUwd0JJNWNZbFpWaUZPc2ExYk5ZODRJaHpPRHpyNFRCZnJXQ2VpTmhMdCt2WGFsTURBWWJCQlVWOUZJQ09QdnR4Q1xyXG4gIDZzUEpySm4xWjFOY1UzN05hM2VhbFF6SW1XZmJydGVFa3hoNTdGWDJydkJvUFBLNHE4eWpycjA5cnFFaE03QXU5eE83ZnRmMDdvNTRcclxuICB1ZmlSUEIvdWpUM2NXY05BL01EemYyZDk1VHhFQlU1bi90KytaSWdTZ3FFbjlKRm02RDMreVlnUVpZbnpERkhhVXcva3VtMzU2NG4yXHJcbiAgbmJESHI2bHh6V1B0UjA1dXJxYmRyTDM4VTM5WER1VVNleTc4clgvcmI4cU5JY3ZVK2xwKzZQVFA5ZUJJZXNaVEZQRjNKb3duMEwxc1xyXG4gIGV1OWhFeGN5RWVGZDhFMmEwaitxUzUwUWo0ZU1VOFJhZkl0WWFwbGJIUjNMSUhyR09odzdJWndJMzREVjFYNTBiU3UwamJ1V28zVnlcclxuICB0dDcwaUR3dkRBMndhc3dxR0dDVFNJZ0d6OW1sQWI2UVZ5dnJQOC9PdzVDMnZCRFhjRnh4bldSbmlIem1BbmVhT1BQd1NUWjcvK1E1XHJcbiAgSnlRNERaQXZjT0FCRUU2ZjdkOTE5eU1XLytFUEx2K2ZpYkllaUN5eUhudnFOVm05YXUvY1R1QkN4bzRkTGhNbmpKR3E2bHA1NnVuWlxyXG4gIGR1NjhUeDJ2NS81azhUMkJQdjJlOEpFT3VBVHc3S0tvUVpkRWo2UkRiNW1XdDZmS3ZiYVV5QTIrVndLTTc3ZEQxcXhjWVRlUW9WZ3dcclxuICBVMW1RNXZwV25WRm1hRnBraXhLV2tteE1jckdvMm1qc1o3QXNvazFEa0dCUEJXVC92dEpjMHd4SURmUDFJekNnQ05rV0o1SWNVSW5CXHJcbiAgRmgzbVRiZFBtYzdDRjVyWWlyek1uRDdtQkkrUG9IYjFIQ01lYk5zSklna2ZIcXgzOG1PZzNTamtJNGsrV0Q0Y200M0IwdXVIaFgwL1xyXG4gIDF4OHc0VVFqUUlnQXRpNTh4dXAxSVI2MFpXMGdnNlpkblUyM1ZrdE9hcXR5TUdsNktsV2FtOXBzNW02aWlMSkl0TUR6MXR2Q1lpMG9cclxuICBVZU1mYldnTFVSVngxckl3a3cwbXBlaG5FRldoNzBBRTVyTDhGQmx4cENKSkl4dzZJZWpTWHZLK3lZUFFiSHo3SDhadGNZL2tJYW9DXHJcbiAgaVhLT0dUT1RBb2lGbTJZcTE3RWNlWCtxakZhaU1Vb1BFeWRwdXU4b2ZkWkdSSlVEbkgyVlpDalhnUjhvNE1BRGZhWk4rMzR3VVhGT1xyXG4gIGpjUDcxdlZJbHUxK0pNZENQTi92emUvUGoyU2E4MldUejdGd3loZi9wb1JDK3dxWHBRUmovdDh1VVc3a1NqY0dpUGE4R0huTVY2d2VcclxuICB6d0drMmwrUlpXZ1RBb1RlUkJOUlhuUXQ1YjZhV1hHc3I3US9XNjFxUGdmS2RxeVd5cWFlcDF3bjd1bVQvZVpkOG8wUUQyMGw0MTZPXHJcbiAgeFlKWU5SSEhYQlppMG4vc2tWYW1hdmxyeG5YUlo3aGw5Q05oTElkMlBOVCt4Y1lCcmxDd3pHSUZPK01Ra1RPSW52TzR3RGVpWWtRa1xyXG4gIFBML2tjNHlIZkZNUUVjU2tjRzFjQjkwbktBKzlJNkl6eEZoT1JOaFR4UFZYWHQvZklYK0VIdmZUOCtmUGw4OWNlSnJNWGVDR0tDRGhcclxuICBoUXNkcndUUlZmY1ErUEtYemszRVg1djFqb1gvQzJEaktYMEtjdlUxKzdaWjFGVlhYbUQ5T3U5VEo1bjBCb3VzNTE5NDA4NWxaK2NsXHJcbiAgK3J3N1NPbHNYWmpBek9NT3VUVEJoV1FOMUprU0VCNmVBUTh6aWtZUm5tOHNVeUZaSmw3VG8xM0xlVjFnOStVOHByK3hJaVRZMzN6aFxyXG4gIHdvV0txQlFCS3VIQUpCT25pZENFZHNkOVNsWEh5Y3JxRGh1RVpKZ0lvZGhGY3d3dW5PY1IzMW1oaUhPUUx4QkU3OUhGNHNydVA4UjFcclxuICBjRVh4OEJHRkFRY1NSN2NDQVdHL0IwUllyQkZneG9PNytNQjVCTEVWZzV6VnRHRURuUjRmQXpjU3RXM0VveVJKUE9BeVFNQndIcUVlXHJcbiAgSWpxTjJFeU9qeVRSbGlIT3FFMzlRMlNCaTRlVVZVL0krbldMN2RsMTZrejMwSXR1azlhVWZEdlBMYUxJZDJXNjMyOW9qelk4TGNZRlxyXG4gIElHYUJVSkNQbUFmVDNKUlVuYUxwak5iUEtlRlFnR2dZV0YzYWllTFduaVZzWXlKMmZvUm9RQlRxMXMyVjBna25tM3R3Wm94bXZhVGxcclxuICBXdXJycEhMSjgvWmNRVkNJMW95RG9wa0VhRXB2MjhIUDhGdjM2S2ZsL2ZmZmw4NlVEQ1dTN1hMeUNjZEl4VkIzalYyN0p2bGg0NE1NXHJcbiAgZlJnNk12YmpObmZ0MGIwNGRKcDVOcytIQ1FQVGJYUlBXVHBSZ2ZNMG4xMEtUQlFRWVNGeWNvZytOd3NTbjU2RHR1RTVYY3VzZnZWMlxyXG4gIEl4em9BZGcvSFBOdm5nWGlLODdYcnBsck9pbGJNS2d3NHFqTEVtMXRmdmpUNXI0a1hRa0VmcS8yKytKLzdCemdrN0pPSlZCM1c5cmNcclxuICBwVkJMOHpmT2ZWZ1JQMWFObmVaM2E5MmJmelBPaEhTb1oyRjA0TnlSM1NPWlVLRHZnUXNoaEF0a0hOQWI5RWhtNmFqbFRTZGs3WFJvXHJcbiAgUUJzZVFtZ1k0NGltK1o0Z3BKVEYrQVh4SjdwQzlocGhZb09TM2V0NVc5MUR2aGQyOE1SU2tYUjdTNU9PNlZFbTJzTEtFck5mSEpyQ1xyXG4gIHhiTVd6STFZTUpOTzlzZmFpOUpqOGlybHJiZmVrdC8rOEF0eTZiVVhKNGdFRU9MeHZNZisvWktKc3A1OTduVTU1ZVFqdXB4NzRzblhcclxuICBUSUg5Y1FPTEFyTnlKMXQ4K1pLblpQU1lhQjNjSGdBZldjOCsvVWM1ZU1xNXNtejVXbHU3OHVicysremM4U2RlSnErKzdPT2pOK2lpXHJcbiAgQTZtdjJpQ3ozc0tTQlIwSU0yaitZNStsZmZBV1NmNG04aUtJcFJOMXZhQkZIVFR1L3hIRXpsblUwNGxmL2VkbEdqTFRSRWwraDlSc1xyXG4gIFhXMmJvMGdiQzZOY0ZJR0xqc2JtVnFzSC9tMXRiWkdNQVFjWXNtVUE0dDZiUG1HcXlab0RBTzZEV2JmM1c4OXFHTmQ3SkJDb3hRTmlcclxuICA5clFoUXB0VnVYZ0dPM2MrR0FZMnhJcVBCVVFDTWNGS0NOTmF4RG1JbjlBMXVGUEIwQzd0aEZEYmptWnJ6TnhadEdkRVpLQzdKdUdhXHJcbiAgRUE5MEZPZ25zSXBxYTl4aEgycXlUNFMwN2JOcDJzVGhvZWxLOU1QczNESkhLaXRxSkVNcEw2dVQyWjJ3Slcrb3liNGhCTUdhaGJxaFxyXG4gIEwrRlpZRkZsQzZvMEQzazhvaW9JQjRzVnpWZVRGa1AzVWJWOHR2UWZQY09KZHJnbmZSZmgvcWdQVjRFZFArMndDUk1FZ2JKd2NFSHVcclxuICBUWnZjNS9hTmkvUURIMng2SGZvSllxWXR4Q1doYjNhdmR0LytYRDNVZkIwL0VLVmxzKzZWcHBaVzZRQTVLTlJ1M3k1bE02OHdSNUtJXHJcbiAgUExFaXlpd29sZEhIWDJ1eldOTTk2SFg2anpsY2ljRmgrazczTjlmdy9aWHdnOGo2alRuQ3ptUDloR2lVQ1FSSWFQQ1VUOW9Zd1RBQ1xyXG4gIHVUNHozY1dQZmt1NTBIZk5OSGpML0g5Ylg2bkxVTEsrMnhnakd2V2ZEbW9ZbmduakNnUTk5TEFMVEhURmVnUzJqRFVPVENjd09GN0VcclxuICBvMExTZTRMSWdpZHZGand6OFAwTUh6NWM4c2FkWmRlSi91MDZpSGg0WDdqRVI4VEhHYnhTTisvWTRrUkZDOEx4MFNZSmE5bmFUOGF4XHJcbiAgMUNJT1I5MXYxR0ZHTEpvUjQ2WmxtdE5CeEZ0OGczeHJGU2pOYmZKRGU5NWlDQmwzN0N1RDNnUnUxcjViblZUQWxmam1XV242UEd1TVxyXG4gIEc2OWgxMEt6V2d1MUhVS003NDJ0a2ZIenhrTEsvTktSOXQzWndrSWxGaWErWW1KbjRVYXJ3N2NhSU9wZW90MU5TOStXZnNYWmN1ZnRcclxuICAzOUcrWkNmV2VoQldWZFhLeXBYcmpFQmdlWVZpdmJMU2RRaWJOMVZheUJIT2JkMWFsZENOZkp5QXBSM2JOcnp3NGx1eVFvbkJoUmVlXHJcbiAgSHAzWlBTeGZzVTZPTy9aUTJiSzFXdDU4ODMzRkJ4MXkxQkZUcGJ4OG9Oejc5NmZrQ3hmdHZnMzlpcE53M0ZIUkxERUI0ZEVCOFhnRVxyXG4gIFBiS1NHY25YQ2ZTc0d5K1pBSXYyTE5zZG1xdVh5Ylp0T3R2UHl6QkxHdmI4cmRjQjF0VGVZajd2SVI3cHlwbHNxMVdra0pGaW9pdmJcclxuICBPRW4vZGxVc2pSVG9jZUpCU2ptUkxVc01lU1ErRk1MdThTaHRpRW9QMG13S2hWd2FvdUVmdXlJR0haUXM3R0tSWXRnRWlwM1ZVRUpTXHJcbiAgQi9rc29TTzVnT2lpZUlTd2NYc05BalA1TDZ4N3Badm9tcUpjdVJDSUV0ZlNIME5nOFQ2NVdNREZWaHhZT1NHbUNLYTV3NFpHK2lGY1xyXG4gIHZtaXdlV3VsY1VhaERXdkhFSDR5YlllbUVVOUJOSUpWQzNYZ01DQ2lXSmFoZzBHY1Z6cnUyS2c5K2tOZklHWmVIakVVcHFyYjE4MlRcclxuICB2cVB4QitYM3YrYTFQK3E1ZWRiUERlODhhTWdSWW9GSWFzU1JYMDdJMUVONVYrUkh6ODc2NiszWDZDeDk1WXUvazBXUGZzZmljKys1XHJcbiAgU0VyVzNtMXJoZndOdWd6LzhFTVBNUkZIcXJZQjRrTjNRbnQxK3U1UU1yTzJnZ01SSFhuMU9tYnF0Vy9FdzBFOTZuZ2IwKzI1MU9rMVxyXG4gIHlldGpSTjM3ZE1pbC81UXlSZkxvWXlCRzlJSjNQUGZ1enhsWHNmcVZQOWg5aFBzalROeGJGR0tsUlA2UVF5OHdKVE9UaTFISFhKa2dcclxuICB5TUVDajdLTkwxNmh4TU1uV0lUbW9kcmFTaDZjRFBHUzhjZVpSUlJ4dUswaTNuSDAvbG5ZdWY2dHZ4c0I2Nklmc2REYklJN1ZGMkV3XHJcbiAgV05BVHBsakg1SmQxSlloS2M1VVF3bUZ3THRsR01zVDNIQnlHY1N1YXR2Vkw1dDVleS9PbmVYQVhMRzRrSkoxOFRzbDdJb1Fnc3M4UFxyXG4gIDN4dCsyaUFtU0FIeStydkxJQ0NVRFc1UGFJdnI2by9sYzVTbnJaT0MvQXk1NDVhdlNtNlI3OFVPdlBHNjZ6TXdwUTB1MDRQbFZad2pcclxuICBJZXgrcmh2Ni9kZ0FjUm5PRXA5VElyS20yeGEwdmNIUGZuS3RuSERTbCtXMFU0K1M4ZU5IR2lHNS9Nb2JiY3o4NkFlWHkrOXV2VDhxXHJcbiAgMlJPNjNNSFVtUzYyR2xXS1MyNzdUMElpNFpINGJ3SzZKUTE2NVBGeW8yZ1BTSjd3bVA2R0xOaFNUZUR2Q2pma09NTHJnUHZRWEt4S1xyXG4gIENrYWVJRm1sazJSZ2FYOG1tOEtXclp6cjJEclBaOU5SUStiUlZvR0JFcXl2YUxlVlJYSmx2dENQdEEraWVOd0hsTFdqNlhEZU5vWHFcclxuICBNMWhuYTFVMm0wUUJ5RG5hQjVsWXFBZ1NKUjREM3VXeERGZ2Y3RjBIdktZakJOaFF2VnBLSjU1a1JBbml3ZTV1NUR2eFdCRWhETytmXHJcbiAgaWEyb2EzMksyb3crZk1xRTZ3UlRTVjc3eHFJVHVSTk44eXV5ZlZ1RnpxcDhUd3Y5c1hKZTM1RTBpQU1rZ3RpcVV6bVdoQ211RVk0UFxyXG4gIElsRlZwNlVSczJEaFFsdlduaElQMnFFOGhBTXhCUit4aWFRc2I1Nlg4dzdaK2dwRUlHMDZhMFFuMEgrL1l4TDF2VDhnNjNDL3RBL0JcclxuICBlTmZXYmJ4M0Y4allrVHErc3Nxbm5XL05UcnZzQWRsU3dUNFBPcm5BWkk5TDZWRzlEYVNxeEVTUExSOCtiV0ZoK1VHeWJmVTdKc2FxXHJcbiAgV2o1TDIzN0g4bHRabWExOTRtaldXVEI1SEZ5YnN0UlovdXpOMW5CaGhEdzVSejlCVHJqQVowd2diK2NleU9jZGp6citxellCd0NLTlxyXG4gIE9pOStkMnlDb0NUMU1ZUmhRdURoeUdPdlNialVMOUZuTk8rdkZ4dXloS3ZqV1N4ZXZFUWZqYnVzUjNsKzhNRUh5OXJaZjVhMXI5L2xcclxuICBiVVpqeE1lYzl3Y2RCTzhTTTJCYlMwSTV5dWlZNFgxQkZPQktQRDk2djZFTW9iVUpSK0s2RVJNdndwMW9uQWxHTVBmRjlEelJkdFJHXHJcbiAgUEN3c0d5OWJGendaaVdSVGpJaGdZY1g0SjQybEZ0eTRoMkZ6cXE3ak51UkJSREMyeUZmQ0JRY0NFV2xRRGdRaVFuL2hSbkNNNk90RVxyXG4gIDRrUkUyK05sNnJGMDZWSzUvckl6NWNUVGxFREc0THZmdTF4Kys1dS9XVHh1c2hzQVF2SFUwN082RUpGbTVZQ0JvM1RDenZxTGp4dmdcclxuICBRSzY5NXJNV3YvWnJ2N0J3WCtEd3d5ZkpBZEVHZys5L3NGUVdMRmltZlp3c3YvbmRBNWJYRzNUUmdRQjV4Wk9sSURWSEprK2FLdTlzXHJcbiAgOWh2bEFkcHpOUEFJenplV3FaQXM0dzg5QWk4WUExNXlGTzFTTHZGajRESDlqYkxRTWJDYWZFREtXbG0wYUtseEgrMnQ3VktVWHlEcFxyXG4gIFE2WkxVLzBPRzJDRnNrMDJyMWtxemJ1MjI4d2FHSHZvcVZMYmxHSGNoMXRkNmF4b3F5dU02WXpwRnBRbDlvNXh6V2pnRUpKbitXR0FcclxuICBrK2NEZEx2T29FMWV2MjZ1SVRvblN1VjZYZjNjZEdDeUpXM2NDbVhieWpkTTlCSFNZWUNIOXF4OXJXZCtnVXovNE9kQnVvZ2wrSGhvXHJcbiAgczcyWnJZZTliOXlQOXl2V2xvbHdvamIxajlrOEh5MnpQdmJ5eHBxRnN1Lzk0VXd1aHhSUTByV0pRNjU4VkRrU0pTTDZSeHVVb1FVSVxyXG4gIFIzSDVKRU1BNU9tUEI1VFRDTndJSHgvS1NEOW5KeTF1Q0VYL1dwdDIyS3dTdmNhSW82OHdVUTVicmRyelU0VEtiQk14eGVaNWp5cGlcclxuICAxQmsxYzV2b0d0NGExNHF5b2tpTnRvSGVBaDBGKzdzd1VTQys4cVhmRzBKbVBGUXVlazVHbmZBMTQrTFMzdnEyekg3clhTbkl6WkdkXHJcbiAgRGV3SGtpNERwMTJvcytianBWcmZUVnREbmUwSGtnUy9HdmZGSktFckpEK2JtbFhKUlZjWVNJQXdFWVBpU3dzUlhMN2UyK2pqdjJaalxyXG4gIGp2UEdMVVp0MHc0eGtEeDlod2lCcE5rQ2VOVkx0eHEzc2t1NW50YUc3VExxdUt1anErcXZSYUkrYUdXVDB5dEFkUG9NbjZiSFZIbjVcclxuICBSeE9zWGFDa3BFUU8vTXJMWHM0eS9ZVEorYkhkSVF6dFJPY0o4SGlNT0lveGlBK3M5TXhzMmZEZVE2WWJjaS9WblU0c3FHdjFnaDZpXHJcbiAgMHljYlpoZEVzVTc5M2liWTRsS3VBWUhZanJjQmJTT2hEd2w2aDVoZXBHcnBheVlxdEhWQ1dzKytVejNIV0NiT251U005UTd0VDc0U1xyXG4gIENtL0w5U0toamQ1MElueW45ZFhyckUyYkFPN2FKaXlZWllLSEdCSUNnL1NBdWkyclg1RGNuRFI1Ly9XN2Q3dmZlZUFxV05XOVlvV0xcclxuICBzbTc1OWQva3VtOThJWEV1eVhuRWRTYnpOT3d1K2ZtL3c0NGR1MlRRa0dPa29iRkpOcTkvUlFZTmNxbkw3bUR0MmsweWE3Wk9iUFI3XHJcbiAgdmVhclA1ZTY3VHZsc3hlY0puLzd5MC9ralRmdzJOdWU2SHNjOUN2dEN1Vmpwc3JPamthWk5lLzFLRWNoalBVSVBObHJabGZva1JjUVxyXG4gIFR6ZXd2T1FKaitsdmw3SXBNcVc4VFNxM2JMVk9vL3hOMTRFemRPaFFhZTkwRnd1VXljanJwelBnSXNuSTBFRmw5WlFicWZ3b1Jqd1FcclxuICBYU1dKQjNVNjlTTkpnRjJXbjRBSS9YQWszVFhNTFBDVnlTN0hwcHdpRUVWb3ZBVEVWaEFQeEZZTWNBYW1Fdy9xN3A1NFdOcXU1L21HXHJcbiAgK0xMeWZPYWw2U1R4Y0ZiZlJWVmV6K3JFaUFjei9SMTZyeEFQTEt6NEdPQm1rRk5qTmRPblR6N2ZsWGt1dG1ZYXE2TTJ2QzFtK1JBUFxyXG4gIHhEQWdNVi9UQWRlQi95VXFPQWRpN2xxUVJXdGVlRDdXcDBqZmdaS1dHYVNKOTdUdmNCdzRrQ1JPblk3MlpwTjdZeW1IcWEzUHRQMmNcclxuICB0K2NoYWNSUnExNjV6V2JvL1VZZkppT1B1ZHphTXRHT3RyZEtpUWRXVFZSREx6VDZoSyticjdCbFQvM0V1UTBGMW4rQXhIQW1PUDdNXHJcbiAgSDBzL1JWRDduZm9kbVhEdXpkcldET2s3T2h6VDdVQWNhUTEyT2Z3Wjh3bFpIVHVteStnVHYyNm0xc1FuZlBMbk11M3lmOG4rWjk1a1xyXG4gIEN3VUxCNkhveDVSN3MxbmtzWTg0YlVBMEtMOU44MHgvc1BGOTQ2SWdwRndmdlZrZnpjZkFZZVZMdjNWUkZ3U2VseGFGUVh3SGtla3pcclxuICBhcHJVUC9kRmU3ZEFoaEpLN25YMXJEdGx6YXcvYXZlanZ1dDkrSE4xN3NhZmV6eWVZZ2ljY3J6N2pHdzhKT2o3VWtJLzlMQUxFeUtxXHJcbiAgMEY1NFZ4NTNzMjhzdGZSUkc1SEJTcTZ3L0FEVGwyQ2FiZU5TSnpkTUxCSnQyRUQwK29RbDQ0NjJkeDQ0a2NvbEx5WE9tOG42Z0xHbVxyXG4gIEcrTFM4WHFFM3AvUXY2N2lMRGdSenJ2WDYwM21uNHQxU1V3V1dHU3BGYUs2K2d5cXF1UmJWNXk1VytJUmg3S3kwb1NMOURqeFFQY1JcclxuICB3amhBUEZnYjhuRURZdjByTG5mdSs0YnYvTll6OXdEb1l2NTI3My9rbkxPUGszNzlpaXp2Z1g4K0xaV1ZOZHJIeWJzMTZkVW4yeFd3XHJcbiAgd3Nwc2pXZlRoUUJSUEo1bGtNelFSeDdGZ0I0Rlk5RDd1ZDNsZGlxU21mWDZMS21wcVRPTHEreXNkSjNaN1MrMWFVTnNBSnFsbFpaYlxyXG4gIHQyYWxEQ2dmTFZrNTdzS2Q3MnZ0bWpYU3I4U1Y1aUJrSXlRNk1BQTI5Q2tJb2lzR0REM2dsSjJQOHFKem5zZXpVU1N3ZmF1eHdzektcclxuICBJU0FvZWhtTXlIa1p3RW14MVV5ckI4THl0c0lnOTdnUGR0cjJmUHJIT2RMTVhoSDFJT2NPNXpWaUlUUDJSRHYyMGNYYlRqUGl3VG9DXHJcbiAgNnZLUm91RG5JNFo0WkJmanlpUlYrdmZ2WjBnR3I3UjQ5ZGp4OWkyYTdXMmdLR2NHQ1hmQjNoTThJL0p4Rzg3SEQrRUFHZEl2Vmo0blxyXG4gIG41SFhoM2p3Z1NOT2NaY2t5Z2xCakl5SVVFYlQ1aU1MTi9BNUNiTm1GODk0Ty9vVDVTa1JtbjJYRVdVUUxPYW5XRDRoSHNLVmlCYUlcclxuICB4RllnOEs4WmdvQTdRVmFQYUlsMnBuenhYc25KempKT3E2MFZRd3NsL0RrNVVmdCtqY1R4My96RjZ5WDZEd0wyWjZNSlAvU2VNWmtkXHJcbiAgZmRMWFpmQzA4elQ4aHV4LzlrMDZUcWJyYWUvLzNMc3VrTVlkV3hNRVpmV3JkeHFITmZxRWErMmVXSi9ETzBVOHVGVTVLMmJ6cTE5R1xyXG4gIGJ4STlyK2g2OUFPUkM0Qmh5ZENoNVRMczgvK0p5cVVZSWNGRkMrVjg1cEM4QjlvSXo0UnhCR0hHclR3dTVwblJJMHFGbUZDTzhjR3NcclxuICBQZFFQWThmcmFzakhwNkc3M0dmQ1ZaS1l2QXlZY0pLR1BybUJDekhkWEd3Y0owTjhjazFQbUtaajJJREZZUkRITXNaQ09kb2xURnpmXHJcbiAgM2tYM05oa09uRlBpb2MvVXhGY1JFWUZiTVVMTXVZaVF3SDBNR3pwUXp2OE1FNVRkQThUaGxsLzl4ZUxmL3RhWEV2cVFsZEY2akNEZVxyXG4gIGl1dEFmbldMdTNvLzd0aHBsdmR4dzlldS9aemR5NzMvZUZMcTYzMjN4RDBCN2szbXpsMHNQN254R2t0amFQTGJXLzh1dGJYYk5jNkRcclxuICA2d242Vkh0Q2M0dTdQRERvVnEvWFpuckw3SkVYdmJ6dVlIbmRUMmk2VzFiajF2blMwY3crRm96VEZHblRXV1I2WVpuc2FnRUIrV1pSXHJcbiAgb2M3Mjlqd1pNcmpNYmk0akk4MDRrYUpPcklZZ1JEaXY4NElvOU14Um1uVk0rMmZYN1JxM0Q0UEJGOHNMbmxZNXg4Y0U4V0Rtd2t5WFxyXG4gIDg0Z3BxTk9xYkRFaDNJZlBrc0xncGwxQ0g2d1c2bzFCUERpU0Zpb3BKbDdCQW92eUdBUFVtM0xSOTFMdytsSG9EMGJURUE5M0xRR1JcclxuICA0WU9GaUVCazdRUFROdE95Q214bU9HS0U2NE9jQzlIQnZuS2xwTGJ1Vk9LeHdMZ083czNYY2tBQWxCdlo4SUhzVUtUQlpsdTRFOEV6XHJcbiAgYnVMNTBBY2pERzVaeFdJNHVDYk1NSGxzL0NCbW9IeW93d3lWME5ZK1JHMVlZUTBwZ3lKNjhXTTN5SHQzWFdpRXE1OXlCZHdqaUhqa1xyXG4gIFVaZHBTVGlPVysxWTkrYmZqR2pVckhKOUJKekF3Wis3MCtwdzBCNXJQM0JiWXR1NUt1VGx1Yyt4K0FFWEFBTGY4TzZERm5LODg4ZFBcclxuICAyYkh3WDkrVVpjLzhYRmE4OEd0Wi90ek5zdlRwbjFwK0tJZStaTVdMdjlINEhPdURJU01kYTNiUGhQWit1TTl3UGU0MzFmb0twM0h5XHJcbiAgcnphWUIyWHVpd2tLQkpQenBsL1JNUVdSR1gzQ1YwMlhOa2dSZTI3cFNDTW1MM3huakJLUzI2d2ViV2JOdWRZKyt1enNUR2xwYVpQUlxyXG4gIG94SFBvalB4OVRIMEIyL0s5SUgrY0t5Wi9TZDU1YWJKU3BUMW1vYjRPZWZucVV2SUt2bStvMllheDBsNis0YjNCZSs1RUpJTjd6NWtcclxuICBrdzR2NzNWRHZSQm5XMXNtRFV4a21KU1F6ZjR1bk1PRkRtS3ErUFdTSVhxKzhTYXVJbVFzQnlMQzl4dzRrWVE3bjFpOU9FRW5Ed1UrXHJcbiAgSHFWdG5ZaHlkTGdEQ2tTRWZVWDR0aEZ6WVRVM3JxUkYyMitTMy8vc2NzbG4vY3hlNExwdmZqRkJDUFRXYkdYNEpWODhKNUczZHAxN1xyXG4gICtRand6ZXZjRkhqbXpNbnk1bHZPdFh5Y3dNWlBYNFdJYVB5V2lGanRDU0JxdDk1MnY1eHcvUFNFbnBDZEJ4Y3VYQ0UzL3ZBS3VmTHFcclxuICBuczRhZTlXQkJNZ2VGRzJ1YitBUlhub3NVMEhqVVZKZmwwY0FMeGdEWG1ZVTdWSXU4WlA4alowT2lWMXJYemF4RlFBSE1ucjBLTm1XXHJcbiAgNVZ2UmVwbW9uaDZJUTRZTUhpS1ZheGJJcmgwMWlyZzZwYWd3VDRyNzlwZW12cTZvcE9DdUxVdWtnTm05eG4yUWUzNFk4S1R0bm16d1xyXG4gIGVjZ0F3MlljV1Q0eTYwQThrZ1BXUXh1VU9zUHBtdStET0JrUGJXdGFrWXZKeS9WRGNDSXl4dHd1SUhiQ3FnazNIb1JPUExyMktkNE9cclxuICBpeFpOYktCNUVBKy9sczcrOHZxWitTTnhROXlHN0JVQi8rTThxYXl1azNRdHhqNHFNNzc4SjltK3MwbUp4eVRqZmxnckErSFFLOWl6XHJcbiAgb1g3Z0tFTGFueEhKRktsZThZYXRJV0hSRm1hOUVDT0lDTTcyK28xUnJxeDZuU25abmF1aUVrQWZDYjB0RnFGdFd6Wkx4cC94STBPZVxyXG4gIG5LTm80RFFkc1NySHBQZUhROHpoUjM3WlJKTFdqd0NKdHBPdzlvK0h5K28xNitFRnBVWEhSSDUrbmd5Y2Naa1NuYmNVYVF3M21YZUFcclxuICBNU2RkcDBqN0xZdkRWWEl0OXE5M1NMWnRIS2NDWldtWHhYT0lhbkFmRHhHQUUwT0VoK0lac1JpbXB3TW1ubVFFUGlGalVqQU8xU1BoXHJcbiAgSjRKTzJUVDNVVm40ME5ma2tNc2UxTFJQVU9qQktPVk1zRFFiZGZ5MVZtNlZjaVBERHI5SXRqOTFrU3o0WUtGT3NqcU1pQnp4ZmVYMFxyXG4gIEFMMmVYU2U2THVQTHRoSFE5T3BYN3pCOUZKTUNQNjhsbzlEU2VyaE9vVk53NUluSTBoWjBLbmRSdGV3MUkycTBiWloxU21DR1R2OThcclxuICBWRGZvSXZ6YWpHMUVpM2hhM3ZET0EvcmU5RGtvcEdabTJ4NHdyaGNaRjlXSjZ6RThORzVheHdBaGJtUnNnZkRXWldZOWlSRUlSSVp5XHJcbiAgckJIeWV2RTJrdm9SVnN6am50MmVnWDYvakV2eWNiWllqd3NVSmVTclo5MGwxMTkraGx6N3pVdGx3SUM5RXhEZzV6LzdzOXp3blVzdFxyXG4gIGpyaXFxOVZWei9VaUtOaFArOFJSMGJtUFh4K0NUbWJ3c09Na1B5OUhkdGE5RytYdUh1Z1hTeUpPT2UxeXM4YkMyQU5DZDlPUHI1TDlcclxuICA5ajlIVnEvd3ZVTUM2SmZiRTFJYUkrMUJ0Mit3NXllcDBGdG1qeno5dEhkYnJ0ZFd1OERZZ3RvbzVxWHpjbk9NZUlCUUhIUkd0VzFOXHJcbiAgSWc1MHBPVkkzOUl5RTg4QWRUdnFaZWVPN1JyanZPOXJicUlyMHRZNVB4d1pSL0hvWE1nak5LU2dZZUJBVUdvbk9ROUZiQm9HNGxHalxyXG4gIHlKUjBrbUQ0MFIzcDgyR0ZOSHREUXp3dzJjWE1HS0xCZmZZa0hzazJMVlFDeE16UWlRZldMMG5pZ2N3WjhSR0VJOHo2UXowV2wvRjlcclxuICBBVXc2cWw3OWhkVWhFLzlFVGp3MHJVT2xTQW1IK1Y2SzZsTE8rK09lWlhFdHdrZE5jV2FET0lha0xLdW1jWjNQR2c2NEFWTzZVdDhJXHJcbiAgaDR1c0tJZTRobGwyZWthdTZTYklEeUllZEF3UUpBZ0svUnFnTS9BcFg3aEhEdnIwNzZTb2JJTFYxNS9vb0czNjdCd0ZTdE4zN2p4WFxyXG4gIDFtelliTlo1SEtuNk4zUkl1YlovdUJ4dy9tK1Z3emxZQ2R4TUdYUHlOeFhSSDI1SW1zV2xuR2YyRDlKems0SlVYN1hObjE2clp2WGJcclxuICBlbzIzelRpQmp3MEx0WDQ2UzhlYWlicGpsTHVZZk5IZEZxYy9FQkU4enE1NC90Y3k2eGN1M2x6eHdtK3MvNkhOTHZlaTEyTjlCOXdKXHJcbiAgejQ2OVl0YTljWTkwY2tyTGp6N2hhNGs2bzQrNzJnanE0c1dMZFQ3Q2N4VVpOc3hOczBON2RoMDk4TSsyOWNPblpjMnJkMW9hcDRya1xyXG4gIDBSYmw1dC83WlZtcjc5UDc0a2ZnY2hHbGViNXlpVG8rV05mQ2VialNQa09uR0xjSU44SjVxeGZxYTlvVy8ya2N4VHdyMTYyTUFtMEVcclxuICBrVlpYVGlTMDRTRWNDSFdRT3JCZ0YrNkRkS1p5cFM3T2NvZXBjVTRrMlVabzA3ZGZabjJPaTdFMldCc0o2eXdscXMwcm41SHlRZjNsXHJcbiAgdTkrOTNQWVIzMWVBZUlDRWdUang2Szc3Q0FEeENPS3UyYTkvL0dJc2RESkhIemxWNnVzYjVWK1BQQi9sN2g3bzYxZS8vZ3Y1eHRjdVxyXG4gIE1pNEVNZGEvSG5sQnRtN2RKci80MlRXSmV3dWdUN1FuZE9aMHovYVg3RUVVTjBqR0dmeEppTWU3USsvblBGZC91NXoyeE1hTnZzZ25cclxuICBIVTVVUTh4MmsrQmxXUGpFSUdBMmd1aGtaMHU2Tk9XT2tEUTluWldKMDNkbGw1V0E5RXVwa0paZFZjbjFIdjRmeFluNTRZTXUrVEdIXHJcbiAga1BVZXpHSnl6YytXSWdSRnFOajBjLzhnQ1dhWXNNWFU3N2ZmVWJINnRFZTg2NEN1WFBLaXpWb3JGdU45TkVWS0o1eG94SU02Z3c0NlxyXG4gIHc0aUhtK21HUG9RUElkWTMvYWlaa1ZuZk5BL1RTVUxPZ2F5cmxzMk8xZzlRSnk0WFRwSENRbmY2Q0xDR3BrMFJJUGx3TXVaMlhmOG9cclxuICBpd3dlNHdEaW9XN29UOU1PWnRxcGVuMW1XZXlqNFNLcEJrVjJWSWZ3K0w0ZjRSa2s3NTg4dUJQY1ZIaWEweTZhb3Y3S2wzNm5iYm9ZXHJcbiAgaDN3UThvU3pmMkxJUGQ2Vy9sZ2NFMXM0cDNmdS9LUThlMTJaMUs1ODI4UXNZMDc2cGd3cTZhdmNxMmx1SkZ2dkZlSlpxNXdEYXlmeVxyXG4gIFM4Y2FJYTNSOG1rNkc4WThkKzBiZjFIaU1jZXN4T0F3UUlvdFRkcit6a3J6WGtEZU5uM2ZpRUlRei9VWjZjU09mb0FNSVVnUUg5SndcclxuICBYNXhqRFJMalpLd1NxbEhIWFdOOVI5Ukl1V2V2RzJ4ckZYWkxVTFRuUXc0NVg0Ni9hWWs1L1NRZklyQlNuOVhLRjIrVjFTLzlYbGJkXHJcbiAgZGF3ME5iVUp6a0RUbEZWdkczS0tySDdsZG1zcitieDgzUkFLOTJKOVozQWZuVzB0bXUxbFdGd0hOekxpbUN1c3JQZkI2eVhpa1dnT1xyXG4gIFI1TGsyeHFnMUhRbEtIZ2xRTytCd1VYWHNVYmJwSXZMZlFKaFRpNnRMUmFrVnBpalJNUzFRYm51ZGIyT2g4azIrTjRKZzNHSmliR0lcclxuICA2OVdUbkx3VGtXUmQrcEZzMC9Sbk52aDFmQ3YzMDdBTjRqRk1jcXZlc0RVejMvdmErVEwzdzVVUngrQWVPdllGOUFvOW9Ec3g4VFlkXHJcbiAgR1d2UERMNy92Y3Zsb1llZmkxSWZIL3p6L2wvWmJkN3dYYjZsZllPcnI3cFFCZzUwcjkycjEyeVVwY3RXeXduSFQrdWhUTyt5RWgzb1xyXG4gIDRwRzNJRnBzcHJkb041bjhjZUNsUkJDVjZGbUdNL0hrYnNwNVRIK1RXUW9wY21CSm83bGk2RXpwbEk0VzVZejB4UThjc2I5VWJObGdcclxuICBNM1ZlMTY3SzVXTHV4YlU4OG5sQ25DT21aZVpMZHV0VzJkWFFKS242QkR1MGVscEhnelMwc3EveEFDc1hCaGJ0SkFjWllaUm1PR2pJXHJcbiAgQmxEWnhTNjZRbDZLRlJCc1BCOGJGallnQUJZSndocXp5aDJUWFpCdUdLd2hqTWRaUVk1cmROSzJRbHhuUkRnaFJObklyb1VRT2JiUlxyXG4gIHhRb0ZaVGI5OFBxeE1DSWVRU1RrN3NOOWYzVEVDeEFDbEpCK3plaUR0YmozbzBIN1g3V090UjBRYUoxZGEzdGx4M3pEMXJka0s1ZmxcclxuICBidW1ubWlWWXFCZnFvdWZBVnQ5WDc0Wm5pTStpMlpLWjM5ZkVFNnhqNlRmcVVDdnY5YlhQNGx6SHFwZC9yM2srZTJRVEpuL0d2bXJkXHJcbiAgbnUzT2lraHNOZHJ1d2NRdDFuL2tzNFQrSE9BQ1dPa01CNWllbldlY0dvc2loeHp5YVZ2QUJsR2dmTzNDZjl2NklTaEZjWi8ra25ma1xyXG4gIDk0MmpYUG44cjR3WUlNcGErY0l0U3NCWFM1MitUeXgxbUN4b3orMWFJQzFjdXJQVk1Sd1diY0oxc1BpUS9ieFhhTjNhVlc4cU12K3RcclxuICBiSHIzQVczelRhMkdXL2NITmYyUWNqZlg2LzBzdDdiZ0pOaHV0bGF2dzNva09MZUJCNTF1eU5WRlp5a3k2NmVzeTJKaU1vTzd0YlpzXHJcbiAgVE9vL0NKSVFwRm1yOTczeDNYOGFrc2hMM2FISXI5YkV0aWpQeDU3L1J6TlFnRWdiQnh1TloydFFBV1V4aGcxdzFJU2N3b29SSWd5UlxyXG4gIHhueCs3ajJmdCtmcHBzelU1UjJtNkxzcU14OXk3azFhZEp4TXNqaldXZXZmL0t0NWZ1QVptcWRlYWtUWEpJNzNBTHdYNVBWbGxianZcclxuICBldGpSMnFqajBMZFhTRXZQRnZhMDhicFdPd3I5bCs4YzAxdmVCYzhBTTI1V3JWTU92QkJFVWxsS2xCeENDOGsyMHRJeWJUMktXV1VSXHJcbiAgNnZqQ3pRbUVKeXUxWFQ1NzRhbHkvQW1ISnhEL3UrOHVOTDNDM21EWThNRnkwMDEzV2gyc202aFB1SFRaR2hrOWVxaXRSQS9FZy94NFxyXG4gIG1XM1ZkUm9tUmFrZkI3Q284TDUvUENscmxCQ2NjZm94ZXpYcHhVdnZ4bzFicGJBb1g3a2lYeWlKMTQ4alprNld1Ly95SDducUsrZGJcclxuICBIdEJEQjlLNGM0ZjBMM2NmTGRsbGJtb0orTXNQcndEUWVKUk12aHFGNUNpSm9PdkFTWUJGUFozNGpaME9pWUdkNjJUSmtvOFVTV2ZvXHJcbiAgQUdtVi9ENGwwbi9rRk5teXdXY1pOTTVIYVFxMURwVHNHWjVubk1oNC9jRGJwVUtSWEdkSHAzRXdFSkg5OXg4bjFibVIrMnJySEgwa1xyXG4gIDdnak84MExjdzdwMUg5Z01INFR0Q0RURnpERkJhbzVVVVV5eU9DbTV3cHlaVlNnYlYrU0ZQTnhSNUNseWhDQkJnSkNiY3g4Vk9xdkVcclxuICBaVGF6dUYwVnkreERUdllsSUFDL3BwdnB1cFdXY1I3MkhKM3pRRXpnQklvM1JEMnZZL1UxaDdVWnpadmVsVTJ2MzI0RGw5ek1qRlFaXHJcbiAgTzNhc3BFeENycTRjRnpMeHFMelZwWlNHbU9LRy9JQjQ4TW5Vb3NpQVdUYUlCMmVHb1R3bHZieHpFNVp0WjkwMWl1dGx0QzBsTmdzZlxyXG4gIC9Lb1JZMmJ3SUQ4SGI4ZHJ1TTRCd21EYnplcGYvekZIR2FKRjNnMFI2RHQ2cHJsUmdVTUF0ai8vRFZtMWRvMjBSb3RQYzNMenBIamNcclxuICBTVkkrNC9QV0l1VzdBSVgrdnlEMk9VVlJmSjdWNklRQ3dYRDE0aGRsbDg2eWh4OTFxUkxhTitXd3EvNWpGbEZzZzd0TnkzRlpPQ0ZFXHJcbiAgZC9TZCs4UWk2OTA3UGltalQveUdjbExmOEFJUmNPOStuVTc1NlBZWnNwNDlKL1JWSys0MEk0blVVV2VaRlJkMUtBYVJ0ZmRpMWNnaFxyXG4gIDR1R2ExLzZzM09vcnRtWUZjZUtJWTc1aUlrVUF2UmV1UmN4Z3hkcEsxbk1kZzhkeCtnZ0JNWS9DbG04bHpPbGlvbzUyenZVUm5jYXhcclxuICA0RHFITlZSZTJNK3pqd3NLZHlOaVZ0WjFHYUZleUdQeUZOSXNLbVI5Q01TSkNROTRnVG9tTnJQNnNicUtDRUlhdlF6ZklOeFBaZzNPXHJcbiAgS052azV6ZDhUczY5NEl3RThjRHRDR3NsaU84cmhMb2hCQkJYUVVEWXNPbTRZdy9yVlUveWw3OCtKbCs4K0J5TGYxencwc3R2eXdrblxyXG4gIFh5b25Iajlkbm4vMnoxSHU3dUViMy95Vm5IZnVTWExZekF1akhKSGYzbks5TkRTMHlPRXpEa3owVllkYVY4Z3BTUHFDMlNQMDlvSDFcclxuICB5QVBwUk5FNFdGNXZKN3JDbVB3YTIwbE5oNVJCc1ZMRWtVTktwTEp5cXhNUGJjTVdFQ25TaFdBd2l3V2NlQ0QyRVhQdFhqNTRrQ25lXHJcbiAgUVlBNlhtVDE2dFhTTjUxTlYrZ0RmZFF3UWs1K0pCR3RoNGhucHRoc21yekc3YjQ1RkY0OXcvNFRmT3pJVUxldGVOM09HYkkycEUwYlxyXG4gIFVkb09iNWVaV2tkSHF3MWN6aUZqaDR2aVBJc0lYUVNBOVVsUDRwRm9Cd0psMTNEaWdZVUo1eUVlV01Za2lJZlZDOWYyZGtEYXpMcXdcclxuICB0c29yd3MyTEEzdUVORFkyR2RmQkVjb24yMGcxNWFsR3RMUzJyWC9tRVZlSkIzbjQrWUxvWUdBUXJobXVXN1A2UGVVNmJqVnVvcCtKXHJcbiAgZS94KzhBbUczSHpMZ2lkazlZdS9rNE11dU0zTVhNM2RSMVRYK3FCL3VIQ0JFMENzaEs1aTdDbmZsdjFPdmNHdXNlcjVXNlJ1OVJ3WlxyXG4gIGUvSzNUQ1N6N05sZnlQTG5iN2FqdnI3ZVBCZEV2SXVNR1QxV0R2NzhueFZSSHlsOXh4d1JYVWV2WU5aUzN1ZDlQZlFuZWRnblJaak1cclxuICA2NnVFY0xUMmMrd3AzNUlaMTcwa0ovNWlsZld4UlBOWEtQY3pUMmY0ZU42RkUzTDlpeEtPNWJOTTdJV29xNy9tbVFKZDIyS2lzVnp2XHJcbiAgRXpFWGFmdUxyb1B0ZjFaT2VxSUhBR2JOaUxkWUgwTTV6S0JYdlh5YmNYL1dmK3NuTlZKbHhOR1h5YlJMSDlUblBrMUdIbnUxbms4MVxyXG4gIG5RcXRFY2VWaVNINjZIMkVlbDNqaVA3dU1jczl2Q2tVRDUrc3o3MVJLcGE4RkpYejY0VUpGVG83a0x6ZGcxNEhGeWprTTU3ZEJIMkpcclxuICBtYVI3SGU5SENFTmVNR25IMUJkdUpEVXoxNVRqNEFqT1F5QzhyRjgvT1pueXRLOFBXUzhEMHJiSXloWEw1ZXpqRDA0UWp3Q0JlUHczXHJcbiAgb2l4OFVRSFVDenFROEY0Z0hyVGZtNTVrMU1pOU8wRDhiK0dvSTZmS3NLR0Q1SVdYM3BadDI0SXh5Tzdoak5PT2xweWNMT093QTh4NVxyXG4gIFo0R2NkZWJSWGNSWVBVUlliNzM2cHR6MzBMTVdUeTl3VngvV1JLd2h5NG1TTmdBRGVFR0xPdkNpbytodXlpVitZNmREb3FsbXBibGxcclxuICB4MElvTlNOTnlnYVdTV1g2YUdQM0U0TUJ5cURsTVpsbHIzSHljQmFJS0tpanRjbmtxcmxGQXlTbHFjck1PQ0VnclczdGtwZldLTzBGXHJcbiAgRWJkZzE2ZXZVWnV4a0prMjZ6eEFXRmo2MUs1OTE1UzJ6S0poNjVHOW10eFVPUS9LYzJUazlZbmFpQVpwZ2hQeDBHWThXcDZaRjF3TFxyXG4gIGZZVUlnaHhkZkZVbnJjcU93NzdiaHhYYWlmZE4yNlJQekF4eGtkRi8zREUyNDhMMStzWjMvbW1XUHBTMThyR1BuUGFDRzVLK3d5WkxcclxuICA3YWFQSkt2UGNKMTV2cUVzZllwNU1tYTlSTjhwT3ZPdzYvRXUvUG53TEVEeVprQ1FhRFBGekVucE0vR2tUNjZvYm5SOUVCYWlMc1JSXHJcbiAgWnZLc00xdzlhY2VtZWYvU2UxOGg0MDcvdmlGUXl3OXRhRjFtelI4cVY3THh2WWVWMkV3eVFzNWl3UlpGWnB2ZmUwaG45Mis1dUVtZlxyXG4gIHlZWjMveWtiMzMzUTJoOTI2SVV5UmhGMStiUUxwTERpV2RPbFpXVmxLUUZxbDBFREIwckJaRnh5ZUQvaEVsQ21nc0JRY2xjdlkxL29cclxuICBGRm40OEhVbVdrTjBDWWZRL2NEcWJNVnpOMnZmSGpLOUdPT0JuUW8zbVRmYlhTYUtUQzQwNVFDNFB5Y3NSaVJPdVY3S0RqNUxPcHJyXHJcbiAgcGZLamw0eVE1UFFmWVp1SHRlNnFzV2Ryamh2MTJTQnlZbTBSaEdUTnEzZllyQm5PSzMzV0plWmx1TEd4MVNaY0F3YVVTTTc0OCtXOVxyXG4gIFA1MXZIQXljMXJwWmYxWU9iN3FtRDdQeCs5SGpQelJGTW1ucldmVEQ4MkN4SXQ1OTNYQkRUSndKb01TRzJFSGN6ZldOVi9GUUFaRWdcclxuICA5MDlPNmY3SDJiT0RROFZ2RytkeWlnWnhCU3ZyWVlxMXcwSmdWa3VWN0grOE9lbzA0cUh2QW4wSWFVU0g3RVVlYW9aZnZua3p2ZFhKXHJcbiAgRzk5OWl6NnJiSnd2NmdRQ1o0NEFZODYrcmJ4K3duNytnTGNRK3FBNFFldXQvbkNXbFBZcmxNY2V2Rm5lZW1laElYVTRqOGVmZUZYT1xyXG4gIFAvOFVlZWVkRDIzNUFLS21mWUhKVXliSUF3ODhKUWNjTURZaHRuSWk1T0txNnVwYVUzTC80LzZuNUVoRjhGbVpHZWJBRUJGV0tQTnhcclxuICBBVTRXVjYzZUlPKyt0OGlNa09qSG5vQnJmL29DbmJ5VTlORkpQSXUwZlhYN2tDRUR0WTJQNU5Jdk9ZZlVRNFIxOTEwUHliWGYvS1hGXHJcbiAgRHh3L1VaWnZaOE1kVXVHUkF4cVBrdUVGZU5DMWpOY0wwSHM1aitsdk1rc2hSUTRzYTVKMzMzM0hYaGlRbFpFcDVmdE5rNHFHc01GOVxyXG4gIFZFY3ZFdWM0OEVtRktJajRMcDI1RkVRcnpyTzJ2V3VjQ3l3WXdPcnJxVk9ueW9iT29LQ21QVWRhSUR6UDg5azJ5bUhZWGQ4eklWVmFcclxuICBGVEZrNW9VRlZMZ29lYk9YVmVaSkJHdXpyWWlJQkJOZGtEM3V3cGt4c1k4SEM4UUdISENxYkYzd2xMbmtLTkgya24xSzlvY3djRDBtXHJcbiAgcHRLWm1sbXo2TWZIdmVPL2FPQ0JiR1ZMM2FoKzRuNGdIbGpIaUJHUFlHR1ZXcjlSUHZqUHo4bVdkR1hpcURiakJyd3lleHY4SVNwb1xyXG4gIGIyM1FEeFU3ZW1aV25OTkFmL2o0NkRQUGliS2hIbUMrb0N4TlNtZkF5bmxnaG92NU16TDBocHExdGgrNDErSGY2MUYvMjhxM1pkMmJcclxuICBmNVZoaDMvUnppRSs2V2h0ZHRHR0loaXV0L3ExT3czUkFtTlB2bDZSS1paTjloK0J4NWIvVGducnhrM1N6QzZNbWpWQUNVamhvVit4XHJcbiAgRGJRQ0I0dklMSUM3emtsTDVLSGszeFBnckJONXZDbk90U3dIeEtHdjNxOFRtN2ZzSEwxQlB3WTNZaDllOGljR210Wi8xcHFzMW1Pa1xyXG4gIGNpRnVOZVJpUml5NWFETUFvcUhpbXBlVmdIeGdFeVRFdEljZmZxZ1VuUFdvdGJQeWhWK2JYb1l4eWs2T280Ly9xcG4vd2kwT25mRTVcclxuICBxVlJpV1RJV3NUWFhwVFVQcldVTmpOaGJNanFuQjl3cHl2Y1JSMTBlbFF0MU9reU1aV1V0N1FkY0p0OFNLVk9pUng2Q1RiUkVyb1kyXHJcbiAgc2RFUW9vRUhCR3RQMDdoQWNaZjVZdHlHMWJIMlhZeEZITWVTY0VmQnhKZkN1RHJCcEo5eVhDTmZ4MjRRV3lYcmRranByamRreWFMRlxyXG4gIHdwYldEOXo5QXlWVUxvVUJ5VzdhVkdGNkR4QjZ5SHZwNVRseS9IRzRvOWs3QktJUmorOHBMeW5TK3QrNE9FbkpPRUJLUy9wS3hlWlpcclxuICBVYzd1QVRmdjlPV1k0L1g3aXdCWDd6LzgvcFdTbTVOdC9WUE0waFZRdmdiSXlFeVBQai8vZGRCNGxFeDg3SHVGM3N0NWJySTlCMDlVXHJcbiAgVmxmS2pwMk4wdHpjcXB4RHEvUXI2UzliZGlDQWNHQS9qNENra3RWZE9VZEdnbmg0dG14cnlaZVJJMGRLYmk1RWdCVzZtYkpva2M1d1xyXG4gIE1wdWpkbUtIcGtHMktFck5za2pqbUduYWdOYzRTbDhRQW9nWjlwcE5kT0tpcTFEZlE4OEx5RC9rMGJjT1JjaWtCeDEwdXVUYlRFL2pcclxuICBrODZTL29vRXZYNVA0c0hNRVY5TENWUFlxQXhXUDh6QWtzVEQ4K1AxemRHakpaMEwwVnc3MTVFL1RQSnpNMnd3OFBwWkQ5SzVDMUVGXHJcbiAgOVREUm5hZmpvdFhXYzdCTnFaNnd0VEFRV21hWHlPOU5EeElScW5BZ0txRStNMkRNVzlGclFEekl3NEFBVVZHNWNnbmVWM3JqOWMzeVxyXG4gIGFjMDhXZkg4TFRKODVpWGFxVFk5ZzlzVVRJaVpEUStSNVRwTGYrZVA1eWtpbXliVHIzNUNadWpCek56YjBVSWN0S1dJbHMyM0txdHJcclxuICBqSGpvR3dSL1NGRmhvUlFQbmFKSS9RaFQydTczaVJ0c2xrd2RadnQ0RlRiakNFUCtUQkNPc0FQRUNiRmtIUU5wNjVBZUtIQnhpWUplXHJcbiAgZzJ2VExzK0grKzIvbjd0K3AyOVdYb0Z5YzM1L3VuRStLTURob3Z4Y2RHZ2NJblB5cmRVbTdzSVhGcHhKcDU2Q1MwTWhqOGt4eDlpVFxyXG4gIHJqZkZ1YjAzdlRjbVI0Vm4vMXRiOGZlSE9QRGtYMjIwaGFGd3U0d0ZSRnY1ZzdCZ1VrNWh2MlBsaFJ0R21aaUx0TDhIUm9PL0Y5enhcclxuICArMjZLNkxxOGYzQy83RkZDZWFzVGhkU3paNlJjUURQV2VWRjV4aWJQakNUaVZadFE2ZnUzVVArbzV5N2psWXRVRHBxODVCajNQbmw5XHJcbiAgN3h2dHh1UDRpaU0wRDlzUUdhM2hKcjdLZ1NBYUpxMlR0K1Qzd0RYOXV0dXFxNlN3TUROQlBFRGtuQWVwZHljZXhDRWVJVzl2RUloQ1xyXG4gIGlNY0pSUnkyNit3ZXVPYnFDL1ViN05BeVUweFA4bkhEak9rSFNWVlZqUmtFN0ExWW1jNEVma0JwY2czTXhvMFYwcTl2b2Z6b1J0ZWpcclxuICBNRXE2d0dGVEk2UWJRSi94WHNIS3hBdnlZcUpvSEhxVTJ6MXNyNjNUcndIVDBnemI3N2Q4OEJBYmhGN2ZrVHRRcnpOSDI2STJ0TTNnXHJcbiAgc0RNUmFIclhaaFlNVHBTYW5JT1ZSZTF2Ykd5YWxxcFhBbFd6NGxXTlJmVnNRSVV3VmRLemN2VkR3VGJlMXloZ2JtdUwyR0psbVIzeFxyXG4gIEdKbkZodnprd0U0T2NJMVl1Z0hUd2tqRzNxaXNQbmw0dXQwWnlYNjNmdkNFSWE5ay9kQ2VoOHhxZzZVVm9obytNaFpraGNXRG9lOGhcclxuICBETzFBTU5wYjZ5MmRucGxyQy8xczBaZ2hDNUd5UVFPcGJnUUVxSnB6cDZRMlZmcHNVazlBQU5BM1dTRTltclp2bG96c0FtM09UVFg5XHJcbiAgZW41TkZLLzBqVFVLdE04NkdUZ3NkQzQ4UHl5c1JoeDlxWWxrcUJmcUlwYXBXY1dxNjdlVVlMWEo5S3NldHpJRlF5YmE5c0lRaldYUFxyXG4gIC9VbzJ2SDYzN0ljK0lSQ042UDM1L1RyUldQN2NMODB6THZIMHJFSnBiSEJYRHVuNjdMbkYwcElTUFlkelM1RCtHMUt0Q0IyOTBQSm5cclxuICBmaTd2M0hHdUlyOUtXZlRJdDJTRnBuRnp3WG5hdzJRV0o0bXNlVm4yekMrVXRzSFJwbGk5UmYrNjNrUjF5NS85dWZYRHphbTlQNFJPXHJcbiAgVkFpUHRQUUJuM0dFemJxaGZtTm5Ha0dCRTBJa2xuaWUwYjFCVEU1VllwTGJkN2dSVm5RbnIvL3FXQzE3aTdRKzkybHBiR3pVc3ZxMFxyXG4gIDlSSGc5OHJxUnMvRC9qU0VrQXlkZnBGdHQ4dzdRUmVGVTB2S3NCaVI5d1h5dGpyUlFkeEVqa293NXYzbEMvcHUzelA5VmlBeTFjdG5cclxuICBKK0pXUi8rb2cyazBWbVVoSDZzdXhvSjV3OVlpN3BnekdqY1JkMDQ5aUlodFhLVnBNd0l4THB2eDdxdlcwWWw0MmVqZW9qanRtTGhOXHJcbiAgeDZNdm9QVnRENUJNc0dFVStoREdJSlpkeVRyNkxheDlUTmF0V3lmZnVyeXJwMTBtaXdIaFk3NGVSLzVPUExSRCt3akhhSjBBWWMwSFxyXG4gIElpMGd0SWQxRkdHZlBrVnkwMC9jTjFhNjl2ZmpoanR1Kzc1Tm9yN3p2VnM5WXc5QTM5anovY29yUGgzbDZNUm5XNTNjOFVkZjBNbytcclxuICBRajFFV0VCOE5YcnU0Qm1tZ0c3cmlCNFlMNXdnOXV0QkZEZmd4VWJSZUg2c1hPSTNkam9rUnZldGtlVkxsOG1PSFR1a3RiVlRjbkl5XHJcbiAgSkNWdnVBMENJTGd4QU9xVlJXVW14Y3dMNTM5Y09DNjZZaUJCUU5paWxnRXpMR1dGdlBQT1hFN1puaUZOT2lzOThNRDlwYTR3eU82OVxyXG4gIGpaMHNkRkpXR3dVeGNuMW1Oc3hRUVdpaFhQQ3VteGlRZkwxMkxqNndYVmxZdWVRRkdYREFLV1lpQ091TWxVbTRsbnZmSFdQcCtNRzVcclxuICBlT2kyOGI1NEVWazQ5eGhXbmtORWhoNzIyZWlhUEZjM2xkV0ljeHVLT0ZIT045VnNNUDlmY0F3cy9PSThNOGJXMTc4dDc3LzdwalFwXHJcbiAgb2tXTVZWZ3lXTXBQK0w0MmsyVmxRU0QwdzYxeXRJNGlrWDZtS1BkckVCSUR3WnBqUVgxbUlDbTREM2Z0b3U5QmtlT3dtYTUzTUloQ1xyXG4gIFJGV21PTlpadUl1aGVNYmtrL2VtS1VSNWZsTXYrYnVMcUFLRWRoVHd0SXJNSGdReTdyVHZLdGZ4b2lFVVRHVHh0UHZPcmFmYVZzYzhcclxuICBseFlkK0tOSGpaU2ExRElaUFBVOEpZWXVLOGN0Q084Ym9nS2laSTJFMzVWRXlEOUExMCttR3U1VFEzS3hyS1AvaUFlWjhhOTQ1cGM2XHJcbiAgTnR0dEhRckVFMDYxZk5wbkpBZHJQUVh1eDhWam5iYjVGTzlpdVJJbTBvVzQvbENpbGhSM3hhL2JxWVRxbDA1c05JWFBxK2FXTnVVK1xyXG4gIDBtVGtxT0V5NnRJM2JXK1BBUWVlNGgzako2cVBPR2ZWODcrV0ZTLysxb2dHN2xHMjZ6ZUNmZ09UNkxDNm5mVThWcHA2VnJkVHo2TzdcclxuICA2cFNXbmRVNm5rKzJjM0ZMclZETzZ5QW0wdk9SUlJiaUlpejAyQTJRaGFma21mV2RpWktpZXN4Z05JNG9sZzIrbUhUQWVVQ28yYThuXHJcbiAgTFRQUEZxWFNWeE5OMlRXaStocENQQ0FjYnAzVllYcVBqTHhpbmJpdE5aRXBZeS9VR2JEek5mbmcvZmxTbUpzdUM5NitWL0w2dU1sdlxyXG4gIElCVHo1eStSblR2cnV4QVA0TU1QbHluTzJFL3o1bW9ldTBMdUhXNVNqdVA3T3FNSFFsdEpjWldubjN6cU5Ubjl0S1BsbzQ5VzI3NGNcclxuICB3RDhmZkVZKzgrbFRMZjV4UVZidUpHbHBiWk1kTlhQTTlmdWVBREhXUS8rOFJRWU1UdTZlMkY4bjlIKzY4OGZLdGVYMVZLSURQL3RGXHJcbiAgVXN1ZVh1aUtkSGM2cllkL1R4b2tJdUVuQ2ZxU2tqbTlsL09ZL2lhekZEelJVcnRhS2lvcWJUYWNrNU5wK3hoVTFEU1o2SUF5aUF0TVxyXG4gIDVyeXp5aFRaWEs5bFo2V3dSelpYWnNkQldIWHlHM1RRMmY3bUlGYWRBVzFQNlMvbFJVMVNxV3hjVm5hNlBzZ09hV3Bxa09GOTJtUlhcclxuICBPZ1BNOVI1OC9OUkJBUXBTUWpRV3JrVVpGMnNjWlFnQnZZQWpiYjFHZ29nRUl1Q2hXNFNrV3I5WWc4SUNRanpjZ3VSb0MwSm83amlzXHJcbiAgamw4akh1ZUR3RjhRdHUrWWVHSkRqeEsrVlo5Qms5NzdnUDFQaXE0VjlTT3FhOFJEUTZ4aGRta2I3THdIRnhNbkhwelB5c21YbmRVYlxyXG4gIFpWZk5GcHZGMXUvYUphTU9QVWRhZDFWSnpvQnhwck5nMFZpV1hwUGQ5bXdoSmRmU05nZ2hGZ3QxQmc1Q0pvLzFNY0NtZVk5WSsrbTVcclxuICBSVkkyNlF5TFd6MzZwK1htM1A1SjQvVEduUEIxUS9iMERRNEVEZ2FsTmlJZTlnVS80THhmMjNtdjZ3ZGlJTVEveUs0NzJsdk1YRFBNXHJcbiAgZE5uTUNyM0J0bFZ2S0VMK21TMzJvNnZtYWwvRHZvZGRJZVhUUDJ0akNzS0xHQkpsYTRtR3ZHY1UwMlljWVFjR0Vyd0hEaTRkNG41WVxyXG4gIG1iNWVsbll3a0lDQWtpNC83QUk5UG11V1BrWTh1R1plWDNNT0NWSjg1L1l6WllnU0ZCcEc3OEkycTE3dlFoc3pway9SWjRCVjA4b1hcclxuICBmMk1jRjJVQmRDb0Q2bWRKWldXRk5EZTNjWHZHc1dka1pFbS9LUmNaNGwycDNNbzdkMzdLeTBlRW1YTG9VZkRCaFQ0TlUzVHVGUS9CXHJcbiAgZ0N2VlUyVHovRWZ0UHJpY1hWRi9NS0RnUUFScFp1d2F4K2tnQ3c4WFB2UjFNOTZ3b3FHQ0huaWxoa2pUSnRzcG8wenZNMnlTaGVZYVxyXG4gIEtDalcrWTh1aGg0VG5aZU5jLzFlNER4c3QwZ2xCaTA3cXZRN1FLbGU0dldpSy9ITHhsT0lsVk5TT28zN2FLcmRZTjhNSEMzbldGZGtcclxuICBhNnlVc09BVU5DYzd4VGFKR3FlVHlBQW9rRUhxTFMydENVUi8wVVZuV1I1SzlVTVBQZERpb2V5K1FDQkNsQTg3RWRKbmxPWWpSZ3l4XHJcbiAgY3llZTZHdE9wazZkYU5lRVM2blp0bDNMZnJ6clFncnk4MnpmOC9JaEErVVF2ZGFlZ0RVaEtQdGZmMk9lMU5aaXVTcG1wWG5pQ2RQbFxyXG4gIEQ3Yy9zbWNDTWxqWi9NYTBmaEh4VUlnR0xoQmVuQWZKZkR1VFNNYnlZK1dTcDJQblkyWHJxNWFic2h2T1krREFnYkpxUzF1djNBY0RcclxuICBESVROekRhdkh5YXNlcjRiOThGR1VaazZBQjJoT2xKdHppNlh0RjJyZEhiUlpGbm9XRnBhbXFTc2JMQTBkT2Jhd0RaTEl6MXBoMTRqXHJcbiAgMURlL1NZb2dFR2U1WWhNckd4MUVVVmtMVFVSRjNNVTd5RjdyMXI1bnN0aXFKYmdxR2EwSGUzSTRRV0UyeGNmaGRVSmQya3ZHbWZHQlxyXG4gIHZGa2dhYTdyOVJ3RWxCbGNlMU85SVVMLytKTDlxRjcraHQ3TDVzZ2F4aFhtSUVZakhscVdWZlNoYkdmK01Obit6bTJ5WTJlRDdTM1BcclxuICBoSzVRS2lXdGVLUVJXTXIwVVNMRVZyTituZVMxV0RXT21BZml3VFhzVFVibk1YVWVPUEVVUllvUndkRTgvVEhIZ3dzZi9McHhITmpzXHJcbiAgODM1WlhNY01IdEVQaEdQb29SZmE3QnVFNm5WcE9jVm0zaUJWaUFMN2JwZ3JDaDJsYlBHS0hnSU9vbG9KeDRZNUQ1aDVabGJsRzdLalxyXG4gIGJqdEZ0TFlpbHZ4OG1YTGxFNFkwT2Z3NWU4L1JFKzNZdE1UcWhRUE9CdVRQUWsrZWZmeGM5YkxYcEVZSkdWd2RDeWdyUG56SytnalNcclxuICBaSXlFdHNrejRxTEVpUHNwbTN5MkVRQ0lCdWJmdUEzQi9IbjVzeit6MjJUZGlPbFl0QjViMktLRHc5L1VTeitZWUFzWE1RR20zZHA1XHJcbiAgZCtzSFhtVnljMFN6V0JqdTJMSFRERDdRbFJqSHBpK3ozNmpENWJXZkhtTGpCVzZYaS9DSHo3T3FqMTZWRCs2L1VrckdIMnRpcmMxS1xyXG4gIDlBZFBWYUtqL1FoYnZwSUk5OEdCRjE2SUl1MHd1ZUFZZHNRWHpUVktYOU1iZWtrSG5rZFpSRVFjZWhJUjMyN2EvNlBLMmpZcjFPRzRcclxuICBTVUkwTUhmSHN6UUdJeGd0OUNRaVNrUTFqd2ttRXpUR01kdmpob1dHdG1CWENVckxzb2RselpxMThrdldlMXdZM3dQR2djVjMrKzgvXHJcbiAgcWd1WEFBUkNFT0kvdnZIT2hEaHFiL0Qzdno5dWRRS0JJbzY0aXZxQnFMRGdENU5iN29YMC84SWlhOXk0RWZMTFgvMUZWcXhjSjFkZlxyXG4gIGlRSEw3b0hyWG56SjkyekwyN2ZlVGpwOHhNMTdSNmQrLzcySnNNWWRjcW01ZFFkeUJtTldDZWd0Ulc4b3ZEQURHMVF4c0lFWm9QZHlcclxuICBIdFBmMk9tUUdGVlVyYXpqZkdsVnppQTcyMldBU2ZFVkg3Z3ZHa3kyb1hsS1FIeVZMVW8wWEplRGpHRlYyeFdIWjFnOElDNUhtQ21TXHJcbiAgMzE0aEc1ZlBrMFpGekNnZm1YVVBIejVVK3Vvc3Z6cU5mYUdwa21iY0NNdTBtYjBoaWtHVVlXMGtpSXEzNmZFb2pNNGh2a0xteXFDMVxyXG4gIGN4Qzd5cFhhUCt6V1UyVExncWQwVm41V2dwdEp0aFA2bVNxYjV2N0xrRUJ1LzZIR25pTVREbUtyK20xclpjZUdoWWFNdXRjTEZsYm9cclxuICBPU29YUCsvR0JacW1ERWZmWVh6a0h1ZVBjTzFmVDVHMUc1UnpVQUtpajBRR0R1Z3ZCMXh3aC9Lc0I1czFWVCtkalZvZElLckgvaWVhXHJcbiAgc01QT1JPZnRXWUhBRkNIWmxOL1BtcDZEbUltclRybGVsai8zSzdNS1lsT3V6ZTg5YkdhcCs1M3liZW1ybkVpb1E0aTRrTms0eUFHZFxyXG4gIFYzd21Ic3F4MnJwcTZTdEswQ0Z5ek5DUE5DUmNjKytSTW5mdVBITlp6MkFmWERaSWhwem51OGlCOVBFRFpmSGxzMlhrY1ZlYmZKNDRcclxuICArU0J1MTNQNCtlNFE2dTdZdU1CRVRnWjZFVVNWMUdXU1ExZzA1R0JaLy9hOTJtL3ZFNFZBYmtub05GRVlBRkhpUFpLR2FHUW94d0lDXHJcbiAgN0RjYWZVMnlEenluUmI4N1FOYXYzMkQzQzhjK2FkSkJzclAvU1diQkJhQnNIM3ZTTjJYdDYvY1lnb2RyQ3dzdS9Xa1FhRi8wRC9QbFxyXG4gIG5WZzdLWXc2NGF1V2o5Z05DeTYyNC9VTzZ4R1ZSNXpWVnprUDRxWkwwZnppRVZObC9sOHZrY2tYM1dYNWlJb1MxOUlRdjJpc2NjcFJcclxuICBvb2xoQU9icW5FZjM0YUlsYWtXaHByZXZYMkFUTHJ3RDhCNzhITTE1dTRWbFlVT3FwQmdybmpiOWlZWk0yQkJEWTVtVnRmWmhXYlpzXHJcbiAgbWZRcnpKYUY3LzFqdDJ2ZmVyUEFJajU5K3NHU21aa2hOOTUwcC96ZysxZG8zcjZMc2dMaDZCNzJkdTd1ZXg2VkwxM3lTWG4ydWRmbFxyXG4gIGxKUGpJdFQvTzR3Y2M3S3RiVm05NHJtOUVxY3p6cnBLZnZDOXkyWG1VWjlQN0thSXlmR1BmM2gxN3h6SUgrNTZNdUhPSkNNU1lkbEhcclxuICBHbjJ2RWFxSTBsSGNRTS9FazdzcDV6SDlUV1FsejIxWTlyWXByZEpaTnE3UW0rNGpYdCtKQit3bmhBVGlrZVErSUFBV2p5bjVDTWxyXHJcbiAgVFMyUXZ1bmJaVnRWbGVCRWtJOXY1ODd0MGljL1hTb3JxaVBGb1NOTlp0Zk1HdE96Q25UMlB0ODRFQVl6aUNFZ2JNSXVTRnl2VFlqTFxyXG4gIEJXelR6Y21nSWxKRVBlWWNFWUtuWlVHSXZvOTFUK0xCZVN5dU1QbWxQOHgrbWFuQmViQ1hOdHVZRnVnSDFGdTk3SUlCTm5QRURyOWtcclxuICB2eU50cGtjWkRqNzZFUGRub3YxU0JONis4UTJwMzdWREVTMWZxTXZWYzdJenBhazkweGFnSmV2NE5YQWlTQndUelJhZEtYSU93c0h1XHJcbiAgaEdOUHVrNmZtWTZkUUR5aWMxZ2JNZXVGY0JKbnhmM211US9MaC8rOFJ2WS8reWN5OXRSdm0wakY2dWdCY1lVQThwNGgzc3hpR1Fmb1xyXG4gIEJuZ0g3S0dPb1FPT0sxc2IzQXB0NkhRWFNSbm5vbTFzZis5UHNyV2l5dGE0MEdwR1pxYVVUUG1NSVdvSUFJUUJ4YTBaVE9oN2d4dEVcclxuICBGMEo5aUNCeWVJQTBzM1N1UWZ1OGY3ZGFaQ1kvMVhSa2NGQ01EMXhvRERyb05Kc2w0eU1LYjhxRHA1d3I3YzMxc2w0NUd0ZWJwTWlHXHJcbiAgZC81aFlqTWViVklNNWxaYmJEWEF6QjR4WTVOeVoyVUhuMm5jWlBId2FiYlIwcExmVDVLTlN2RHh1b3MrRDZRMmJ0dzRLVDMxOThhNVxyXG4gIEtlYTBHVHY3bE1QOXJubnhkekxrMEUrN0VsNEpEQzdMNFV4NEtEd1hrQ3M2RU80Rmp3cTFxNWdjaU9sSTN2dnpwNDJyOG5majVlRzhcclxuICBtVmpRam9OekkvalFXdmIwenlKQ3lWM3laMUc5eGhnamh1eitDUEpuVFU5ZXlYQzdWN2prN3B4SVZ0RUFVNTUzMnBUR042WnEzcWxqXHJcbiAgelV2NU4yR1dnVllsQ2oyMmF6TWk0bkhHdGNOMW9CdHBYM2lYenJ4WFNYNVdpbHg5NmRseTFMSHVUYmszZVAvOWp3eTVWbFhWeW93WlxyXG4gIGt3eXhBNk5HdVlzbmtIeE56WGFkalcvYlp3NmhOeTRraUt2QWVTd0d2VmZMa0ViL1Fya3hvNGRwMmJrYS8vaEVXUVVGdWZMNGs2L1pcclxuICBZc0c5bVNTUEhqVlVhdXQyS0NGVC9GRHZ4aHJ0N1IweVlrUlo3eHdJRUJUcHpvSDRDd1hDeXpHd2FDek4yVVN5OTNLSjM5anBlQUszXHJcbiAgN1FFbTdqOUJsbXhvMUFFMldsTXBNZTRqMU5lODNYQWZBWEU1Z293UXEvN1J3WUJ3MDFQMDQ2OThUOVlzWDJLbWoyd3d0R05IZ3d3cVxyXG4gIEd5alo0ODhYTEsrb0R3Y1FkQnZNZ2t2Mk85cVFEb3Yza3R4R1FONGhURE5uZ09nZGNHUzRkZEd6WnE0YnltRGkyQm9wQXlrYitobjZcclxuICBSbWplU1pVallwRWFjblR5SVFpMjM3Z1J4ZVM5ZUgxdkI4c3BPQzlFVHFTWmZacUNVK05HUE9MUFFlTVFEMDJac3Z6RFc2ZEw5YmJ0XHJcbiAgTkdXYzJaUXBrNlRmdWY5SzF0RS9Qc2dGRDF3dDB5NW5hOU1PVzJUbjUvblg1MldiYXBIbGRTQVVXQzcxVjBKbTVwYjZoN05DaWlDT1xyXG4gIGdwc1lvN05wQjIrSDU4eEhqNHdld29GNGkzYlp4d0drTS8vZVMyeDJEa0FFQXJJeTBBQmlrRjA0eURpWGl1ZHVrSzFiS3V3czZIN1VcclxuICB5Qkd5L3plWDJINGU0MDc3bml4OTZpY1dZbmFNaUFldnh1MHQ5VW9jSEdsaHZXUE9PbmNESUh4Y3VFZFhONERUQ0I4V3hBWnJKUWdNXHJcbiAgZWpyNlNwb0RNMlkyaHRxKzZVUFRNWTB4eXpWUVA3TnBpOXFpUkVSS1dJV3RmdlYyVzNuUHNlVFdnMlQxNmpYYU55MmtGeDg5ZXJpTVxyXG4gIHY5cjNwcmVxek1nVkZqMzZiY25NTFRaaWlGaHIvWnYzU2w3cEtDTitDUTdSSzlpc0haM2FxejgrMkhaVERHMTRpeDA2Q1pqajd1TXRcclxuICAzOHNIeGJybFJlWGhmSmY4Ky91eS8xay90akxKOHF3VDBmRVM1VEdaNER5TFZBbk44d0pXaUJxUGN5S0VjTldXN3VpVW9zRVR6R3JPXHJcbiAgejhPSnhGM0FhM205TjlMR2dXZzd4SEYxc3Y3NUgwbjExcTNLUFZ3am56bjNlUE5OdFNlNFVaSDdEMzd3RmZQSVcxR3hyUXZDSjU3a1xyXG4gIEdqNCtMZ1NucG9jZEZuR3pFUVJ1NStPRTlLeUR6RTM5cHZXdlJEbTdoMU0rY2JuazVtYkxZLzlKNG1kV3RvTkJkZ3Y1V2VseXhKamRcclxuICBtSkxaMXhML1pEUWVUd2JvVWE0N0pNL3RYOHAyclE0cGFabFMyWmdiRVEvcElyb3ljMUx5SWlVMGJUanhnUHV3cFAwNFV2VU1RMWNnXHJcbiAgclNpUEVGMUYrcUJwNW5VU2F5K0lSMlpXaGlLYnJaS1hzc3NSVnFSQXBRMlFHamI5ZlBoR1BFRDRFWGZUdGUxVVczdkF1Z2VJQjU4T1xyXG4gIHN4L09vVE5oTlRkT0E5SFg2TmNiMWV0S1BEek5aVk5Ob1lxVkZmbXArbHgyYk1Ua041UUwxM1hpWVp2OVJNVERWbERqNGoxT1BLeHNcclxuICAvRnA0VXNYUDF6VDkyQmJyL1dmcFJaUFFIT2svS01lQnlHckRPL2ViMHR2TWM5TVpINW9QTjZKL2lFZG9ON1ROMmdMMnc1aHc3aTl0XHJcbiAgNWs1Ym1GU3ZVTUlCOFpqNlpXM0xpSWVYUithTkZSTFBtbFg1VGh5T05FUUx3bi83MWxObC9WdC8wMW54MTJXLzA3NnJ4L2VNTUhFOVxyXG4gIE9FWm0xOVhLQmJTM05NbjZ0Lzh1ZURhMng4ak5LUEF1aW91S0V1SWlpQWRBSFhQa3FDV1ppVU04RUQ5QkhKeDRvTU00dXV1aFJJS1pcclxuICBNNU1KRnVLRmZMeThWcStZYmZmRHNlenBuMmg3YmZxYzM3ZXlYSXQyYVpQM09talNHU1ppNFQ2NVI0NnRIenlacUQvNEVEZE1tSGp1XHJcbiAgemJiMUx2ZUFvcmkrZmhmNDBpQXJLODFtaDdodjRWblluNGJFSjM3eUY1WisrdzlueW1zL084ejJET0Y1UU1qV3Z2a1hlZWJyQTIwaFxyXG4gIEh0ZWdUbzdPNkUrOVpiTlU2cVFIRVJiV2lLNWdUN1BuSHRhTGhQSm1qYWR4ck9Vc1gvL3JkQklEUjhsQ3o5QVBMKy9yUkRqSXExdjNcclxuICB2bzFUenVIOUdXVjUySHZmdnEyb0R1bUVxYnArdCt3YlFod09uZlozS0xkaDE2Rjg3SnVFeXduY2Z1dUhmNUxxaWtybElJWktjVTZxXHJcbiAgaWFoQTJIc0NpQWRsQXZFZ2prNWswcVR4Q2NSUHlJeCtYMkYyZE0wNDhXQTdXUUJ2MkJBUGlCVEFlY0JGWlh2dTYzOExPRWZjc3FWS1xyXG4gIGxpMExXMkhzSHRyYTJ1WEtyM3dtU2ptc1c3K2xkeEVXZ0NLOXBhbFpIL1lvV1Y4YmpWSUZYazhVQ1Q4UjhLS2phRHcvVmk3eEd6dWRcclxuICBUS1JJWmt1RmJLdGhyWWNPMWF3aVNTa2NaWEhPQmNzclRGNnpDaUpyTEoyaEJpV2FLZFIwNEZ2L21GRnBaeXh1eU04SGs4VVRlYXdIXHJcbiAgU05jalE2bndRS21xMkNKWjZlMm1VS2RvVHN0V1NTczkwQlhsalR0czdRVDdEMlFyUzkzZTF1elhzbmFqOXJ0d0ltazJhOFhhaGpSdVxyXG4gIHEva1FFVjJCekhIbndHelRyYTVjMUdXRFAycURXUlBYUVdrT1VzZEtaV2RFTlBpSWVBNG9hTU45SlBxZ0h3Nm1pbkEzNXVKQ1o1ZG1cclxuICBvcXBsbkhob3VRVEI4dWZEN25xampyL0dadXdndWZZTnM1VmRaUXRMTFdMUHZrTUd6YmpjNm1JV3lxeXYzOGlJdzlDMkd1czJTc1hDXHJcbiAgWjJUODZkOFhUSXM1NFVZRUtiSlFaOHdnWWNSVlRWb09DeW11dWVqaGJ3amIwdTUvMWsyR2dDbkxVYkhvQlNXOHp4blJRRUdPZFJRY1xyXG4gIHl6dDNuR1dLY3ZZYUx4bC9uT1ovVGljVDdMTG45d0ZDUnFFTjBzZDlCUzVzZlBkRk1YRlNYdDM3VWwxZGJmY0VGQllXU001K3A1bG9cclxuICBDb01MM2dQdEREemdGQ3VQdUllSkFqTjJPSjcreW5HU3RyYTZIQ09zVERpSE93Mk9SSjRweklmYnUrRDlJRTVoSjBEcWJwaHpuM0t5XHJcbiAgUitsOXJiUCtzeWd2TTdldmladVlvRkEyaUxwUTRBY3hsK3QxanBURnR4OXVYQlZTV29oSWRsYTJqQjR6U29aOThoN2JOWEhCUDY5UlxyXG4gIG9sQm5YQnIxY0p0aUN4SjFBb05ZRVBFaUI1WkkwNi82ajYzbTMvS0JyN3V4bDZ2L0plT09sVzJyMzdKSkM2U1hQVHNRcFFLYjV6L21cclxuICBPckdvTEJzd3NWRVkzQ1plZU1sRG5NVzdYelBiRFFRQzJQaFRZR3p5UFdRWDZaalZPR00zUjhlOEdiRm9DSGpKS05SNjZQS3d6SXFhXHJcbiAga0l6c1FtbHBxSkVVNVRDeUNnWWt5Z01lVHpFcFFHblRQTk9ERFI1Y0lsZDk2VXlaUE5VZEFpSWlDaHpGN2dBRmQwRDJBSFhtUlB1ZVxyXG4gIEUrYzhlaEhPazk0YkhITElSRm0wYUtWNXhXV1hRdXBzMzc3VHdwR1JSUmJ4Y0lUMHZYOS9VdnU1YjF6T3ZnQVQ1Mzg4OExUZzl2L2tcclxuICBrMkxtOGIwQTNBYnJQaDUvL0pXRUhnVFlzd2hMa2VuUnh4NGw3NndIT2ZFcVlxOG52TUVBbWs3bVJERUx1dWZxYnpKTHdSUFRobmZJXHJcbiAgSzYrNVM0b0FCU05QdEJERVkxNXZOWTVyZ256OXVNem5QOVlrbXV1NmowaDBGUjJKdUNGTWtEcDV2WVdZN2M2VGdlVWpaZW5yRHhudFxyXG4gIFFTZVNwVFByTVFjcHU3K3QxUkFhWlVONUN3M1pKOXRJNW5HazJZZkp2cy9zVHdIQm95eUVDS0lTM0xZSDBWV3lEZnFNSXpuZk54b1RcclxuICBVTFpXRGVzN05pcENLU3cvV0hEVEhpOVAvYnIxMGF4TnN4QWZzQ1ptemV5NzdQbGdZcGx3TTJKMWlLWG83UEFPMithVU5RK2VyLzFRXHJcbiAgSXJMb3ZvdWxSVGt5Z0dkeDdIWFB5cXA1ejV1b3lXVCtXalN2Wkl6Sjd6VnF1L2RaWm5SOTFuWE11ZU1jT2V6S3h5eWZaOXFwNzJHNVxyXG4gIHpvNHBmOWcxYnFsRVdVTDhTU0Zxb3Arc2hRQktkSGE4N09tZkM0WVFKa0pVSk9aaUtnV3RpQ1VaWG90RHVqZGdSZ3hpYjE5MHI4NDJcclxuICAyVXlxM1pEdDlNTU9sWDRYT3djU0I4UXptQU5YTDV2dGhGZ1JJSVFBZlF2dkRQMUljRzBDVjJLcng0MGY4RFVRakNQV3dHQ3BCOUUzXHJcbiAgUW1TY0JoRDd6RFM2OUttYjdGejE4dGVpMEYxTHNOQXZJR2tBZjFDWTQxWXVmc24wSHdGVy9ubTZMRjZ3d0ordHRyZi9oUDJrOUt4L1xyXG4gIG1Pa3FGMWlxejQ1OVVERGFnRUN5dHd6NWxGMmg3MkhaYzc4MGJnYnV3YWFIZWdMQ2d1N0trL1JYRHcyWlpNQ2hNajRnR2dpWE1JYUFcclxuICBVRVBNU0Z2RCtuRFoycGZOMmxEOEl5YXJyMWhwM01hcVYyK1hrVWRmb2NYMGFsSGJJZTRpTFo3aHdScWZaN29sRmdveldVcUtwWkloXHJcbiAgSEROMThaZmw3azhnSHFWNkdsUGRFa3VibDJacnYwT0tOejBrNzc3N3J1UXBIYnorcXhmSXRWKzdXUERyaEk0RGlITUN1NE5BUENqelxyXG4gIHM1L2ZKZCs1NGN1V3QyTGxlbE4wNzYxK2R3aWlNU0RVZmV1dEQyVEdqSU9Ob01IbFZGUlU2K1MydjdCSHlQbm5uYXpsOWwxTXRpL1FcclxuICAzTndpMmZsVFpPQ0FmckpsNDJ0Ujd1NkJOU0ZzQ2YzaXkyeVA0TEJIRGdULzUyczNiRWdvMGcwQmVTVDhSQkNRQVJETGo1VkwvTVpPXHJcbiAgSnhNcGtwOVNKMXUyK29JdTRJRDlKMGhkbTNzQ1RjL0JIMWRLWXRFZ2VXa1p1U1krb1UrOWN4OGdaZnJWRlRsM1A0ZHVnNWxTWnYreFxyXG4gIGt0MjRXaG9hR2t6MjM5N1dJZlYxVzZXa1FNdjBqOWFSUkVlSWQrVTZ1dWFoK09ialRTQjd6YTlpY1p0K3pKV0xYN0FRSk85MTQvMU1cclxuICBOY1VoQ0lndE43Rk93ZXFLR1JrZWExRmtlam0vSDZ1bmQ4U3NEQkVBSWR3RXVoVjIyY05EY1EvaW9jZm1ELzRqUTJmNHltTGE0UmwzXHJcbiAgdHJGZmZMcTByMzlWNmhzYWpYandMQnJYdmlyN1gzaVA2U0c4alZUWjhQYmZUWnhSZ2lpUDFxTjJ0eXg0MGpZNW1uRE96elJYeVlibVxyXG4gIHBhYm5LREg0cVJHZ2d6N3JJZzNydjVaWTljb2ZkREt3MHZRY3lMN0p4bVhLMjdlZFlUTlJ4SGRjZzVrOEo1bVJiM2o3UGpQZkhYSGtcclxuICBsdzNCZzRDRFNBZ0ZiZVdTbDZ3ODNNdWdnOCtVRFcvY1plSWR6RnhCWFJQTys2M1UxVlFhZ1lFVDRObXdUemJJaGpnY3dzN05pNnh0XHJcbiAgaUFKdTd6WGJrR1VBaUFuRUNZNENOK2VJTFBIcGhiRUVWbUNzb3JienlobXhsempYaGF1aWJ4QWI1MXFHSlRnVjV6cjIxL0V5eVFndFxyXG4gIDFsYnNqd0ZCV3ZyVVR3MFpyOWUrY3Y5OTAydWtZc3RXcWRtSWNobVQwMnhiKzlIWWxtbnJTN0EyR3ZlSjc5aGFEVVIvS0pyZG9JQkhcclxuICBtR0pFRUc2RUNRRGIwYklIUi9taG56SHVZNXNTUDRqL3lLTXV0WHZtQjdFa0lrV2VYb2VPRVpUV2NOaUkwZGdJRGY5bTl1SzBMR2JlXHJcbiAgemZvT3FOdW1reWM0V041clJtYSsrYW95ay9jSXdoakExQnhBdDBVV25DUmhraFBoclFBZXNrY05IQXRyU3NLWmZEenFLcWRuNXU2RlxyXG4gIHZ0OEY0eTk5NmQyeWR1MWFTZXRva2dmL2RxTU1LQnNvYkNQcjdrS1N5bXlBK080Z2NBTWc5MCtlbzV4d1NWL2pQRkJBbzdQZ1hvcUxcclxuICBDNnl0UGJVVGdGNnpid2dRbE9hclYyK3d1cHdqbkRkdnNZVVRKNHkyT0Z6TzA4L01rckZqZkJIcS94VlEydVBtZmVuU05iWllFWThmXHJcbiAgZXdMNmllanU3WWo3QXZaTVFDS0FnSVFYbUF5aXVJRyt4a1F5bGg4cmwvaU5uVTRtVWlTcnJWSzIxZWpBaTZDMk9VL1NjL3ZwS1cwYlxyXG4gIHBLeDVpS3lRaXdQWXVWTnZqOXdIQ0hZM2hDU0VJSWcrdG9OZWltU1c2b3luZG9tdzZaQ2VsZWJXTnZNRVhEcGdrTFNrNHg3Q0VYWWNcclxuICAyWGNuSWhBSEZLVW00OVd2RzhLR01wNUZjQ2o4Q1NFRWNlNGoxRVZaaXRnS0Z5RmJQbnpDeXVDSmRPZkdoWGJmK09EeTY4YnVRZThQXHJcbiAgblFRZk5SOGNlNVl3Q3dPUlFUejRZTU16NEtBT2ZxWVFSOWlIcSszZ21nTExMcXluU3ZjL1h0cVdQMklMTFczU3AxZkE5MDBxUkpTblxyXG4gIFFsODFoSkFYbExvWXlmdVRZc2lIOHlPUHZWS2FGTEhxR2FuV1dlMzc5MTB1QjE5NHB4RUQ3ek1FN0hFelVRWkJndHpJNTJDUEQyYjJcclxuICBMSFNiK0ttYm5YRFFqaUpVMW1NTW0vRjV1eFlLYVJhNmNRNGt2bDZKQ2dpYjlUQW01dEp5aUo1QVFCdGUvTGswNmp2bFhsRGU5ei9vXHJcbiAgVEVuSkxEQ2RCTTRPUWQ2NS9URGRUakVEQ2N4dEJ4MTR1aUpXUlpaRlpTWUd5c2hsbGJMM1BYN1FQd2daOTlHcUNETXRQU3VoVXdJUVxyXG4gIFU3bWhnQ3Y1NFNqbzE5SW5iOVJraXJsSUR5SXlPQVgyczZFL2xHVmJYSlRtbUpGakpSWUk1Ync3VDVYTks5ODNTeGlnYlBCQU9laWJcclxuICBicVdHMFFIbXVHd0x5MWJHRVBxaCt0eHh1d0poU2xWQzQxc0VpT21rR2lwWG0wdWQwbkhIS1ZGd3d3L1c3Yno2azZtQ2hWYXd1cUl0XHJcbiAgUEY0dmUvWm5NbVRxZVlia1dmdUMySEx6UEgyUFJrU3NxT1lOTWN0RlJnOTdqNWpySFQzSmFkWmsyVTZFRWRDUGJKMFVVY2JjNitna1xyXG4gIEtIalI1VnhQSXFMbE5kM1dyTVJEQzBDczI1VEFzMWJFS3VnMXcyU3lhUDAvWk5XcVZiSmh6UnI1N1U4dWt6NERmRE9vOHo1MXNpSC9cclxuICBjRUJJQmc4dWxUZmVtTDlINUE5eE9PbWttYmJ3RDBMQzRrSkVXU0RXTTg4ODFzNGZjY1FVNjlmZUFPTHgwRVBQeXNTSlkyVEk0QUdtXHJcbiAgaDVnNWM0cTFRWC9pSVgyNjYrNUhqTWhzMlZ5MXh6Nyt0ekIwNkNENSt6K2V0SFV2ZTdQR1lsSGgxcTNWQ1hjc0FOaGdIeUY2S0JiRVxyXG4gIEg1REdlM3RlUGNwMWgzQXVSUTRhMUNETFY0Yjl6VVZhVzlvbFd6a0NMK1BsWEhUbEN3aDlvQ1NDVUVRYXpYbGFxTU1RMGxEVDlrSXRcclxuICBKRHVlanNwRmFZNitVNzlzQ3NuOFBCZWxWRlhYU3RXU0Z5VzlreTAvSGRFNzhuYWtUTjFRSDNOVFBPcmlmSTQ4WnRhRXZ2QXYxZFpyXHJcbiAgMkdyNXFFNW9JeHg0bUsxYStyTEZjY3ZPZmg1d0lFTVVlWVE5T01LMTlFY1A3MHZoNElrMnErWDU0TXA5OC94L2EzbGZMTmlWZUdoY1xyXG4gIDB5eTRnMmpncXNJV0lDb1JaRFkzYUpJaVZ2MHJ1K0F4NHo1QXVGaFQ0eFZBNmxiWXJOcEFtK3V2eU1YdWdZUnlmZS9kL1ZsaGJVZTZcclxuICBJZ0VJQUl0UGw3SGdiOFdiY3RwdDdvN2NLbW9kWEdXQTZFWWNjNldiR2V2TUhyTlBEc1FoS01iTkE2K1dSLzdQVG44Z1lwQW5TdSsrXHJcbiAgZXUzQlV6OXA1d095QmVEYUJ1eC9vcFdsYit5cHNmU3BHNlZORVMzM1k3ZlBUMk9OSVd5SVVQOXhJRzhNSW1ocmxsUkY3V0VoWnlJUVxyXG4gIHpXK28zV2pJalRxWXo4WVBrRDUxR3BTN29QN095bVhLWGZycVh0SWZLYUVZZThvTjFpWUhiV2lUMW0rSUZYbkUyVlJxNlpNMzJmWEdcclxuICBuZjREYzIyUDJ3OGNQbElHUlh3NDZuZlZTeXRlcW5tY2VqdURCenRDNFo2eEpqdnlXNi9MQVovNmxlMnZQMnptbDZ3KzE1engxV2NVXHJcbiAgdVE0eW9rNEdmNWhORHpua1BIbjJ1a0ZLMUorUVdqMUhPNmY4YXBQNUhzT3R1NDA1TFF0UlAvakNPOHlKWlhCZUNFQThWNzMwTytNMlxyXG4gIFExbk12dEhWNlZSUGs2a0paNHc3MW45Z0lxdkUyTGUrc1FWQ1g1dDBCUThKSEJBVFU3Q0hkaTMwZXVFNjZOYk1IVXJJMDdHSTJTOXBcclxuICBPSS9zckJUNTV0Yy9MeGQ4N2l4RHlBQklHU0Fka0RUaW8zMEI5QVpCeEJUZzJtcytheUZJbUNVSW9mMjlRZGd5Rmt1d0YxNzBqYy9pXHJcbiAgeUJubzNYZVdyOUg3T09ENDQ5ZzAwRjJtN0EyNDl2My9mRnB4UW5JQ3dDZTFSeWdmczNlWkc2L1NJUm1MZytmcWIrK25aZHMyVjV3SFxyXG4gIHlPd1RLYysxUERPUVpMWFFFcUVPRkVWQ3huMlExZ0dEY3R0S01KRENFWlh0N1dBZ0l5NmhYQnlaNHpwbFIzMlRaS2JEQkl0UzNhM1NcclxuICB0dlJocXhNR01rZEF5SHdnSGcvdGVKd3lpQnhRSkJJUDVXeEwxK2g4S0UrN1dKU1VUZjZrSnRsazZTQ2RjZDl2K3hvd1l5dWJUQnRSXHJcbiAgdTNwTnlnYzNKVml0TU90Rm9ZamljK1RSbHhzbjRtMG5yOE9tVDl6UDhDTXVzWFpxMXI1bjFqZVlDd2YzRlZZMnEwaHlGTkhrRnZReFxyXG4gIFF0RFkxQ3BWYi85UkNzc1BjTG4zYUNjZTFoY05XUXdJMThGKzViYnlXZk50Y2FUT2lHZGMrNVMzcXdlSUN3VXZQcVlnR2xqUklYWjdcclxuICA4M2VuMkF4N3YwOTh6K1R5bEtWOXhGNzRQY0tkQm9RRGF5dVE2M3QzZlVhUjd1dldaNGdGeC9nemZtQXJqa0hHSUdMMEdOWS9QYkFnXHJcbiAgWVJrQjlBRFJWMHJCWUt0dmZiSnlTbngwWmd3bkVBZmFvZ1VBbWJ3VEs5ckJibGFFM2UvY2RiaENoMXNHNXZZWnF1Vm1hZE4rN1NIVFxyXG4gIExqQkNFM1FjaElzZis2NGNjZDBydGlrVTE4VEVGakdZUFh2OXc3MS9JQ2FsRTA0d1lrSmJITzBySGxFT3VjbnVoZjFiOHZOenBMcm9cclxuICBCTFBjOGpKVTQvbFpWTmE5Y1k4OGNWV0JQdGZ2bXNQSGtyRXpwYUZxamF4OCtUWnJuenE4cDAvOHZsYld2SEtiTEh2dVpudUhtR2F6XHJcbiAgMEpQN1pnTXJlOTk2TVB1ZmVzbDlTa1RPTllMaTQwRE1zbzVuNnRmMis4QnNsblVpWElNdFpoR3QwZ1pjU1hjaXd1cDEvR01GNnl6YVxyXG4gIFlCZFFKZzJtNTdBOEwwK0llTFo0S0thdXFZS3JkeVFTakZYejRLdkZkcjUrbzZ6NGFJbDgrNG96NWVaZmZEV3hXREFRamFsVEp4aWlcclxuICA1d2g1QUl2cmRnZWh6UGUrZTVtRkVCTHlGaXhZSnIvOTNkOWx5aFJ2YzErQnVzRWlLeEFJQ0JQZWNqbEhXMTBKaDVkOTdXTWtJQURXXHJcbiAgV092WGI3RnRiUGNHWllOS0JOUGZBTHNWWVgzMzI1ZVpHSXNGaFptRkxqODFzQmNlQTE1b0ZOVkVMT2llcTcvSkxBVVNucmQ1VmZLaFxyXG4gIGQxODRpRmlpdm1KRlF2ZUJHTWdWMEYxMUg3dndlUldaOUZIT0IxdUUyS05CbHd3ZEFTTnpOVGNOVVRrVGxaR2ZNMHBTYXBkS2ZRTXlcclxuICBWajJ0ZjdqTHp0NjVURElINDlKYTIrZ211cUt1bStwNlh2UE9hdnNZY1BkQUhDNEd2VWVvNHdmMzczVzlIcHNyUFdJV1dpaHBtN2F0XHJcbiAgTmZreE0rdHdQaDVpYllXeUY3OUJyRnRvMGpUaU1oQmNydTB0bnJ4bmlBY3pRQkFEc21qRVY0ai9XSnVTMEI5WnV5bXlTam1FY1llZFxyXG4gIExadFh6RTNzUVRGbzRDQkpIM0s0aWJqaVpSZi81M3M2NnovTzhsaFFoZ0owOFNQZk5yRUpJaXN0Wk9YWU5BcnVDN2NkMW44RlJDMXNcclxuICBFZ1hob0I4dXlrbzFSRmU5WXBiTjFoRzUwTVRRR1JmSnZIdStZQndUaWw5YXdHS0o4VUdCRmMvL3hrUk9BTlpWWmoybGlMdTRaYTFzXHJcbiAgV0RaZjJwVVF0U3ZXVGUxb2xRTSs4WFZwYW02MWZVM29DZ2djdHk0c2FFUC9BY0lQSVcxRnR5cDErbXlyUG5ySjlCUEdiU2duaDU3Q1xyXG4gIHgyT3FERC84SXErblJJRitFV1pwZjZ1V3pkSjIxc3BBNVU1Qm5QdWZmWk54TFlqSFVLTERGZUFra0RJUVE4WWxZam1JRzg4VHBUclBcclxuICBvay83R2xtN2NxbnNyRjV2cy8zMjlrNHB5Q3VRUWRPL0pDT092TlNzQk5sOWtVa0wraG8vanBCUngzL052UGZpd0JNbE83N0RjQzN5XHJcbiAgd1gyWDIxakEveGp2ajJmTURBTlB4dWhKNEVhdzNrSk1oWVdXT1ZmVTU0QlYxcEJEenBkMzd2eWtiYkVMVWNhM0ZNVGVQQ2VNbW03dlxyXG4gIEIrRDdjakhUVHVzZmdBK3R1clh2bXBqUHhsSUVPWDNLOVBuTTArOW1pbzdQTFFuTHgveVNVZm9jWENJUUs2NmdZdzZYOFJxRFd5UkVcclxuICBQOUszNWtYNWNPRWlHVEcwVk83NC9YZDBZaFhWamNIYmJ6dkhFUkF6WWlFT2lNSGV4RmhCaFBYVmF6OG4yZGxaSmdiRG9vcDZRU1MyXHJcbiAgcnd2L0JtbzlkQkhVRGYyNDVkZC9OY0tCYUN6NDRDSS9XR3h4bngvbm9zS2lvZ0o1NkYvUHkvQmhaZWJuYTArQUdLdHYzeUtaTmR1SlxyXG4gIG1HS1kvd0s2dkR3Zy92cDdCeit2djEwS0poTUhsL2lnQ3NDSEdFVTgwSU1QcldzRFBia1BadGFoaGlQWTZJank0Z2ZuOFJCcWUwTnJcclxuICBQRkhlenVNbzhTMHBuM0ttOU9uVFI5TTYrK3pvTkJOUVRFRlRQL3A3b2s2b1p5R1BVa1Brc1lUWnhleExraUpiM245YysrOXhKeHBPXHJcbiAgQUx5dXB6ZSsrMUFrSHRLMC91WVAyTS9FWUVPbWY5NVdFbXVocUh5eUhod0g4blROc1k4VVlnVVNISGI0RnhJbXUxNmU1NWtpcTEvOVxyXG4gIGc4MEErZEJCd0lqVmVIN0pOdjFnOVRFZWRPdFd2YTRFYkwzVzlQZFJXVlhWbFhobytQYnRaOG1nQTArVllyMmU1ZXN4K3hkSHlOaFRcclxuICBiekI1ZkdpVG1YWlc4U0NOZWhsV2E0T1EwRDlCUEVCeW5FTlJ5eXlXMWVrMjY0N0tnMGlaL2NNNWtRTXlaZVpPdm5NYnN4UVpIV0pJXHJcbiAgSFl1NWNXZjgwTXBnSUxEeXpYOUtJMHBkZTdZb3lKVklOVlpJNlRqbFdzNzhvYTJKb05HUG52eXhmUFRFajJYeisvOHhoRStiZ0l2RFxyXG4gIC9CbmdnZGoxRmNuRDF5Rmg4bnFVdFlPUEx4VFRTN1U5K3NNSzlHMmEzbC83QktFZXJ5SEFLbmpiYTBZckJRNEYvMUpiRno2cjczV2hcclxuICBQcE9qWmUzcmQ1a0NtMmZEK0ZqKzBTSXBLQjBoR2VtcE5pYlQwMUtsc0xCUXozMW9aZGE5aFhzV3hGamZqMXlaK1BQTHdBdUNSbkVqXHJcbiAgOHVhdHA5cHp4bVI0djA5ODF4WVdRc1REczk3djFHOGI4VUQweURkbFQwM1BzVWJHM2RCNG1yS1RQdmNuSlNMbktsSHZhOGdmSjUrSVxyXG4gIHN4QlIwaDdsK0lQWUlVbGczUkNyN2ZPVVV4eDU3TlcybzJJb1IwaWJqR0d1UXhvdkN4Q1RqTndpRys5VzFzWmpQUFI2L01GOVlKbUpcclxuICBoOTFCQS92SVhiLy9sdVFXOVZRTWc1QkI4dkU0WVlCNHZEdFFscFhuRjMvaGJFTzhnUXNCUWx2TTVGK2I1UjZLOXdZbzRNUDFnbmxzXHJcbiAgbkJ1SkEvbm9JTERFMmxNZi8xc0kxN3Zuci8rMmNFL0EvYkg2UG9CL0dYdUJQdnUwUm9ZWCtkL0RHKzhtVGNJbVRUalFYSTREV0RHNVxyXG4gIDAwU3NzUEk5TDZ3NjEwc0ZXM01BNTN1SWYreUVRWEpRMmFBajM2S2VKc0hNblpBZDdrS1pjRkMyb25xN2pKaCt2bTN2R3FDcHVVVldcclxuICByVkp1YUMzKzhQWFJLV0l4NUtJSHluUHkrRGc5TDdTRmJ1UkZHVHo1azFHZWx3L25iYjJDaGlncEVWMlZULytjclJjSjUwRlN5ZmFTXHJcbiAgOWRCNUZBNCtVS3BYdmk2NFYxazcrODhtQXRDeldpWldYdE1RanFsZnVzL2lpS3hXdlhLYldhd2dwN1krV2gxL0ZxYTAxWFJtMlJUSlxyXG4gIHpHQ1JJSUlCYlFNRGgrM1JRakZOUC9PTlFUSmVFUlh4OXBaR2FXdHRrcmR2TzExTytzVWFzN1lLNVJZLzloM2JuN3hrREJaTW5vY3ZcclxuICBLd2paNFY5N1hoRTBKdExvQVNBZXMrMnhZcDNrSWlaUjVLdkVRWkVJTlFQU2RzTGhTbWlERUNvc2Urb21XYXFFQUFMQURvcTc5UG0yXHJcbiAgS3hGTzAyZVJrWm9tT1huNVVyTnBoUkdMUUNpd2ZBcHQ0NDRlYXltSXdGdTNubVpsYkd4RmdNVWV5Ti8yMlk2QmN4bnVYQkZpRkFBaVxyXG4gIENTZkVEUVNpUW1qZWdoV3hCNExDQkFDckpSYWVZaklNWjNMS0xSdjkzdlFvS3A4b1pmMXpaZDM3ejVxckdlNTQwS0NCa2pYeDh4cExcclxuICBNUkZmVzJPZHJjY0JXR3dMSnhKRVcrT1VVTS9VNXczUndJaWpwYkhXVnBEVGp2dWhvcGhmYTc5VGJrQ1ZvSG1kMHFEM3kvdkgrZyt4XHJcbiAgcENGM2NyUWNwck9ZL1VKRXRxMmVvODlrRGFlTWlLeFdZa1ZiWVh6MWo4WWFTdm9zZmZlY3czaUZ2VHI4Ty9KckUzZHVBMVB0K1VaNFxyXG4gIGlBT0pCWVpSV1VJM1NQRnJNS0ZhOXZCbCtsejZ5elZmT2t0U3MzcEhYSUZnQk1RZmdMenVLOEI3ZzhyS0dsTStRendDOG8zckx1NzVcclxuICB5Mk05a1ArZUlJaXhUanhoUnFKZmdVRGM5b2Y3dTZUL2ZCZGVJWHJxU3Y0dkFFZXgzOWpoc25EaGN2TzB1emRZOE9FeVd4Y0NnR0gyXHJcbiAgQ21XRi9nTERpMHhBdDZTQjVmVjJJa0Nzclc3RjZrUG5kVURBMW5NYW90RzFJSEVsS3RtRitrc2I5aHRCY25CMU9XTDVJY1Rja0gwTVxyXG4gIFVJNTZDNTV2c251ZHhTSk8yWms2UUVwTFM2UzR5QWtZSHhXV0wyeEFVN3pob1VRZDJvU0ZybGo0dEF6RTN0N3lVbldXL1lTd2QzY3BcclxuICBMcTdKTTZJVCt1QnhrQk16L2tBYzBIdXdvanFVNmQ1dnlySFhoU1lNc1lMMHRpdVNnZ3ZvNGVNcTZoOEVCRk5nOGxDZXM1ODEvbzJzXHJcbiAgYkxnSC9adDN6K2RsekNuZnNuTDlwbHhnU0F1bGRnWWJoQ2hVUDhuMnBTSXZmR2UwZk9LM0ZZa1YyaEF2UFBLZWZwdk9UR2hURDlaMlxyXG4gIG9QQUZJZUlobHpTQVhnUGpBcFM5WEllOXpJMTRySmhsZnBxc1B3b1FEa1J4Y0JMbWU4b0lCOGczUmppNmdTbkU5ZkF1dUVYVm9GTDNcclxuICBrOVNpZlczdjZMQTFDaWtESnB2aEFjZ2VRc0VZSUE0WE1mN01IeGx4b0IwNEJKNGQ5MmJkMGlOYlo5cThNek5IamZMQ3dmYTd0TWQxXHJcbiAgQTJGZ0VzUiszRFdyM3pXaWhma3IwSC9jRVVab2VPMFFsRUVIZlVMR0tVZUVUbVhjNmQvVDlsSk1BYzk2QnRiemZQVEVqYkoxL3IrRVxyXG4gIFBjeFRVNVNBNlBWeWMvT1UyL3FCSFZ5Zlo4UUpuanYzZ3BnU2JxU0svZDJwb0lEdUNWRVpYQ0JFaTdIT3BHekZjNytJaUxhVzA3SmpcclxuICBsSWdnV3NYTTJkM08rUFBjdGdvaTRyc24ybmdhZGJnUkVjN2pBb1dRZjNSbDV1SWtLa2NtWnM2Y1J3ZURFZ2VPRGs2NGJvMXZXbWJsXHJcbiAgYUhNRWVsZnFzSjFDbVhFZm5Bc0dLTW52d2tQWGh4d3NPK2JlcVZ4QnJ2emg1MWZKTjY2L1ZHYk5Sc2ZSdTc0Z1Rqeml4QVNPb0xTMFxyXG4gIFh3Smg5d1pZVG5FZTRoR1FPd1FqdElHVkYvRGpHMzFqcUwxQnZDK0JNSVR3d0FOY25CL1NlT29GempyenVIMUM5dnNLVjMzbE04WnhcclxuICB2dmtXUmd4N0JqaEtSSFlXdDk4OVFIcGJtMnplb1UzelBydUFEWlVJZXB3MDhGeGV0RVY2d0pTWTZ4SVdEYTZvY0srblFFYU9yd0VKXHJcbiAgZFVGa0ppN1FOQnZMdUFzTlFGbmR3ZDI1RDM1am9aM3I1YkNBMEFldmx5VXZWUWVyRTQyc1NaZks2TkdqSlM4M3kxZG42L25hMmxyQlxyXG4gIG0yZlc4cjlTMk1RT09NNERmR0JiSTViMnRpRU9QdGp0R3ZaTE9jOWpsYnJWMFRUS2M4MjFoWWloTFF2dFZma0N1bFJNUlRWc3FOdGtcclxuICA1OWlYMnR0THRrbDV1QW5pbzQ2OVdvcFJMaG9vUVVHeGFXVzhEbi8wWWRwWEhqRmxMZ2dEbmNKQnAzK1RFdElSS1lncktpcGt6dTFuXHJcbiAgeVdGWFBXNWlQb0I5c1hGblB1UGFweE50UWl6UVl3dy80bEpMYzBBNE9DQWMrSEVDMk5VUGR5UFVBL21oKzhKeWlocmtvZU13cEtqUVxyXG4gIG5YQWdla0c4RkRWdkI2Ykw1STA3NDBmMk1ZQ3dFM29zeldpVER0bGVWMjNJRlNzdTFzeGdwbXFPLzVSZ3dFV1lRbDRST1hYSUF6SGhcclxuICBHZ1lUOHVxbHI5bUI3eW9jUStMcUhHNHg1Q09LMmw4SkVQVkRuM1pWS05jOGVMd3NldlJiY3VpVmorcXpiTFYybWQzVFB3Z0Q1WWx6XHJcbiAgZXppV3hHZ0NBa1FUckFFWmNkU2xSdGpXcjJldkV6RzNPMHhzeHA3MGRhMURLVEhqQW9pdEsvb1IrODJ5dFIxd3RTQjg0MGFlVVc1RVxyXG4gIHk0ODY1a29MMlgyUWV5ZU95TEZHaWNNSC80aG16cG9ISjFKK3lQbG0vc3VZd0p5WTdaWUJEQ2Nvdy9WNUZ4Q0NXbjBtVms2dno2UUlcclxuICBMNzdFUXprNEZyaGVkMjVZWTNrUUVac3dZYTJsdjNZL09vWWhJaEM0TmJQdU1tNGJCNDhZU1dDdTdXVkNXVDlxWHZpNnJOZUozZm1mXHJcbiAgbUs3WEtUS2s3cjZqR0FtOUF4eEVXc3lpQ0tSSXZZd01uekR0Q1VENmdYZ0VlUENoWjZXcHFkazJnL3JnZzZWS1lMQ2cyenNjcWUzZ1xyXG4gIFZnVUlITTNaWi9taTBYQ05rQi9TQngyMG56enpySFBwSHdkYzhKbFBXTWdPaEh1REh5bXhEUDNkclJJZFFJbmVvYk9ROVB5aDB0NnBcclxuICBMNHJCa0FCZVlCU041eWN6bzF6OWpaMzJoT2V0V0pSOEFKanVtdkpjOC9rb2JmT1hhTlU1QUJKbUJzK2dRWG1lcllQUnJxVkhHSFFoXHJcbiAgOUx4a0dJOTdPZDkyTlRIemp4VGltSjlpNlpQSWkvSmJpaWRLVWN0cXFkNkdEM3hGcUhvMDZrRFJMa3ZmWVpOa1IvVkduV1d1c0VWclxyXG4gIFdzRVdjb0Z3K0tDVENuS09tTnVTS0k4UUY5ckl2WXZMSjVuQ25CWHJKZU9QajVYemtKa1lIeEx1S0RSVHI3bmNmQ3N4VTBaUmFXWHRcclxuICAyZEp1aWpsaHhEeVNtU2hyUExobmwxTmp1a2M1U2ljSkdMYjdJQUdzdWJEeDczdlFlYkwrNWQrWUdXeW1mbFMxTzNiSXVQSmlTUm5zXHJcbiAgU0lUdFd6dWE2Mlg2dGM5WWZkcGsweU9NQUFaTU9ORVc5WEZmaUNOWlRZOWV3eGUwZWQvd2MrYUw2R2FaNG5YTmEzZm9qUGdvYVczYVxyXG4gIGFVcGh1c2dxYUJhNm9aU0dJMEc4aE42Q21USFh0TEZRWEdhSUg3MFI0cTBLSmVoRERqblh6ck9JcjBGbmFreEE2R0ZCUWI1OTVKd2JcclxuICBkZXlWSnQ2aVQzQThLTU1SVWFFNHB6MFU0dmtsSTAxbmhDc2QwdkdEU1E1S2NxelNCazg1eC9OTGh0dE1ITmZ5dkM4VXpDeTRHMzc0XHJcbiAgRjVTVE90bXNrWUI1ZjdsWVRyNTVqUkVlK2tJYUNNU0Uva0JFbVBXVDN2cjY3VkpuZWpMWHgrWGw1Y213Qy81cGRkaWNqTDFQR0c4OFxyXG4gIEo1NG5iYUk3WkJMQnZYRHZpTmlJVUFhOTA4QURUOVdKQUp3aW5uT1BkTSs5K3grdlJPUUtHVExOMSt4Z1RwNloyOGVJZ1MzMnBDRnRcclxuICBCRkVVM0xvcjRQVzU2bmZLOThQZUhvT25ucXZ2YWFOWjVhMVFRbVB1VWJTUVZWVmduUWdiaHZVeEUyVjBTOU5zOFduWXNzR3ZnVCt0XHJcbiAgdWJhTEordDFHRXUwaVdRQ0Jic1psa1NROGNIUDViMDVjMlRVeUNGeTVSWG5TMGFtaTUxUmFIdTRwVmVsTTBnWlVSUldlb2h2c0tLaVxyXG4gIHp1VEorMXZJZ2RKNmR4Q0lCMGg5MGFJVlNveFN6U1NYZkZaNWs0LzdEMHg3OXdhdHJUckdjN1B0ZXRSSG1iMTgrVnBiM05kZG1SNFdcclxuICBIbFpYMWNxd1lSK1BNajBuSjF0Ky9adS8yY3I2dlluZjZBTm14eXRYYmRnN0J3STB0L05HdytzSFlxTWhEcjNsZFlGa2dlbEQzQzF3XHJcbiAgQUpDT1F5aWpjNUlndzlRUjFXaU8ycHo3c0Eyai9JUTBLSkdKMS9IZmVCZy9sMklEM0Vab2RDQ3VjRFJLbWlLZTcybU9DTkZQL0xLTVxyXG4gIEhqVmNjckpaL2U1UVcxVWhxNTc3dVl3WTRZdlFPTFl1ZU5MRUkrYjRrWHJXa3Y1Wk8vRTJQVTU1eXZnKzBGNk9HV280SHcrWmlSRkNcclxuICBNREI3Yk5sUmFXYWVUb2pzS2haYVhJOER6OWNaSUdrRmlJZTV5TEIwVkViL1FBelk2K000RW9YdDZKT3VrL2wvKzZKeE5SUWJOTWdYXHJcbiAgWDdVb0o0cS9vYXFxS2lYc1N3M3hkTFEweXZTdlFqd280ZnVDWTFtRGZzTXpVMHlNUng3SUxlUXhHODR1WnBNaVRXa1dDRzdqZXc4cVxyXG4gIEVSeXE1WTVXUW55NnphUWhCcmczTWZFU1NGQm5pOFlwS0lLMHpjUzBQbFpBbk1PVEx2bk1jMWg4T2Z2bVl3dzVaMlZtSmdZNTVRdnpcclxuICBDNVNBSG1iblFOSkZ3eVlyc1hiUlYzdHJvNG1nT0pZbzBvWWo0VUJQQmRleXV5Ti8wR2hYbnV1eDVQRWYyMXFjRnUwREFGZTB2eEtGXHJcbiAgL2xxTzJUUUtkZTRIVGlWNkhBYm4vRVdKdEJJd3dONlRjajBnYWM3dk4vMU1TVzJ0a2VhV0Rwek02ajJseXFGZlJ5eUZKZHNMOHRidlxyXG4gIGZNdFREQXJXdlBZbjQwWTR6QSthRnVJNThxQWh2QkJvRTFWcEduRWFIT0hZazc4cFMvNzkzWVFlRVZQcWovN3pQVlBja3g2Z2hHYkVcclxuICB6QzhaSjFJZmZZZHdJb3d4NDBRMTVHK010c016WFBuQ2Ird2NCUkZmWXBoZ2xjaUw4bEY0WStKTHVibzE3OGxBNWVBaEdINmVpVkNxXHJcbiAgalhQY3lGQWVGek80NkdFVEtpQW8xWE1XL0VMbXZ6ZFhpVWU1WFBIRk15VkgzeTh3WnN3d1ErQWNFTjNkaWJMZ1FzSnNPc0FxUll4ZVxyXG4gIGI4K3dVcEV0NVVEc2lMVkNIZGFPaGZ3NGg3TW5nRkJRSGdqaUtod2RBb0g3Q1BraGZlU1JINjh5UFd5anV5OXRzdW9lMkNzSEFod3dcclxuICBKRitxVytJS0tSQlVGR1ZnQkxDb3B4Ty9zZE9lOEl5Q3ptclpYT2tQNkxnampwS0tGbCtZeE95UERXUW9oeU5EQUQxSS9nRGZNNXlaXHJcbiAgZmVBK1VKNFhETVlSWGtESXlUQWcvZ1J5amZMY0RMaFVaNHNqRktuT01ma3BMaTB3RDJVRzZYdUlCRTVCNjBSY0NFZGEyYUdTVWJkSVxyXG4gIGR1M2NJZWxwZmg4TlRTM1NVTFZLaGg5eWpuUmtGcHJJZ3NWbDdwWWoyUS9mcjEzajJoNm1paUFKK29wWUR1VWYvVWlXNzNvdklYL2RcclxuICA2M2NiQjZJWjFnNGZHTXJ3SEVYR1hvYnlFS1duM0NlU3hwbnRzYmMwbkFDcnN6WFQ2K3NmbkFjaUhCQUo3bE13OWNYSEdJdkZySmorXHJcbiAgNVJmMmtmWHZQK3RLVm9XT3pqWVpjdVNWc3VHTnY4aU1iN2d1aGdQaUFiSWdqcE0rWnJPY2dhTXJIWCtzNWJPYUhQRVd6Z1Z4S0ptZVxyXG4gIG5XZG1zY3lNY2FFeTZvUnJ0QmdtdjQrWkNXZUFYSjNWTXk3aWdKa3dNMmxFUUR3blZ2QnZVNktBS2EyYjRlTGFZcTFrMUM2Um10cGFcclxuICB2WHFLcEtkbnl5SGZlRUg2WWlHbWFRaEZ4WWZQbUVOSENBSHZqWHpHQVhvQ1ZyNmoyMXF0U0ptVjBpRExRRlRpeDZhNWowbXpFblBHXHJcbiAgRnZlQi9KK1orZkNaRitrN21tcGwxcjE1cjNIVjdBMERRZUVhSHlteEdUTHQwMmFwUlo5eFNrbmVRUmZjcXMvbEZabnpCOThwTDY5eFxyXG4gIHBiei8wdjNLaWJVclFoTEp6TXFXdG93K3hwbmhCZm1JYjc1aW5BcDlIekwxazZhendiMklHeVBNa25GbmZGODVzZnVNTVBPc2NOdXlcclxuICAvdTEvMkx2aGViTVZNTlpMbUNmYnluOTljWEFpckRCbksyTFd5R0FSaFhOR2RFSndKVnBOeC9CUVdmSDh6UmJ5em5uZmpJRk43ejJzXHJcbiAgejNLaStiQ0RzMnh0ckxNMU0xeUhlZ0RjTG5IYmdsZ2pZUXZrcEtzVENuYWF1VEZjSitNZmdzakIyaUU0RUVwODhPUnZwRitmUExualxyXG4gIDExK1h6MTM4S2Rtd1lhczJwMk5RWi9OMzMvT1l2UFRTMnpaNzM1M1pLOGlZR1hYZ09FRDhjQ01oajNCM0FLY0NoRElnWHVMc1pBaXdcclxuICAxd2FMQy9mVnBEZnNGY0pDUFRnajJxTE5RSXhJaHlPa0F6ZnljVUJaV1lrODhPQXpKc0pqYi9ZOXdaL3Zla1JLUy92dW5RUHBiR3cxXHJcbiAgbWYrK1FUUTY5Z1phN0wyRjBhcG1oVmZtWTJ1dm1ieDQvZkFwQUNKMkNHMTZtRGNRQjRxQUk4SHU1ejNzN1J3ekhWOExrV1pyQ3p3UFxyXG4gIDF4bFlmb0dBbWZXd1ppUDBoY1BhQ1hFOWhrODRWUHIxN3lPdGJaMmkvNUtWam9YU05sbjcwaTFTcytCaEdUVDViR3MzdEVIWWhURG9cclxuICBPWkEweUpvOHl2UWRqUnNJajN1OUdQSFF2KzBiRjlwTUUxazhia3VRYThPNW1CdVdtT0xjNnV0ZmxuNWMrSmhDZk1QTW5Qd2lXM1NWXHJcbiAgTEVQSWpKSThmRDJodk1lc09UWE5uNDM5YWRpUUJkZmlLOUtCK2wxTk11ZjNwOG5oMzhUeEpXVWtJaDVKS3l2YVluRVhCSU1aTDRYZ1xyXG4gIE91QXFFQmN4aTJSR2pxaUoyU1psV0gxT1hXVDNiTUlGWUlrRVl0ZnBwNlVCdUEzeTFyMzVOMnNQem9HSlJxbm1zOGh0NFVQZnNEWW9cclxuICBnMDhrZENBOFJRQm5lMHYrK2xtcFd1cm5RYm9RSVFqSnJGOGVZL25FYmJLaTVXMXhvU0pFbmdNbXdZakxRUFFjNU9Pc0VLczJpQnZlXHJcbiAga1hFaWlVbHJSbmErMWFlOUpmOVJUZ1l4bFFLVGh2M1BjdjBJbkFwSWtHY0FRWUZ3c0ZmK2tkOXl6bUs4bG9NcmdjQjgrT3dmYkkwTFxyXG4gIHRneXArdTZuWDN5SGpQL0V0M1hzdm1udFFrUngxUjdpaUVCUndMTXVBMDdFT1JDeEJZcHdIeTJLME9rZjhjQ05JTUxDV0lFOTVpbk1cclxuICBQWlZPT05ITTBNMlJvUUtMUmZQMSs0VDdOSUdnMXB0KzFST21GN01MYUpxL0F6OXpxM2tQSUk5SkN0d3RFeGpPazhmemhBc2tqa3NkXHJcbiAgQS9KR0hpcXJYM0c5bmJWbDM0UytQUjMzbE9XQTBMQkZBVHJBTFk5OVNZYVdENUEvL09wYU9mRTAxeG5nNDRvRFF2TE42eTVPaUdOQVxyXG4gIHVIdmlRbkJpMkIzaWU1L3ZEbkNLQ0ZBdWNBaCtyZmNFUjRoQXlOOGJCQTVtNXN6SnR2OElFT29TQmtJUzBzREhSVHlBVDV4NmxLVHBcclxuICB4SFRwUHJoMy8rNE5YNVlWSzlidG1RTzU3OUY1c21OSGhSVG01a3BEdWo4TWU1SCtIMEVVczZCYnJnMllBTVNqdEFZdGRVa3p5SlRNXHJcbiAgWXVNQUtBK0hBZHNmM0xlVFp4NDJkU0RobGpuSHpIZTlMVDQ0NXhBMGJZTXROdWlpSTU2SExvRFpPR2tXdmNHeTR5Q1FmVHZJMjdieVxyXG4gIGRmUHdHZXJIdVk4UWI4d2VMa015ZENiVTFDRDE5Y2pXdGJqK3RMWTJTMEZhbytUQlFoZjROVUs5QlBlaEI2SWFUWmpyY011REdDZ1NcclxuICB5Y2d1a3VEKzNjdjZQUkVpSHk2ZmRyNFJEQkFKTy9FMVZLMldza211YzBHM1lpRVBWa01RRlY1VE1VL0YxVFhLUjJhSjhUS3NNRVpQXHJcbiAgZ2Y4bVpOVHIzL3lyNlNUWTRBZkEwb0sxQk13UTArb1c2LzFoNE9CRTgvQlBmMTl5aGlMQ3dLcktpUWNMR1NFK2JPMkt1SUVGZGxnQVxyXG4gIGNUbE1URmtvVjFRMndXYWppTk1NK1N2aEdLb2NnOG50RmVtRHRCRHZ3SEY0TjNVODZLeVg1K0I3Y3h4dUlqZFc1NlBiUVhrUGQ3TnhcclxuICB6Z1BhSHVhK0tGcjNzelpvWU1naG41S3RyLzFPZHRiWEd4TEVqSGY0MUZObCsvWTY0d3JnTXZCMHUzMzlmQnQzR1hsRk5tTXVLai9BXHJcbiAgaU1UZ3FlZll1R1FQYnNSY2hjcnRNbDVBWHN5S0lSWjlSK21FUWljQWJIQTA3dlFib3ZRTWFkYjJJUHI5eDg0MFUxVVc0NkV2V2Z2R1xyXG4gIHZiTGxneWZORUdMc0tkL1Fzb2NaTVFGR0huV1pUVzRnSms0RWo1Ym15c1d5WmNIVDByaXJUbGhRbjllUFJZVkh5NXJIdmlvVEx2cTdcclxuICBFVUhTS014NWZxd0RNaUtyZVhnWHh0ZldzQmtYYVptanpKR2pyWjhhT042NEU1NHY3d0h1QUlzK0NCcDZIWHlNNGRnUmdzdENXSFFpXHJcbiAgN1BMSVlFY1BncW42cG5jZU1ITnR4R3psMHo1ajR6cXU2MkFNNHBXWWNjY1l3bjhXdXhxaUh3Rzh6QkI5RDYvS1FCMkhjQjVZcXcyWVxyXG4gIGVMS2RNNGphWWcwSzN5dGpsOGtXM0Y3MnFuL0lsczNyNVE4M1h5MG5uK0ZldXdGbTVYQU9BT0VIQzVZbTl2TFlFeGVDcUlueTVlVURcclxuICBiYUVnU3ZBaFF3WmEzdDQ0a1RnbkVPS0VIUGl3bXFLY3lwN3FCNkFNQklLUTlSNVlnM0gvcEVNWXJoUFNIUFExdUVYNXY4SnR0ejhnXHJcbiAgK09YYUZ6M0k0MCsrc21jTzVNTFQzUDU5ZmFYTGN3UFFlWWRrTEE2ZTIvczVZRXIvcE5ORVBteFhucWVZc2hWaTBWSmZiV3NGYUFNUlxyXG4gIERkQzlOWnovR1FZekNGY2tqSkNrSFVBeUQ0c1BFQy8xR05odFRidnNnOERLeUJBMlpmbW9Jck5IYTRmOGJ2R04yZE9scEtTRUhHbkRcclxuICBQVVptdW5RcWNscTNjYk1zbS8xM3lXdUlmSEpaUFI2eGhsRTZIaWRjcjdOMVN1RnQxWWxIMS9QTXRGRW9OeXRCSFhIa1paYVBUbUhrXHJcbiAgTVZkRVphTDI5UStYMlphbmY0UWM5UlgwSldvM3lnY0pJNnBEK2F3NStxRy9MYU9PdlNaYWQrUEVnN1VkY0dNVTRPTnFidTR3bzRFTVxyXG4gIHBWWGJjSHUrYlltSm95RDBBTDY2YXBUak1NKzFpbWljZVBqNkJCVEpZWmRDRkxJQVNBL3VBUUJaQXBpemhqeUFCWVVnSWJpRjlyWW1cclxuICBLNGUvcmcxdjMyOGNCMklpTnFzeXJrRGJnOHNKcHMxd0VwVnYzQzZaT20zbmZpRDByZTF0MG1mSS9vWWtnOVZVMmFUVFpkSkZmOVFaXHJcbiAgLzQra3JXRzdjUXR6L25DdUxIdm1aa1BzUzUvNm1TbUhVZUp1bXZ1b0V2Tm5iVE9qblZ1WDIreDk4L3pIR2NTV3YrYTF1eFJKWG1UMVxyXG4gIDJPK2Urd1haamovN2h6TDh5QzhhMFFOcVZyeGxmUThjQ2dCbmtwRmJrQ0FtY0NWTE5iN3NieGNxc1hLRXlMc3E2RE5BWHYvVEYyWEFcclxuICB6Q3VNMEFUckxWLzc4cHFsUDN6NEc4SktkL0p3eUlodWhySEVuaVBHa1dqYVczUFhKSWc3c2ZZaUMwNEVZNURsei93c0tpTzJkdVQ5XHJcbiAgKzc2aVkwYlQyZzVXZEhBZ2NMQk9OTHdjNzhycWFCckRBa0x5d3JpYmR0bEROdmFzdkI3ODRZY0xYUWg3cXZPTUdjL3NIMEovRTkrT1xyXG4gIC9qSG1zNHBLVFMrVHVmeGVxZG0yVmU2OTh3YkpLZkx4Rkljd2t3Y3dkdzNwMTErZnB3aTZkeTRFeEUwNUhDb0M3TTlCWHBqNTd3NDRcclxuICA5K2FiN3h0U0QrVkNuUHBqSTExTTRCejJCb0d6UUtmeTNudUxFblZEU050QXZNMDY3ZXZIQmJpbTUxdlpsLzVXVjlmdG1RUEpUbW1YXHJcbiAgZXg5OFJuSjFGaTJ4dmRGNS93NkppQStLQ0R6R0lMR0lRb2g0WG1GSGxXeXBkc1NUWHJ5ZjZ6cTBQc1FFN29NRllNeFl5V3ZlWHFHY1xyXG4gIFJxbk5PckNJOGVzZ3gxMnIrUU1UZ3hvazZZalhaL3BKWkV3WTBzckZWQzQzZVMxeFU4UnF5Q0JuUmxreTdoaWYrZUdhSXlwUG1MU2tcclxuICBZcWFQQmRjN1VxSXpvY3ltRGJKcjEwNHJZNnl6UG5sbWJSbXR0Wkk5RFBteWN4K2hMU3lQTk9LenVhaHZtSVR5VE9BVy9CcGQ3OFVzXHJcbiAgVlRUa3VkQVBqQWpDZWcvKzBOZDRXeW5HL21PTnRmbjlmMXNma1lQemNUSnI4N0orb09UTTFXZUpaMkNleFNidDEwQkZOSUIvdUNtQ1xyXG4gIG00b3BsOXlyR1VvazE3MGdOYlZLR0JUUzlGWll1MUUwYUxRc2UrVnVSWXo0QlZKRVZGaGluQUdFSjZ4akFMbjNHVFpWKzFSbW9oNFhcclxuICBZYmsrQTg0RDROcHdLOGpXaCtyc21RbURPK3J6MWQySWl1QVdOR213NGExL3lNR2YvWU1peHh0Tmo4Q0I0bmJBaE9NTmtXT2FXanIrXHJcbiAgR0NVU3hiTGsvc3ZNR3FhNXNWay9DajRMa1FFNkV4Nm1pQlJSS1FzOGx6NXhrOVJYdXdnVkJNYnpSWWRSUHUwOGF4dnViZGlNejBwaFxyXG4gIDJYZ1pkT0FwcG1Nb24vWXBDOHNPUGwwNXlaUE04Z3A5QWhNU0FBczJYSGRzZlBkZnRrQjBxM0lRTE1CRFNZeHJra011dTgvRzhucmxcclxuICBSbmovS0pBM3pQbW5ySjM5RitOQzkxZGl0dVR4RzZXamFxR2tObXpSRDdWV1VyWDcyYm1aY3ZnbGQ4aUVpeCtRaGgyMXptM29Nd0tNXHJcbiAgaUJyeHhTWEpGMHgvQTJlSGQyQXoyOVo4N3NmR2dRSWNLT09KQ1J0ajF2cno5bjNHcWNCMThMaFFZQ055UktTWGxwbHRwcnA1ZkR2YVxyXG4gIEJudlZzT2dTRG8ySkNPdXFlTDlVWkxVNWwySFNnQjh0ZkdZMTFXeFVibVdqV1ZJQlppaWdRRyt3RUVSOHhkaGx4MHU0UUJZbTJ2Y2VcclxuICBnMTA2R1NwWWU3L01uZnVlSEgvTVZEbHN4aFJEcEwzQlkvOStTWXFLOG1YejVrcHp1NEZGMDZtbkhLa3o1OTY1a01CbEVDTCtldlcxXHJcbiAgZDAxM0VoQTJDSlh6dlVIUVY3QXVZLzc4SlhMNDRiNGRPTnhDc0o1Q0xMVXYxbGc4ajNDZEo1NThWUTZaT2pIQmRjVGJvMHpJeHhIaVxyXG4gIEVUUDN6V1I0YjhBK0tRLy82M256Q2ZZRnZkYWU0TEhIWHR3ekFSa3l2TndVNmEzNllZNGVObHkyczI3RkVFeUFLR1pCdDF3d1FBS0lcclxuICBlM3BTdjJxWjgyRlMveUhwQlpJWjdURG9MaGN3SjkxZzRpdkVDbWIycVFpMHZibGVjSFBPK1YyYmwwaEJaREhpeURrZTZuVTBuZ3o5XHJcbiAgcUYzUEttMGxYb01ubWlpSUFZOTRDVGt5b2hTdWc1VlBreUszM0JMbEJ2U2N0MG1ZWm1uaWVFMUZWdHllWFNKRkEwWkxhZFoyL2NDM1xyXG4gIFNXdHJ1eW1mT0NxMmJKTE1iZTlLM3BpVHZHN1VQM005b25GWFFpcjNnVDVELzRZZWZyR2wvVnJKZnV1UC9pY0pCUDN0bzRTbWR1MThcclxuICA3YjhPc25nZGJjZDlDYjBycFJOT3Rsay9Ta3R6ZU1lZFIyV1FTYk1CRk1RRHpvT1F4V2x1TlVaSlh6ZVFyZTFEYkRIcFhhL0lqVGw4XHJcbiAgZTV2djA5RFMwaUVWeTJiTE1UOWFaSVNoczczRkZQR1lxeHJ4ME5JZ0Y1Q25SaTNOckRkUEVSSGlJbHlOQUt0ZnVjMDRMOHhKbzRMbVxyXG4gIE5CSWxMNGpNbE5TSzVCSDk3TnFLTitCRkp1TGdmTDRpUTJiY3cyWmVwT05sazZ4NitRODZ3L1oxSjV2bi84ZVFldlc4aDJUbkxoZGZcclxuICBwWGFtU3ZIZzhVb05kMHBqL1U0VDNiSHpJL2MrZk9ZWFpQRGtNNlYwLzJOa2lCS0hzRWdRYm9SRm15RDVhdVVhMkpFUmNSSWNXTlZIXHJcbiAgcnhyM1FSclB4eHZtUEdnRUNPSlRxb2g4NU5HWHlwZ1RyakhSRisxeHJSMmJjR3N1c3ZpeEg1Z1BLdDducEl2dU1DSUZONUlWY1NqRVxyXG4gIGdkSFR6NUc1VCtITzNYeEJTbDUrdnJUa0RETno1Z1gzWDJVNkdjU2ZjRFJNZkRpRzZiMHNVMjRDRTJDMjNFWHNCbUhCb0FDZEdBUUhcclxuICBRb0l1RFVNRGV5ODYzcmtJK1VaRTlIdkFFelFHQkhCUTZWa0ZTa0J5dEF5N1JqNXZYQjV4M05qUC90bDBXeXhMV1p3d0x2blA5OHhQXHJcbiAgbG85TnNYVWtpLy85UFJsMTNOWDZIcFZyVDB1M3RVT0R0UTduQWI1RkZoMGlwZ0lRYzBMNGVLODJ6aVBJWGZ4YmVlL2RkMlJ3V1lsOFxyXG4gIC8vb3Z5TEhISDI3SWRMWnlGcXlMaUFON1owQThBRnl0VDVqZ0hpNG8zNXRJS3FSQnlwLy8vSmtKd2dGQ1hieDRwWm10aHJ6ZVlPZk9cclxuICBlc25MeTVVaFF3WWtFSHkvdmtXQzQwSGFQT2FZUTZPU2V3YnFoZm9vMDFtYndtTWlIY0pBT0VLNm83M0R3bzhENk8vTnQveEZTa3I2XHJcbiAgeUplLzVPTEczUUYrc2ZaSVFJQmdpVFZ3WUxuVU5vR3NMS21RaUVSUlR5ZCtZNmM5NFJsOVVtdGtjMVcxeFZuVlhUZ1VCMjBwQ2ZHVlxyXG4gIDdUUVlpYlFBbk9tQjFOalMxSFFlR3JmUUJxajJCdzRFTldsSWg3d29Uc2pNRDdjSnpFb2hCQ0Nnb1B2QXp3NFdQK3lGd0d3K055RktcclxuICBDbTA1MStGeE9CaWRCUm15VmNLZ0gwTk5TNzZVNWU0eVN4LzlzcVc1cGMzdXRMbTVTVEtxM3BIY1VTY1pvc0RGZW5wT2tReWVjbTZpXHJcbiAgZmVjK1VpTHVBeUlSaUVieStoNXlQNTYvWnRZZnpidHY0bjY1bXBYRDRxcGNaM0tIU2JZK1I5eUx1OVdMMTlVZllZMEdWbGZJcEZtd1xyXG4gIEJrYzA1TkFMdWhBUDlCNklOUVlySW0rcHJ6TjlCcnNROWttclVtNXJoK0JGbkxsOGZtR1I1T1lYU21kR2dlbG84TjhWckx3UVd4VXBcclxuICBvVWJPVDlxUWxENVhFTjdZVTc1bE9nUldyeU5TQk9CSUFMcFpyM0ZrK0lodklCS21HOU0yQ05GWllObUVGUnRtMzh5d3NXNGFmc1JGXHJcbiAgZHEwMXIvM1pacmpjTGVmR1R6bEtOc3g3UmxwYVcwWDVRMG5WV2JST2ZaVmdmVUxmdzVtSytNNncyVFlFcy9LalYwd0pYcm5rRlp0cFxyXG4gIEk0NENvZktPQ0htM0F5WWVyNXpJT0t2REFWY0NaOHc1RnA3dTByRUxNVVgwdCt5Wlh5bFNWR1QxK2wvMXZ0SnNBalRsQy9ydURqN05cclxuICBMTyt3UEt0YzhySXNlL3FYdHM4R25kNy83QjhhRVc1WDdnV3gyNnIvZkVzSllJTms2cmtPZmNYbDB6NHRFOC8vblNMVmNobDEvTlZHXHJcbiAgTUNhYzh4TUxXVDhDb1RBaW90emRwcm1QeU9aNWo1b3VodnZoNGJLWENrcDJnREsyRjRrU0M5NFBWbE9JQ2MxNlRkOEJuQ0wzamJjQlxyXG4gIGpDVGdzQkJ2c2RDVWI0QU5uT2cwZWhEMkd1azNkcWI1dWlxYmRMYnJRM0JuQTJqZmNXWFRzRzJERW9aYTZhOWNDUVJuaFk1RkZoV0dcclxuICBNb3hKaUFoNUVIY2ZzL3E2aWgxeFpyNTdneXhZc0VENkZ1Zkp0VmQ4U2o3enVlVHNlSGRjeVBzZmZHVHJHeUFZSUYwUU16UDQzYTBMXHJcbiAgd1h6MzdMT1ZrMVdnTE1nYng0WjRvQVZCN3dsSi8vS1hkeWZFU29paFFQREJheTM5LzI4UWZDQVEyZG1aSmo0ZU5hcmMyZzN0aDc1d1xyXG4gIGRNLy92d0xQaXgwUXNVVGJteDRFSzdOOUppQlpCV1hTMk80N3hqa2tJb21YRFhoTWYzdVU4N3kxeTVOT3hqbzZPaFdoK2FaRWVFdEZcclxuICBkTUdIaUNra2VaakhRbFIyNlVkVldPYU8vemlhYTdlWWVXR1NhSVN3TytMMUErVGkzSXZtYXljZ0hBeFlrQXpFZ3owblFBaUplb3J3XHJcbiAgUFI2WjgybzZ0SWRDbFErSWZtMys4SG5idkNodDhFeEoyVHJIV0ZnV0RxV25VelpGcXFxMlNmK1dKWkl4N0RqcmYxNC92VWE2bS9leVxyXG4gIDN6VmxoaW4zNFczM2NpOUdHTG0yNWlsUlJCd0c4alFua0hvZmlYT1V0K2ZyQnd2OFFEYmViODJ6c2k2NmdpTkJiczN4NFlQWHlwaVRcclxuICByN2R6b1F5V082eS9nU05EMGZyYWp5ZVp1VzdoaUNPa1l0NkQwdFRjYmdTa1hSRkxXbU9GZlBqa3piYTN1YS96d0JmVlQraUpFaVZmXHJcbiAgRkFaeUtoNCsxWnozRFRrVU4reXpmQ01pZmZhSUtuZ1BjQklRQjVBYVNBdmlBVUpjeHlKQWtCa0lYSUZ6Y0FHWTZrSTRndmZjZFc5b1xyXG4gIE9aMWhJejRiTVBFa0l6SXMyRnZ3M0o5c0Y4dXc4VkpINDA0NTZ0cjd6YWZaMmhkK0pVMDc2M1RtM0c3ZVllRTJoaDMrT1NORy9jZk1cclxuICAwUEFMeGowNHNmQUZncmdqZ1JQaVduWmdYcXJjalpjYkxtTlArcG9NVWdKQmV1aU1DNDNJdFRjMzJPSkV4S1hMbi91TmNuMXpsT2hVXHJcbiAgeUlTemZpZ2pqcmpZUEE5ZzFneHMrZUFwUTlqN24vMGpLY3Bza0JXei95R2RyVzNHZldSa1pjck03ODJUbGNwcEZTZ1JXLzdNemZhY1xyXG4gIDBSbWhDMkVyNEpkL2NJQVJhSWdlcmxFZ0tKdmUrNWM5Vy9hcVlYSm1UaTYxcGl2Y1A1OGdJcFVmdldqRUE0c3QyNTFSd1lpSTNqLzdcclxuICA0RE1aNFYzWk9ORkpsVTFRZERLUzAzZVliUjZHQ002MkhGQkFITXg0REp0UlFad1dQWEs5amJrbW5ialJEaFBDN09LQjlzMERKaEhRXHJcbiAgRzhLbkhIRTgvOEo5d0cybHpybGVsaTFkcWdnclRmNzh1K3QwTXBFdmxSWGJqREFjZlBBNFE1NGZMVjB0WTBiSHZJWXJqQjgzMHNvQVxyXG4gIGNYSFV1bldiZWtXMjVtVlcyNklPUkNCNHlRVkI5OGExZEFmT0IrUlBITkZqYm02T3hXZlBucnZQaS81NHI5UUJtYytmLzVGdGRoVzRcclxuICBMTnFQaTdIV3JOMWtuRUM0N3NjQjgrY3RsdmNYTEpOam92dllIV0Npdk04RUpMMmdYRG9WVWZsNlhpQUtMUWg1SVpsTWUwNlUxaUJ1XHJcbiAgZlpWV01FSXlDOXg2QUFTRHpneExqRXhsZFptdG1xVUltZG9lT2dBUUpjN3g4bGduQXRMa09sMUN5bm9ZUi9yNDBMRmRBZnVWYTVZVFxyXG4gIEJZaUlPM2JyWXg4VEh3aGhWcjcySTZyZlczdlk2ck5UVzBQdGVwM1p1ZTAvQ3h2eng1NG83UnZmTUJFVzI2ZUN0TEt5TW1UVHBpMlNcclxuICB2Mk9lNUl3KzJUaVcwR1pYN29OcnhPOEJaQjVFVjU2R1l6Slp2eElzeW9VNm1PdGljVVVaRHBTUm0rWS9Jb01QT1UrZm5iZEpQbitZXHJcbiAgaFBJTU1GMUc5NEhJd1VTRW5OVXlUMTNiVjJmSmQ1dU9ZOE83RHloaGZWUEduZmxqTFROQ0VXQ09ySDN0RG1sdGFZV1cyZXIwMW9idFxyXG4gIGNzalZUeWVJQjJzcTJFWVZCVEZ0UWl6Z0hEQXJMZGYra0k0RGNucDJvK045UWp5MFdkUGpZR3FOdUlXTm5qTHlpazNQc0I1T1F3a0RcclxuICBNMkNJQjBybnVYZGZiRWlTUmFaQmJJUmVBUkVReUJJcm43b1ZzeVJkMzUweUNjcURkRXBuV3Bhc2UrNm5Vci9wZlJsOHhKZVZHems1XHJcbiAgUVNpQTU3ODVTcEhwYTlyMkYwM0JEWEhhdm42QklYNDhKRUE0V09PQzhjQ09qWXVNVUFWbGVQd0lZaWhtN3FPT3ZkeUp5dlRQYUR2dlxyXG4gIEdrZXc2dVhiVGFhUHpnZGlRdi9oZ0RiUCs3Y1MwQnRseCtJblpIdGRuYW1SOFRpR2o2WVc1VzV4d1JMNndUUFlwdGNoaE5PWWVzbGZcclxuICBqVGlqQTZ2bSt2cE9lYTZFNktLWStCZ3gxalFBRnhUblJBRE9NNEhnZTh1THhnYVdZZWFkVnprSjFwTEE1VEhwWWg4Um1tSmR6Y1ozXHJcbiAgN3JleUtNL1JhV0xxeTFWeWRMeVJYMzdJcDQzckdLN1BIT0tCOG56ZEczKzFTWVFWVkFoRUJPQTlzeUNWNzNiRlcvK1VyTFFPdWYyV1xyXG4gIHI4cnhweHhqaE9HK2Z6eHBvaWFBbWY3NDhkRWVRdDBBeEI4NGxEaHhRSm5lRzhJTkJBZkVHU2NjNzd5NzBMYVczUjFRSmlEMXdCRTBcclxuICBORFJLV1puN1ludnUrVGRrNmhTZEJPOER4TnU2K3g3ZmlUQ0k2SGc4NUFlQzBkalFaTnZyOG4zdnkxcVRmWUhhdWgzeStCT3ZTbUZoXHJcbiAgdnB4eWNzUko3Z1lZbjN1RmpvWldLYzFxc08xZDl3VCs3cU1SMEIwMGUzcHBYWlNBNjQrc3J4UVFYM0dlbVpwWlgyazh5Rnc1NGhaWFxyXG4gIG1Td2kxRHhMNms4eTFFZ3NwQXdIOXZza01kOGx6ZUMxREQwd3IyelFqd0hsT1N1RUlTTGtXeHYyYUxxMlJ4eDU4WllQbnpKdVlwQnRcclxuICBGTVVwWDlGZWR2cHZkSlpSTGtWRlN1d1VXaFRaNXVabXl0S2x5NlhtK1d1VWU1aHJuQWVvRE5FUlNsRHFkdTk3YitIMmRmT05uU2ZOXHJcbiAgTmUwY2ZiS0V1eFZaOWRMdnpiNmU3VVU5UHpwbjdyV3RTMUt4NENrekdpRER4UXplUHNybjZWYy9hWnMra1ViMkRkaUdXMXBtaHlMS1xyXG4gIG9wS2hSbzlnUWVCQ210bzZwRitwejFEUWhlQTkxWldqVGp5d2hrS1BOZXFZcjVnbEVHQ0VVd0d1ZzlrekV3WkVWb2hlY0N0dWU2b29cclxuICA0UHNKWkppWlUyd2NDVWdTQ3lWaytKbEs5RUhTSUYxdWkzTWd4eFV2L3Q0V2xtS0JOT0djR3kwL1BTdExXcFhMYUVlRWxaRXBmVVpNXHJcbiAga3FOK05GK08rYzAyYVh6aGEvTFl4V255eUVXcE12dm54OGpydnp4VzJLUnB2Mk8vS09mOGRxbWMvdDEveTFtL1dpQkhYUEliT2V5elxyXG4gIFA1ZnBsOTRsTTY5NVdLWisra2FaZlBvMU12MVQxOHVSWC8rUEhIWERxM0x1dloxZERnaGI2Nko3WmRGZG45VDJVK3hZOG0vdHZ4S1NcclxuICBTWi8vZzh6OHh0TjJuNGdJbjdsdXBCS3RWNDJ6UE9HbUQyVEVNWmZKcHMxYnBWVlpqelk0VDMzbStUcnJCdGEvOVEvamx1eDU2RE5JXHJcbiAgemNxeDU4TDRoUk5aTy90dUUwbnliSGsyNVBGOFNXQ3B0bm5lSTlhT2pRMkZLdVU0MEplNEF0enpXR2dMSjRJb2tyRUFjVUY4aFdkY1xyXG4gIEpoOFU2emZtU0xQQ0kwRlQwNjk5Mmx5cTJPNk5TbkRNM0RkWVlBRWE1QmFYMmZvUWZIMUJrT0dHVVpiSHh5cWxlWmNzV2tTaFh2bnFcclxuICBqZEszT044V0NwNzRDVi9yQVh6Mnd0TU15WEl3VXlka1BVZHZ3RGsyYVFxQWFHWjNzM1dRZnlBNEFIdHdBT2VmNXc0U2FXdDN3TGxBXHJcbiAgUENCU1U2ZE9USlEvZE5xZTk5bm9EcUZlNk9lN1NzQ0EwSDdJRC9mMWNicDRENHNJUC93d3JNWGJQYVIwdGk0RUYrd1c4b29uR3dFQlxyXG4gIENzYTVmTkJmY3dRVzlYVGlOM1k2UWFNMGI1UXNsd1ZybE8xWDZKOWZLTTBEZkRFUk1tRGNPTVRYZmlDMlltYVAyNHpDYU44S3NCZkVcclxuICBoRlhUeVprNllaakJSeUluOHZUREk0U0FCSjlYdHFoSmthYjd3VHBjcTBWck5KaWhkbmI2UHV0Ui9lNjZEM2VZZUxyRmQrck1zWERRXHJcbiAgZUNONHNPbkpzbjdOMWprM3l1clZxMlhIamdhNzE0eU1GTW5NekZRa1VDZ1pJMDQyeGEvM3RYdi8vWG84TTg4bkQrUit2OG12UTU1elxyXG4gIFphbkdmV0RPeXdZL3ZtQlFFYjdlcTV2TWVsMytjTGRkZnRqbmpDaWpzSjV6K3pubUVKRnpYa1pzMWpwNGlydWNwNkczYmoxVkR2K3FcclxuICBML1Nqd0p1L1BWa09ualJWNWp4eHUrMHZqbEFvSXoxRlJnMGZMdnRkK3J3c20zMmZFbytoVG9TMVF2MjIxVWFnRVVXaERBY3dvY2I2XHJcbiAgeVlpTElqZ0FjOXcxaXZUWXZZNkJpSzVrM2V0L01lSURrUUVSQTNHa1NRL1JsVXo1d3A5MXB2dW1Qb2M3ZGVZN1F5cVh2aW96cnZFOVxyXG4gIERSYitsUFk2WmVPR2piYUdoYldJckU3T0x4a21sUnRYbXFpUlJYa1ptYWxLTkhqbURuQ083SCtla3A1cnJsb2dZbzI3a3ZzZjdBNTRcclxuICBmOWxLckpCYkEzQU1PMkwxYUhkdzJWQWRGeTZ1d3RJS0JUZEtld0RpQWdleWJlbUw5Z295TXRPa29kNi9PMFNpNWVYbE12bUhhKzMrXHJcbiAgK3d5ZGJLNzdlVGJvVEVEczRkbGcvc3VpU0Fnd3p3L2lBQkVKN3dGaThzWnZUNUd4cDN6YjJrWUVCK0JXbi9ORzJKVmdZTmpTZ2htM1xyXG4gIFBrT0lCOThINzIzcGt6K1JtVjkvM29pMHZURE8yMFFFQzdnSGJROTIydTZyWE9oeWRDT0lTM1U4VXA4eTc5ejVLUmwxL0xYNkR0a3ZcclxuICBmYnJNdWZPVGN1amwvOUpUK3JaZ0V6VWZEaE9EaEp6cTJmcmVtdVRpVHg4bjEzM0xkd0dNd3g5dWYwQ3V1dklDaTRNODQ0aS9Pd1RrXHJcbiAgR3NxZzcwQzNzRHU0NDg0SDVTdFg0QjI2SzBDa2RxY2JDSDJnREFnK3hFTjVUSVN4eHRvWGlOOVBpSGUvUjU0cDR5N2tQLzdFSzNMbVxyXG4gIEdYaDkrTDlEZHQ1a213QjN0RHJoMmgwa3Y1emRRSDNkZkVuTnpiQ2pCL0FsKzg5dW9PczVpRWNmN0JFVk1qUEQ2bEpBUS8xSGJNWFhcclxuICB3K3pEZHUvVHY4ejh5R21peG5kdFdtUUtkRWQ4WkJGcUtvcUgwTTU1QVZNcU01TWhuOEdNZU1ZSkNxM29USnNaa01iTnpUWjVWdC9yXHJcbiAgeHVPMk9qcUtGMFp1UWtDWVd5SS9QMTdXRVh6bWpCdGxlUGxRS1M3SXRRZWNtNVd0eUtCWktpcXFwTFFSZDhsS0lQU1BlajBQQWcyalxyXG4gIEE0TUFaTk5keWtmbjFyeDJwelRXYmpidWcrelJ4Mzh0RWdsNE9mN1l6SW45R1JxcVY5dU9lQ3VldThXZWc3WG4vem9ETHJQOVNpcVhcclxuICB2bUpienM2OTUvTmRpSWQrMDRaRTFuNElXNHNiZlFkREt0WFZzcTFpdlJMU1lkb1hKZ2R3SDY4WjhnVnB0VFUzU04xYS8zaHpTMGNhXHJcbiAgRW9MakF5QWVyRnRBTE1LNkRaeFF6cjNyODJiSmhTVU9TQkhDQVlBc1AyTEdiU21SUTc3MEY3TTJRanlHbkR4OTZUMHlORzJOdlBtdFxyXG4gIFVqdHFhMnRrNTQ0NmFXMXBVZVN0Q0Z6cjdGUjJ2MkxEY3NHUnM1SjhTVlV1bU9IWTNOd216WTF0aHJDYm05cWx2cVpLT2FOMTBsaFhcclxuICBLUjFOMnlWREwwcjVjSVIwYmw1RzRzakpUWmVXcGlhcFUvWWZFUUQ2TDlyamFOR2pYZHZkdkdhTmxlM1hyNCtzZmVGbUplVG5HV2Z5XHJcbiAgMnRmN3l0b1hmeW83MTd4aXI0NHZwRm5yNEJPVzh1UnQyTGpCN2grVDRvTCtnNlR5clR2dDJRVGlVYkhvUlF0UmtoL0ZhbllGaUREUFxyXG4gIGwxWHRnUk9CU016ODJyT3ltVTJrQUcwY2x6NnNhNEZEQVhoSExUdkROdE84ejlsYXpEa1IzczBidnpuSjNNSUhDSnhJdWJuakZ4TmZcclxuICBJZkt5amFtVXdKc0ZaRFFteDV6d05lT0E4d2VNMDIvdmJUbnNpa2R0ak5xZ2lzcXc4SEZBNjRleVp1MDZPWEQvNFhMSVlZN011Z002XHJcbiAgaWdCeFpOc2J4QkV2c0tmdFcya2pFSS9RWHRpemZIZWNDeENRZkNBZUlSN2c1VmZtUkxHOUEvWFJvUUJoYlVnSWYzOGJVZ3hKN09NZVxyXG4gIDhoY3MyRHZIc0srQW1JeHh1R2FObTEzdkRzTDN1RStRRmlILzNvQlhiNzhlNlFxeHZOb09UK3dzZHJ2bCtvcmxwZ2NCMGZqaVFmMkFcclxuICAyc05nUVh3VkxXTFVhdWEyM2VLMDRRalN3ZE4rQUhyR1BneDN6b2I4bmp3UVhwRDVNN0Q1VUpnZFZlbk1OUXp3VURkeGpTZ08wVEhSXHJcbiAganhLSkxRdWUwRE1nVjhyZzRKRjlzYVArNkhucTVCN3pTeGs3ZHF3cDV2RGNpOTZBaDcxa3lSSnBmdG4zNGdodDl4N3lyejk2MkNaYlxyXG4gIElROGlwWkhWeW5Hd01BemxxSjBBckxqWHNUWTBYUG5DcjgzSjNaaVR2bW5uOG5XbVAvYms2NjBzN2JOOTZlSFhQaXZWcTk2VW5ScytcclxuICAxR2ZmWnR4VlZNQTh0Y0oxNFhSdjRyVnpaRXRsdFJUa3M0Y0tCQVI1NlU0cGFsMWo0cmorWTQ4eDRqRjArdWRsNUxFKzYySXJWZllxXHJcbiAgb1FLTDk1eno2RXdRRDRqTW10ZithTWdPZjB4SGZ2dFZXZjNxbldaV2F6TnFSWDdVNDNwOUJ3NlI0UWNmS1dtYlhwUzNieWlWOVMvZFxyXG4gIExDdnYvNnhpZzVkazhlS1BaTzc4RDZWUysxZFZWUzAxMjJxVllOZElxK2srRk9rcnJzbkpURkdrM0NsdGlzdzd0VUdjMURkaUZOQ21cclxuICBzMThsSnFBam5maExsaElZNWpkNjIvWVJjWiswWWZOamZaSG9BU0hzVFkxS2NQUm9hMmxYUXFWRUxKc05xNXlnWk9Xa1c1aE54eU5vXHJcbiAgMG5ZZ0tOdTFieDJORFhZT096WFNnZENrdFhWSXVoNVVnK2kxUm5tWjJySGxUOTBvTDkwd1ZsYmRlNTRjK2VPRmt0T3kwVjczd29ldVxyXG4gIGx3RVRUN0RuTmY3TUg1aklqeDBYZmM5d2tjY3Z6K3RCUklaTU85L0VYZ0FlYm4yTmtpakg4aVBuL3VBU0k0TFNxUStMUlpPTUtSTm5cclxuICBLYmZDd2tQUzZIT0NTM2hlTXM0MWFUK3ZmK1FiYS9STXFmcm9aVCt2end6WDcrNEdmN2xOTXBBNklNcWlybzEzTGJmenBhdmxnL256XHJcbiAgSkRPMVF3NmR2SjhoMDdBRmJSd3V2K3g4UTlMeEl5RFQ3c0M1QU1RUFBIQnNvazUzQ01nZkNPMWwyWVRYL1YvMVZpY0E1MEo5NmhKdlxyXG4gIGJYVjh0aWZpMHhzRUFobnFoZkNnQTEzTSs5TEx2aGxmeUE5N2hYd2NjTkhuZkYwWWU2WHZDZjRyQXFMZmhBTERZbDhoV1hibW9PUnFcclxuICB5YjY1K1lsVG1IOENUYlViOU5jemtac0R6YnVxM1BwSzgvbmJ1ZGtWenc3eFVNK1NyMGNJUFYrL1dJMmpxTFlWc2FscC80Kzl0d0NzXHJcbiAgNHVqNi8wOUlRaEk4dUx0NzBWSzhRa3VGK2xOM2QzL3FMZFRkM2QzZEhXaWhoUUpGaXJ0N0lBU2loUENmejVrOTkrNjkzT0I5M3VmOVxyXG4gIHZmOHZiSFoyZDNaMjcrN3NPWE4wMUFhQ0J3bWpveHF0M0VqWUhTZm5rZFlQblJ2VGpoT3RtWitkajJIbHBDODB4Znp5U1o5cG5icGRcclxuICBqL01NSktqUFB6M0hsWmVsdEpYS21abVNucDZxUktoU3BReWQxR2pTNUNtUzgwMTByZ3hiMEYvN1Z4THNjeDhjMTFnNTZYTzNHZHMyXHJcbiAgc3dvQzBwcGdFRy91Um5aNnozcGNEMmtxOUFQdm51VTNnMzI0VVBvTnY4eis5bjVaNVpnUWFvaG1nNjZXMVZPL2sxYUgzZVFPK2VQTVxyXG4gIDRjRUlGQUpTa0xOQzA1WVFoWi9xS0RMT1RSQzV2ejhqcnNNUkUvZStJRHJsYTNxRE5EWU5WQ2hjaXZnSTA4dGp4ekRtQVZIemhDcEpcclxuICBhclk3UUJhTmVzMUpVcGZLaWhHUFNiMHFXK1dMODFOay92ZDN5WmduQmptSjR3NzVkdGdCTW4zQzc3Smk1VnJKMjVUdnBJeU5zbnJOXHJcbiAgQmtmQWkvWEo4Y21oQ1NIbENoY3I2M1k2dWk1SmJsOUIwVllwY21zWUFlbG42TTVwT1B5NU5kQ2Y3RnJab3Eya3FCcUt1S0U2WFE2WFxyXG4gIDV2dWZKVFdhZDVKRzdYdEw3VHExcEY3ZG10S29maDFwM0xDZTFIUGJ5U25lVUorYTVONTFTWXJrTzhKZjRKYk5qQnhjYzM1R0ZYK3RcclxuICBFcGlQdXo1TGlidkIxSURwSkRuUmhuM2NlNHFybU9ZV1Y1UkM5d2Zta3FJUHZFUVd6RnNnWDF4Y1UwcVcveUhGMDkrV2FxMzZScGd0XHJcbiAgNjJydU9XTVhvVDhnVmV6bmlMb3hFVkxQd0VTS2kvTDBmWkNPSDhNNTcwRFZVZzZjd3paenNMRE9tbVBPRDc0L0doTUI5YnNkcDVIcVxyXG4gIG1sUExnVDZLSysra055OVdPd2cvR0xVbEF6WitPeStKWEZsRXBKY3BXMDZXVC9TcTFNbnYra1NhbXljK0tYTm1UcE82OVdyS3gyL2RcclxuICBMVmRlYzg1MkNiWVJhUlk4a3JaSHBLbHJoUDJKSjk5V0Y5a1JwVVNtRytPSUVHZTM1bHhjWE8xWUlsQVBVTWZPVFUxTjFXbGdyWTJkXHJcbiAgbFVTZWVNSkxHblplL0RwOGI3Wm0vOTdBZnIxOGJyQkhIMmNtMDlLeFF4c0l3QTRDcWpUcEw1czF0WHNBLzhVcGZNbjlqZXlpRUd5NFxyXG4gIFZiZk1OVExpcjhtNjJiUldUVmxUd2VkY3lsMDF4eEhrVnVyTlZNR05mSlZJYXJ0Sm12dUtENWl5dDMzVTFnN00wRkRYT3RwM1BkS1ZcclxuICAvVHBzQS9GcjlTMUhaZU8yTVpqajlxbDEyTTVhckFueGZGMS9ycDJuMjY3TU5mQzhxdE5waVBySkUxVEZjUkxUa1ZiRDdzSHFoaVBQXHJcbiAgV2FOaXFERDNlVGRDbnVaRzY3bHFOeWh5RkFLSGhHYk5Ha3V0NDk0SjZ2ckk3U2FhUnQxdnMxNDQ0bGszbXIvVWxlMDNsbEhwZ3pUa1xyXG4gIEtVNnlRZzJRN2thUTVFTFNJVE5QVU05bFVxaUhOVlczTHovaXl0ZTY0N1RCVS9iMVpuMTdueU1BTndyWldnbmtpaklQZHcvdUwxT2lcclxuICBWbktTSDNtZllDU2F5WGp1YXpKbDJuVEp6Zk16b21Xa2wzVkVsZWxWejFTbUFFajdUVlEzTmhmVnJUc3BBanNPek1WMDhxem5mOCtVXHJcbiAgcTQ3R0pwZlJVVHk2LzJMWHh6SXFWNWVOYTFabzFtTTZhSW9qcnNXSUV3Nk0vckVMYkM3WXJPb3BRSEprVEZHT2owaEtSaVZKTGltU1xyXG4gIGpOUVNEVWhEZGNWODAxVXFWcEIyYlZwS3JSTmVsK1FhN1NSdnpnL0x4engxWWwxMDc2ME91MDdLT1VtdjZqNnhldSt0eGZsNENNaWFcclxuICBoVzd3NHRZbEd4WktjdlZZYnhxOEJYSGpEYU40M3JleXRVSURtZnZhOFk1NHJIZE1Ma3RxVnFzcTVTcFdsT1VydkIyUTM1dGN0bHhKXHJcbiAgUWU2bU1xbnU5L0hiQWRJSWdNSEJTR0FvdkF0K2ZTcS9zMXlxMXVGdGN3YnJPbzBiU1VabngrUWN3Y2N1QXVzaGl3T3FQd1l2UE1OUlxyXG4gIER3K1NvMThzOU0vZk1YYmVDM0VzdkZNODZVZ0h6N05yZnNEbGVveEoyM1RLWjRVbkU2Z3lhWERHVjNlcU54b3hOUUExSXYzRzIwTkVcclxuICBSajgyV010VjNhQ0xjM0hLYURuWVNiN3VYRFFCazk2ODBQWFpVOTBSMnQzcXBKRUNxVnAybzh6NDdtSDNHemZMczQ5Y0xiK1BSN0wzXHJcbiAgUkR4TVBNTUlFMVFpd3NsalZScmlpYXMvYjd4YmJ6dHl0M2FSSGxBVlVUYmJCb2kvanpEc09uWmY0WFhZUHJJak1OVXRrMDBCT3o4M1xyXG4gIE4wOERGaDkzek9XS3kwL2RwdjFQUC90SmpqN0tiTlc3ajRrVFowaVhIdjlTcVdiRXoweWNseGowdloyR040UUZvRWZIWXp2N2pIbUFcclxuICBXVXNDc2NpTnhuMytKVzlQQUY0ZFJGOE1OVWJadGlQN1djZVdqWEN5ckovUFMvVEJkV3hqKzFDM1JGZkdPd1N2SDF3M1ZYM0YrY0Y1XHJcbiAgNGJMN28vOXFkenBDdDFQS2xwZU5aQWwyWlJoS1JQVVZxcXVQMUczYmZxS1ExOVg5bDlTcjMwREt1dUV1NmcrWWlQdnBNbnZ1UWlrWVxyXG4gIGZxbWV4ZmxOK2wyb3MvVFJ6cEt4NzBUYjFoVzEvQlhZeDRmczU2Y1dyM3UyNDhFNVRCT3J6TVB0dys3UklzUThmRDNSU1k5Z0htd3pcclxuICB3WTlDajVjSjlOSkptdE1LLy83Ump3eFNWOUNtQXk2VUdvUHVkUVJjeFZFRlJ2VXRXNG8xUmdZZ1hheWUvb015RDFEa21DaUVET2FCXHJcbiAgZ2JSbXU0UGs3M3VhYnNNOFlCS3NrNXdNa0xkdXBXNG5PYzVReGkzRnhhU0t3ZEVCNXVxSkw4a0ZNNnRXa3ZyMXEwdEtlcm9VT3ViUlxyXG4gIHFHRnRPZkM4KzZWRHh3NXVSSjhoYTdNM1NxOXJmcERqM3lpUmc1N09rZklIM3IxazFJdVh5c2g3QmtwdWNWcmQvUjlmSndjOGtTMzFcclxuICBEN2xGcW5ZNTBiM1RrVExDSFJ2NzdDbTZudjdsQTdKaXBwTmUzVVdUM1B1SDhhUlhyU3ZwbWNHYy9HN1p1R3EyVFB0MG1DNmN3ekpyXHJcbiAgeXArU3ZTNUwybHcvUTNyZnYxS09mbVd6OUg1d2xhUjNPRTN5OHJaSWswRTN5K0gzVDVmREhsbFk1cmczdGtxREJnMlZLVlROckNIdFxyXG4gIDJyYVU5dTFhU2ZsS0ZWUWlRVEpKVG5NREduYzVwQkYrT3hKTE1relY3WU9Icmx5MFNGWU9mMFJtdm5LY3JCMStsNlRQZVUyUzB5dklcclxuICAyamw0MWZsYmJYUDRUVkhtN2Q0UmtnajJSdHpScWNQM1hibEJaODNreTdHUzRzMnVINkhLd3NXWEZyQ1BrTm5YOXd1WURSbVhnVHFTXHJcbiAgVUllR0hGcTdnUWkyRWRLaDRPNUx1cE9zT2Q3N2oyZlorYlRuVkJYTUlJaGVUWkRuaUZldWNvT1JNc284RGpwMG9CcWZ3d1pyQ0NScFxyXG4gIFJzSXdRc3lJLzQwM3Y5QXl4SlFsSHRRbExzUEtudWppdmJTdEZHTEh4NDc5TzBZYVlYL2x5aFVUdG0vdzdmcno3VnpiampMRHhKSlBcclxuICBHREFQdTQ2MTg5RERyK202YytEV2F5bmw3ZmpmZjgvUjlaNWluMzBZekRzbTl1djI3M09YR0VqbHNpYUl4OEozR2Y4M2l0QjJxSWczXHJcbiAgeW1FRDBYbTZVZXFhdWJyRzA0cmNWMVN6dUJEQXlFZzduUHRidUhHVkt3WU5zZGJGbHlPRU5vUU05NUZ6SExkUzFGYllQdFl2Y2cvRFxyXG4gIFVXNUdSaGh5YWJsOGRWeDNHVzFyWTc2OVVKbUYrVFZZYjFvejMwbEZzOVRZUys0bWdnaHpscy93OVlPNnJGeEJ0akJ5Y3h1NDdaS2hcclxuICB0dExCVDh1K3ZRZW8vV0NMRzFKcTRMdXJTM1R0bXErOHIvNkNYNS9uVkZrNi9nUE5wY1R4cGdNdjhlMEgxMEIxMWN5TkVQMDEvYlhzXHJcbiAgV0hpYkNQN0lmaTNaY2I4TEhUYVpVWWtpbnYvekUycjRiSFg0elZvVG1HMWw1dGQzdWRGbGlXTUdod2NNSVVsbVR4NmxEQVRuSmVnR1xyXG4gIHJDUXZMMC9qVEJpNU1rZjMwckh2YWZuN3k5Tmw0aXVueW9TbkQ1WnZMa21UYVcrZkozOCtObEFXTGxxaW8yZGpIakFHSkF5WXhlWUNcclxuICB4eHhjbWRIMjFpMXVkT3FZYlZyWkRHbldxSUZVeUNndmFhbGxuV1NTSWtjK3ZWSmFIM0d6TEY2NlZpcFVyU2RIWGZ1eWRMdHJ1WXovXHJcbiAgNFQwWk4yNmNkTHp3TTJVY05kcjBsM21mM0xBZXdsNjBOYjFCLzV1SEMwdU50djBEaHJHL2pMaDdvS3laNFZVMUE5eXhuaGUvcmV0MlxyXG4gIHg5enVHT2dSMm9ZdEZXdTNVR1pwMjdVN0ROSjZMSnhqNS9Fb1lTcGZYbFpYMTRERWlzZS92a1dqem1mOTlwNU0rZlFlbFl5N0RGMGdcclxuICBNSkpLM2MrWGFkTm5TMG5MaytTZ3B6Wks0OFlOM1NpNFJMYVViSld5am1sVXFWSkp5cnAzaTRxTVo4U1FqcThTS1NVL0owZXkxcXlWXHJcbiAgVlV1V3lyZy94c3FzOTYrVldaL2NMQXZmUFUyWmQ2V0duVlJDZ1ltdzV2MDA2WCtla0dzTzQzdnJ3MjdRWUZOVFo4RkVpTVhSNllRZFxyXG4gIDJBOURJWmlWYjA2OXRaZzhMT2hYMlF2L2xPVVRIUkYzeDFCZnNidTRJRWVUTG1JWTEra0R0RCs2eGEyWkgyVkxNWG5LM0xramJwZHFcclxuICAxU3JMRTNkZnBNekRFQ2JVbE9mUFI5VWRDN0xIQW9oelBNR05SL2Z1N1NQSFVGR0M3dDBUeDJkUWp5QytzTlJCKzZRckthMTlRRDNRXHJcbiAgcWxXVHlMbWN4emwyckRUVldXbXdkbXh0ZU9UUjEzVWR1Y2Qrc2NmM0JNU2U2THZKOW5ud0VtR1hHRWlxUk9jczN4VjByYnBXcWtBTlxyXG4gIEhFb2NRZmhqcFo4b0tpWERyM1VPRUQyY3BFWmMxa3pnUThmMlNKSks5VG9HVlNDRnZxMElZVlg0Y3BTWk9DbGtucCtxMVNhN3lXemNcclxuICBRM1cvSExPWjFMeSszcCtqNThhVlNkTkJSbE84VkRCQTErMXl0S29JQ0haRFdpSWR1TllQL3RtNXkvLzZSSmdYQTROeXcxNmVRU1MxXHJcbiAgT1YzYUgzbWJ0R3pkVXNxaW0zQ0VFVDNzdEw5bnlkOHZIUzFOZXAyb2JlQVJWcVVSYWtQZm5pMzh3dzVEZWY0SWZONjlWNHNlMTZQVVxyXG4gIEUxbjQ2NHM2RFN0bHBoUlYxUUViZXR4SHBCUFVHRlNYNHNKY25ZWE93OXM5SUE0d0QwYWFHTm8xNEZGcm80OWY1MFp5NVNYVjlTNklcclxuICBPOWlVbFMwclh1NnBicUJ6SG1zdnpTcHZrckdQSHFnREJuT1QzZUtrQ0Rwa1VYNnhFa1U0RUFib0xhN01QbU1lL0p6cVZTdEthbHFHXHJcbiAgdEduVlVobzA3eXdIM3ZTVDFEenFPYW5aNzBxcGY4Qy81YkRuQzJUMGt5Zkk2TmV2MXppTUFmZk1rZG56RnN0SHA1ZVJtbTBHUkJqSFxyXG4gIHBCZE8zb2kwVWFudDRFd0l1eklOeHloZ0dDUHU5aE5kR2RFM2htQ0FjZTRKYUF0R2NzUlR5M1VORS9sNTZMNFJadExPTVpIT0p6OHNcclxuICBpMGUrTEQ5ZXo4UmkwNVd4d0VobWZuR1B6UDdnNnV4dWR5elM3WmFIM2FZU1NvOGJ4OHZnWi9Pa2JyMDYrcnlRUkNyV3FDMWJYWC9hXHJcbiAgNHZvU254a1NDVStjdTJlOWZQRVMrZkhhUmpMcEtkZDNmN3JTN1VGcEpPcldIcnhTWlNqWVI1aWFsM2VvZGtqM0lveUo1SzZkcjR5a1xyXG4gIGdldkxwTzduUkk3UkY3enR6a25sblk5MDMrMVViWTl6OTd2eVc1VkNZQ2FzV3g1Nmc2NjVKcGNsQzhMS3FkL0k4bSt1bGRtelprcS9cclxuICBQbDNrdDNFK1gxZ1lFRjRJc0JGZll4SUdVcDhEamxzZHBJVFNZTVIyMzMyOWs0RkpKZkdnSGlveDJnd3pwdXJWTTdjaDVHRlFuN2t5XHJcbiAgeXBmUGlOd1A1NFhQR1pCQWJiWTkyRDNFcitQdlkyL0dnM1JvNytkZTJwNTMxeTR4RUUweG9vWEluMUlRSEF0V2pFNnpOOU5sUmVwVVxyXG4gIDl3bmpQS0dFaUVWVHR1UFJvU25HM1hsbE5KRFF3VzNrWUR6M0c4RWFoTXF1VHBoeEVCMk01R0hlSFJqd1VHRnhDbE5oRW5HT0ZMSjJcclxuICBKbW5iQTNzREI2MGRMYk1aVlY5VnF0UGFNUkVlWkpMR1N5anpVRmRqWDkwdmtZTDcwRTUxak9NMDM1NWJOamdwSkF0dm0vVEdVbnZRXHJcbiAgUFZLenBtZU91YmxGa3A2ZUl1dFdMNVZwcngwblRRWmNKSFc3SGF2NW9qaVAxcXhOL3BNV2hMMk4rcHlyUnhicjNPREJid2l1ejZoUFxyXG4gIEs3T3cwclhmNXQvTXIrN1VsTnh6blBTQnpXUHVOL2M2NlFNRzR0c2hoVHlBZVl4NjVDQTNNcjNaamZSdjFYMm9PWWd1cjFXcmxvNTZcclxuICA4UTZDRjRKSlk4YkxmRGVTblROMXB2dzFjYUxxOUJrd1FPaGdKSXlZWVJCdWx4SStHRXFLcTRNcXBuclZLbEtsWXFaVXFsUlI5aC9RXHJcbiAgVDJyWHJpZU5EcnRUTmpjL1FicjhlNXpNL3ZNN1dUZHZyQ1BLQTZSK3p4TTArQThjLzNxSlZLelpYRWJjaXdReFFoa0hSSGpoRHcrdFxyXG4gIGhuSFU2M2RCUlpVMkhER0hjZng2LzhGNjNvQ2JSMFNZUm1sUXU5WmVCRXprZ0dGaklzd2tMSlVNdW4rR1p1K2QraUZTb01neHJ4WktcclxuICBjV3JsS2grZDdoajZSLy9PYXVQT0lYYmsrK3RiYXN4SXIzdVdTOU1tVGFSV2piclMrWlJucGMrNUwwcWxLdFdrcnR2WHQzOWZxVnlqXHJcbiAgdXRSdFdGL1MzZlBrOWZCTGVGOHpKazZTV1o4UGxiRVBESkNpS1MvSnlyKy9VNmNHMUxvWTFUR29vMjRrY1NXUjR2UWIzTEFKb01WdVxyXG4gIDR0T2MwRWU4WHB3K3JtcG9kNUdDRGFzMGtTTHpuUmk0cm5xdHVYWlFaYzM2OGs2M0oraUxibC9PMUU5bCtmSVZVcWRXZGJuNmtoUGtcclxuICB3UDJEL0ZnQklKUVF5VERoakIvOXN3OXZSd01PRnIzMzh6YldlRHo0MEt0YW45VHVPNEpkRTlnMVR3KzhrOExIRW9FcGRjbk1hN0RmXHJcbiAgQVB6djJEa0dFbnhhcGNMYTNOSDk3QTRzcG1SQzZIZkVZOWNZU01tMkVvai9nZTd2ZG43cE9DZVNHOGhRQ1lqNTBLQkJod3ExdmI3TlxyXG4gIGoyeEFrbnJ0c0daL1drVUNCKzBhck9sOEZIMG5EQTc0dGR2V2RPMnVySW4xM0RZaklNdlB3NmpKMTNjZG1yUWdXdVkwYXlmYTV1YjhcclxuICBqVDVLM3BWaEhxamFWSDIxWUp4Nmg1RzJnK3Z4TDNKZXNQQ1BhVU9SWU1nbHRIRzU5OVRDSmxKU3ZvNDBQTzVGYWR5NGprb2lCVzcwXHJcbiAgelhBeGQrTW1XZkkybzdnWjZxSkxtNzY5cUlxTnYrd2p3QTNwdzQ4VTJRbUkrM2hZR3U3bkpSNlZQZzY1M3BYOWE2WXAxQWdhUk9ZMlxyXG4gIE9BMFhURFdjMHpZVkhNalBCY09BMGVEazRPRVpENFNET1NYU0J6Nm9lMHNLdlJXYm5nRmp3T21JWmF0akZnU2c0b0pLdGxCY1p4bCtcclxuICBJSXlrcFR2R1VySlZ5cVVtUzgzcWRXWEFOVjlLOVg1WFNFbTFkbkxnRXhza3E5RXBVdVhReDFVL0R6UEFzNGorUWhuOGNHTmI5VGdhXHJcbiAgNENRUGlQQlhWeldRT3AwT1ZZYVFNL1A3SlI4NkthUjh3KzQxalhITS9lRXBsVGhBdit0L1VDYjBQdzJZU0R3alFTTHBjUHpkTXN0dFxyXG4gIHozU0xTU01yWjQrckJ0UFk5K1RiWjdNOS9iT2h5a1E2M1RwUERlY3p2My9TaWRmTlplRERxMlJqMlVheU92TUE2Zi9nR3NrcjExd2FcclxuICBEYjVkOXIxaGhOUnEyRUJWaHNyMDNmdEJPbGt3ZTY2TWYzU3dmSFcyR3lDdC9GS3ladittQzZoY3Y3ME9ubEJ6NFFiT2dBbTdDZjJHXHJcbiAgOU9zK2c2K1BVYXJTc0lzYm1FMWhVM05id1h4MHc5WHQ1YVFRUDdlSWFKWURNakdUeVpoaldSOGRJNXZ5Q3lTMXpGYTU0ZXBUSk05SlxyXG4gIG94RENlQVpoMnh6RENNMWM0UEU0NTJ5OEM3M08vc1FUQnF1cUtoRjZCUHNYbXgxMkI3QnIyMGcvYktRMzRwMEl4SmtZVWVlZUtjZXJcclxuICBnbmFHNENleWc4U3Y0OXV4L1lhc1ZYN3E4RjBGYzVtQUgzL3l0dFpFMkNVR2tsd1FPN0ZVNlhDZHh4QXFZZ2hscEFGODFLa29VZloxXHJcbiAga3J3bmgxdVhFSXVneVJQOWZveDhIbEVpNXcrR0ZyZmZEcEV5aENKUjRxaWJJSlc0bjNxREg0bmtuTVRqS3F2a3cwbDZZdEIycU13Y1xyXG4gIDBVeTJRNWtNcW5YM2NSM2UzUzlaWkhQY0I1V20rbDkvanI4dnJwU2tNNzh4cFd1VkJwM1VPUUIvL0FiN09xSVlVUU81MzVwUlV4b2RcclxuICA4NEswYnRsQ1IvSHNCWXNXTFphc0g2N1ZsTmUwNWR0azVlMGZ6TzhCeXBhcklwUGV2bGlhRDdyYTE5RHJpOHo5L3FHSTZvK0VqeEVFXHJcbiAgOXdjRFFWMkYxTkVpa0Q2YU93bURZd0RiaUUvSjdwak5WM2RKNDc1SU9yU3Z1OXoyT2VxQXdBSk0raUJFaURjS2dRcGpDKzZ0ampCd1xyXG4gIHJHS05lcEpSb1pJa3BaU1hneTkvV3hvZDlaQjBHN1pBbHMzMHY2bi9EY09WV1NEaG9HSlU1aEVRMTg2blBhbmxrVTdTZ0hGQWJFYzlcclxuICBpaU9Ea3pyZUxIRVMxSFV5NThOcmM2WjkrMHdEdGszaWdIRXd3NkNYTmdZRWZleS9CNGtZU1d2MzIycnZNMFErZHRJSGo3Zi9UVDR3XHJcbiAgOEpWL0piVXNYN1J5S1V5RTM4Mno0QmtSUlQ3dEU0SXVSNm82ajJNOHh3SHVlWktrbE8wbUo3OHBUWThjS29mZDlidStJejU4RmhUR1xyXG4gIE1Qd0pvMytYK1ovZktuTS91MVhHT09tRWQ3QngrVFJWWndFeUhxREtBc3pCajBmaXpLK3dqZUJRY3JnR2ZxTDJaRElvSER3ME5rVDdcclxuICBEVUc0TldTclcvTmJrUHpKQ3AzNzVZa3liOTQ4YVZDbm11emJyYTMwMkxkTGhQQU5QUEJzWFJzZzN2ZmMrNklTU3Nwa0tvNkhxYUdZXHJcbiAgeDhQU2ZpU0NFZlZXTFdPOTVrcURNWTU0WnZIalR6NndzRFFRNlE3NFRkWUc5aXRqSnR6RHp0cEJXcmYyYnZIV1R2emFudHVvMFFRcFxyXG4gIGl6Q1RvV0h5eE9sU3JWYUlEdXdDT25Sb3FlK01SSldsWVpjWVNFNnVHMUhpUUw5ZEJDODNkaVdweFp1bFFscUs2dnpaUndReG5jdWtcclxuICBFRUM2Yy9vR3dZVWVic1A5eDQzVWx6a1RzSFlkMHErQzNjRSs5NDk4VUdUOFpFOXlXbmsxRUxPL1lwQVNwV2JyL1RVWm5jNENTQzBhXHJcbiAgQ05vSU14RWlwTlhyeXBWSkZNait1bDJPZFNPc3YyTnNIeHhQNGxFRzUyS2daODRQUEZySXRzcHZ0WFpaK2JWamxPVnFTYlZqM25GTVxyXG4gIHRZNlVkNFExTDQvVTZZNDRyRndsT1JQZmxQVWYveXZTcGthYnUwZnY5ZGFrWm45VU9wLzZyQ3NHMTNWM29FR0RCMS9yQ0lZZjRUWHFcclxuICA0ejVFbFQ3OGZaSnUyMHNmYnBjRE91K1dLbjFRM2JmaGp6bEc0eGdMYnhwcEErRGlTUms5dUhwVTFXanFScHVCU3RNQlJxSXRwSlpSXHJcbiAgTjlOa2dpL2NwYkZ2VksxY1NSclVyUzM3SEhtTjFCOTRsUnoyWkxiTW5qVmQ0ejFHM2pkUTIyT0I2TkV1K2JMQ3pNUEtTaFFkZ1VUbFxyXG4gIGdzb3F0VndsWlF5RlMvOWM5T0ZwWmFSSyt5TXE5YnI2Y3luSVhobVJPS0pxS3YxaDduRXdEdi92UXp3anlXeThqMG9mTS9qZGJ1RVpcclxuICA5TGpvSFhuOTNEcjFGNHg4Ulk2NFkvaHNHS0l4RVNiUm12M05ROHBFT3A3OGlDd2Q5NUUrTHlRMUdBZ0w5V2FQKzBFT2ZHQys3SHY5XHJcbiAgQ09uWW82dEtoVVZ4bjNTeWUxVFRYajVHVm4xeGdkcEdrRUxzK2VuQXdSV1RVekxjczB6MVdSN2NEdXgycUR2VnpkZHRrd0hDYkVqZFxyXG4gIHpuMVRaZ2NNQlNta1NiVXRHbEJicVVLYVBQZllOZkxjYzBQbDdYZS9qaERFNFQrOUVqT3FodUQyM3ErekVzcUtGY3RIQ0hBaTBBWlpcclxuICBzYmNIMmdubnFUSWJ5dmE4c2F3dURJRFpDc3VtK3NEQzBtRG5jVDlXZnZhNTl5Ty9rWDFXM2hHZWY5NW5EYkFKcVV4ZFJ4dkEydW5UXHJcbiAgMjZ2dDJyYnhFM0ZOLzN1V3U4L29ON283d042enZXQkNmMGM3aWRTa0lzSEowanJUenNIWDNaemlnK244UTNDTW83eFA0NHdLaGhvRVxyXG4gIG9ma1JzK3VNd1R3UzdOOFlUTUxFaHJia3lrYnIvQisvYUcxM3dJL1FnLzF1bTB5OFBxREpFZXlpUEQraTBnYUFyK092Uk5udjR4K3FcclxuICBKOHFrTFZreDZYUEhiSnJMaXI4K2RmZTVWcG1DcXFRNGdmTnBMOVFPczg1aG04RHVnZnBxK2NUUEFydUNQeDVla0pDYW52V2xkTHZvXHJcbiAgRXpkeXFDMWJ0bXlWdlB3aUorNXVsS2xUcDhycWQ4ZzRTbDJSNWdkZG9XVVlnU1pDalB3T2gwZ1JCbmFBKyt0MkJNZXRHdk5QSTMzTVxyXG4gIFVlbmpaaWQ5M0tOclpVSU9KTS9EN3JGcy9JZE9DdHlzWllWcmdHMllSNXNodDhtVWU1ckp0RmZQbEszNXhUcWExZmZxbUFaTUJOWFZcclxuICAxcUlTU1V0S2xrcVZLMHV6Sm8ya1NyOHJKYW5wSVZLbDl4WEtsQWh5SXdPdEozQkRsYmdSSjFLNVlXZE5TbGthODhEZUFlUCs4SXd5XHJcbiAgS2szMHZPZ3RtZi9Wbld2K2VQMzZSaVoxVFB1RWFWN3ZpVEFPcE5uUXc5a3hxTHFyeTE0RVRLVFJmdDZGbUxheGp4QmJoRXFyVWErVFxyXG4gIGxLbE1lUGtjR2ZQdXNKYTlUNzQ5aG9sa051bm1udFZRamM4Z1lTTWVqVHkzM2xlUU9jRTlkNTYzcTdmbzl6ZWtZTU1LYVhUUmVHbm1cclxuICBwSktqWDkwcTdicDJrU3ExYTZzMHdqdk55Vm9uQzJmTmtyK2VQVnhtdkhhY0xIMmhweko1OWNSQ0FwMDlRbFdmcEY4SDJOUnFCaXBoXHJcbiAgSkgyK1lmVzYwb0dWSnpUcjNlQm4zWnpmWk9xZlk2UW9iNk04ZmY5bGN1QWhBOVJiaWZrbmJDVE52VnJaWU1TU2ladEEvSEdEMVRPQ1xyXG4gIG53aVdHTkhhZVA0RlQ2Qkxrd2hvMCtwQ3JKbURuSDFoeGxJYSt2YjFHVGVvRDJFUDM5L08ya0hzSE5yaVBDUUR1Mjc0K2xhUDlTc3ZcclxuICArYVNaYmRyN2hMVzdpNlpOZkVvVEp0WktoSjFpSUdQY2lBQjk5cUlnTjR1QkY2MS9mU0VoK2piSWsycnBuZ3VXejBpVE1TdXF4Tm8vXHJcbiAgNnZpNXo0dVpSQ1pvaUF5bEhvN1JxQ3V2TDBjSkp1dlF3bjZLRGt5TkNVRm4vbWtNNTZpWmNMbGxyZ2k4dldvNDZZUEsrVmtMdEo2ZFxyXG4gIEh5NnpWSGRTQlA3OWxKbkFpZHhjRmV1MTEzdW5ua2tnbEhVSnppUHhJYlBVVlhFU0NQdXJPS0xZcVBmWktnMzQ2c1p3Zk13TDdUSkRcclxuICBZbEs1bXRMaGpGY2x2V3haYlpGZ29jM3VTNTQxZDU0c2ZuMndHNjNqUGVPbHEzWHovOUFKc3NMU0IvODBaWWxiY3BaTjBVU0x6TFlZXHJcbiAgT2U3V3FZR0VSNGVZNVpnSEJNRC9idURXN2o4MkZGSnRNd0dXU2gvQmNVYVlxZlBlbDdHMzFwVkZDeGJxUGdOS0lTS2xZU1RrT0t2dlxyXG4gIENGRzE2aldsejhQcnBQYS9YcFhXUjk0bUhZNi96ekdtVDVXQTBTTEVESUlFOHlDckxpbmROeXllcE1jdEZUcHFxakR6WVA4WGw5YlVcclxuICAvUkRhK1ovZXVLR3dxS1FHekFJZ2RlQ0J0Yy9wVGxvTG9Ebk9Fb0diU0xUc0RoSzF3N0ticUZDN3VUSkFtQ0hTU0p1amJ0VU12VC9kXHJcbiAgaGdPRnlQR09pU3dhL1phTWZtZFl5LzZuM2I0NHpFUjRwZ3QvZmRXdCsyc3lSSjR2ODlXenYzNzM0eUxQblRUNjVOYXk2UFdDK2tPa1xyXG4gIDk5MHJwTnMxUDBtWGZYdEdDRVBocGsyeVljMWFtVE1uc0lXNS9nQVRJZVVKTVNHb3JUUTJ4TjBaZlhuV1YzZnFQdnY5dnZ1VWtYM0pcclxuICAxanZ6RjhtZCtxN3U3OVMrbVJzd1JnM2ZRMis3V05PU0E0aDFvdEU1eDN2MDZLQkVrK2xwOFhSS0JNNHZqY0dBMXEzOUNKMXJiTnFVXHJcbiAgRjduVzlqeWpxT09KZnBRQmdPMWRoN29NbUtscnFpc3dkdXdVWFlNd0F5Z05kbDRpRkcveGRpTWo4TFEzK2E5cFRqcE1rcllkZkt6SVxyXG4gIG5xQmlSWjhGZXU1Y0gvd2FqNTFpSUIyNitiRDJuVVBveTNGRlBMQUtDd3ZWQzJkZGJyNGV4ZldQZzJyL0NLQXV2WHFxNjRoQnNrSzJcclxuICB2ZjNEbHowb1FCQjkwWGZRWUovN3g2US9aTWxOVGVlSCt3cE1UcVB0dUUxVDcxUnZTN1JtMEE0SHRLd2JXcVlOMWlzbWZhRXV2SUJKXHJcbiAgZ1NENjJEKzB2dnRIQTV5blpiYzAzUGMwWVZJaFJ0TXdqK3dsa3lWbmllWHg4WFU4SEJPcTIwNFdqSHhlWjB3a1JtWGUrQytsV2ZOV1xyXG4gIFVxTnhPNDA0VFU4cks4V0ZtMlhXckRreStpNjM3KyszZFo3elpnZGNvWHBrYTRkN3dMT004dHp2SDlTWW1wbGZESldxemZIRnQrdVJcclxuICBRdVFBV1R0M2xESlNkTlJSMjRlUDkwRGlxTi90Qk1kOG5nNWw1aFdaOFdCYnFibjJXNWt6WTVhc1h1bnRVVWdjWnU5QThpaVRYRVk2XHJcbiAgZHU0Z2pRYmZKQjJHTFphTUxtY0w4MTBnV1RDL0JSbHo2M1UvUmhiLy9yYlU3WHEwbnBlM1pvRVNzTld1RHRQMEd2UEFtd29tQWZFTVxyXG4gIE13L1VWZ051R2k1dEhmT1krUHhKK1FXU1VSbnZKTE4xbU5SUlhKQ3JEaEQrdDRYZ2YrbzJ1Lzh4N09IMVlKS0E1MERnNG9GM2pKZnZcclxuICBybXVwVXRXaEQ4M1I1elR5eldFTkI1eDIrOG93RThGK0VXWW9FOSs2ekEwZUttbDl0Z0dNaGRRbVBGL0FleUNMYjVreUtWTC8vREVxXHJcbiAgbVRScjZ3Wk5WYXNxa2NoYnYxNitQamRKeGo4MFFKWi9kcTRzZUxhcmFoRmcwQ3IxdTk5WXQvTlJ5anlZMTkyWXkreHZIOUQyaS81NlxyXG4gIFVuS1hqSmVWaXhmSjU1ODhLa052djFUdXV1Y0ZQUVlnZ3RPbSs3Z3dRenh4SmNFaHFkc2gyaGpKVGZVVUQ0aDlJZ2FVQ0JNbStPbTFcclxuICAvYlcyeXVyVmxrUXlGdHdmc1UvVU00TE91clRNdk1EdVA4d1FtUjZYdVVHc2paM3RIT0cyd210N0JrU09nem16NXF2Yi9PS2xxM1I3XHJcbiAgVDJGcXNYbnp0NDIvQVR2RlFNTG9WbVBIcWEzdG1iREt6YzJWZ29JU1NXSnlnd0FXZkJTMmYrQlZSSDBNZDdnTDIyT3RWTDlqMEI1L1xyXG4gIElOWkJNZGpXZmJycC9ycUZFYnJxWGdQaXg4UTNsTzFmelRiN1M3NGpYSndYYVV4WHZnd3pLQ25ackV3TTExM20vTUNBRHJQRHhaSGdcclxuICBPMnBxL2FCZGZZeHV0Y0dOL0ZtWU41cEplblNuVzZDeldvLzZkcDViMWp2Sm8ybi9pNlRKZ0l1bEtna0hIV3FmOUw2ME8rc2RxVlV0XHJcbiAgMHpIZUlpbWI2bC9SSnNkOC8zSWowcFZmWGFUMmtCWUhYNlB0QVA1T2VlOHFMZU5iejV3UCsxNzJoUjNXYS8wOHJMTmpXRzNVbFhMaVxyXG4gIEcrZHJwTERlaTk2WHIwZGh5WmczVkZWbHRnK1orNWxzeUN1VXFWT254VEFNSkZLUWxKSXN6VnMyMDFRbWpCQko1a2Q3VkYzeUI1TU1cclxuICBlZUlFZ1lOWW9aNWgwaVRRcU8rWjdyYzhyZVZPSnorczBrWTg4emo0dnVtYXV0eVlSN1BPL1dmL2R2OGdxZDV4U0ViYm8yL1RrVGdUXHJcbiAgUUprVUFsTFN5eXZCVkFRL01mb2IvNGV3bS9jQkUyblM3eXlaOHE1UGdIbklRN1BsdC9zUFVvbWE1OEh6R3ZIbXNOb3dDOWxTa01jelxyXG4gIDQxbFdiOWxIL25qcWVHVWl6Q25QUE96TkQ3eEVzaHpqVUhzSXpJT0FRc2RRbWgxNHFUN3JmVTV6NzhKZHc2TFZVenFjS3h2WCtma21cclxuICBzR1lFcjErV09xa1lBL2lNbHc2VDVaK2VyUU0wNWcvaFhOVEZmNzkvbFpTcjJzaEpLdjFVOWJrMVAwdEd2bnFMYkMwb1VLTjloNjZkXHJcbiAgbEFDZWNmcVFHTlhJbkRsK2xNc2pnc0RlTnN6M2pYZ1lNZTdWcTFOQ2czbVVPSHZFWk5BSWdYdjRiWlRyV3lHaUhEWkFod0VCN3gwUVxyXG4gIFUyTWlSdFJMZzlVNTk1eGpJL2YwMGNjL3lDMDMrOVQwL3Z6RTkxWWE3TGZidW40OTh2aUpyRnUvUVNaTm1DcmovNW9oN1R1MTBUbmhcclxuICA5d1pzYnBDUnBVU2s3elFEdWZHRzgzUzljV00wS2VLMjJQYnJRQUtCVHBWUFQ1R2U3YjI2aWd5Y3dOcy8zRUZYd1NaOENuc080UTdvXHJcbiAgVy9Sa092ckhGaXY2TW5tdmpFQnpJTm1OanZDK1VyaDlwQXhuZjNyVityNGVKN3UxYnoxNkhnWjJNNTZUbzR1NU1pZ3p4elIxVUY5UlxyXG4gIFV4R2N5cDh5WlZDWEpFbnQ5b01qazBWbE50ckhCd1hhOVJSVzlreEVpMDdrMU1tYnVKL2tOR2wzK3N2U29VMUxEYmpqSmFteHM2aFlcclxuICA1azRhTGttTFBwT1NsWUd0eDlXZjg3MVAwWTR2UDVIeExRKzkwVzM3cVVzNVRyUjU1MU9lMW95cnBHc244V0tydy9HMDRzSWkzLzI3XHJcbiAga2JRNkZGdUlPTWxsbURRTGNtOFZqWDljUnI5MHZteGFzMElLSEZQRlFHNkFtVFJ1MUZpbG1DMnRUNUd1VHVwSVAra1hkZkVFU0F3UVxyXG4gIHFaYUhYS1BFQlpVS0V3bk4vT3ErNEtwZWpWV3BmbnRKWllJb3h6QjRWb0J6T1liQm5EbklVZDNBVkZydTAzLzIxM2NjM0xMMWtKdWxcclxuICBRYStUVk1XemFkVzh5RWlkT0FRRlA0U0wySVgrMjJEM3RwUDNWNjU2UStsNDBnTk9xdkE1am5CUEh2V1FUeE1ERThIdU1lK25aNlQvXHJcbiAgclgrVW0vSDVYVnQ1ZHUyT3ZWTTl6bml1ZUdibExKK3V6N1RGNEd2MXN1YTh3TWI4bjU3UzhzTGZYcEVOVG1LdWllSGN2UVA2N2VFUFxyXG4gIHpaTEdyVnBKaGN4TVBhL0V2WGZzSklVYmNtVE5zdVd5ZU01Y1dmenhXVExuN1ZPa2VQa1kxODVBbFR6OERJL3VXNm5mUWFZODZiL0JcclxuICB6ejUrUkZLU2szV3U4V3JWcXNnK25kdklvNDh4MFBKNDZJRnJZbFE5ZUZ1Rll5a01ScGhYcmNxU1JvM3FCSHRqc1puSit4Mm9aK2svXHJcbiAgNGdFUmhwaGZkdWtwMnFZUjVkTHd3WWZmUmU2TmR1MCtQQ05JRE9xWStvZDZTQ3dtTlhqR3RYT2RvTFJyWUQ4Q1N4WXVreTN1TjU5MFxyXG4gIGtzOU5sbGJXUjludktUeWQ5SkpUSXV3MEF5SDdLdmhyVmx4RDIvMzlTYkpod3diVmpaY2tKVWRtVmZQNXI2SVNDR29oQTBacTN5Yk1cclxuICB4S2N5VWVnUENWM01GU05Nd0MzOFEyMWt3RTA0UGJPZTkydDM5WHlBMVA1YXhwQUhZcGdJeGFBTXZCck5yWjBVd2x3WkdCM3JkVHMrXHJcbiAgeG5pdTV3WC8yQWRqd1hVWHd6bXFxMFcvdjZiQldON2wxZGZ5NjJnSk1LOEhicnZlWThxQnRtdDBrQnFuZlNOTnVoeW9icjZNVTRxM1xyXG4gIGJKVk5tL0oxVXFKRjM1RERpamFjMU5McGNLblY4VkNwVUxPNXV3ZWZHeWY0R1hwODlyZjNhcGxVSTlnOS9HeVB3S3V1R3ZjN1QzMzFcclxuICA4YlRpT3ZqcVo3MjZuL3o2MXMyeWZ2MTYyWkpTb3BsbE1aQWpmVFJwMUV4YURMbE5GcXhjRTBtZXFNRmo3aGh6WStldW5pODlMM3BIXHJcbiAgOTgvKy9oR3A3cGpIb3RGTW05cFhKYzBtQXk3d0krTktOWFVFM1dMUTVWcDMvYUtKeWlpUU5sVDkwcWEvRU5OQmVkK1RicC85MDFQblxyXG4gIHRvUnhtTEVjR1BNQTZWWGNhTXgrK1A4V2NMczdlY3Y5Yi94SkpyOURUalBQUkg3RjBPNkFUV1RpRzVlNFp6bFNqbjF0Y3hJTUJRYlFcclxuICBZdEFWa3IxNGtwYTduZnVLa0RFWEYzZlFQRWkzcjZvczkzd0JEaWRGdWV0MS9nNmNUV0Q2Q3laOEo4bHRUcEg5SDFvbmJmZlpSNnJYXHJcbiAgcXlzbGFUaTVPSUVubWVTaElpc1hMcEtzbFN0bHp2dm55YW8zZkdBbTEwR050ZjduMjJURndnVnkyZFZueXlGRERwTFhYNzFiWG4zdFxyXG4gIFUxbVhsUzN0NHFhSTdkaXhsWHo2K2M4UndveGQ1S1piSGcrT3hnTGlXOCtOdm1mTzlFSEk4VGp3Z0Y2NnBoNVR5NVpHZ0luTkNIczFcclxuICBsWmFqaW1PMW5IUkNPNVR0SGxsdkQzZUUzSGFaRnBjMTk4MGFacktyaHZUd2RWblhybDFkWG4zNUk2bFFzWngwN1JtbGYrWExwd2VsXHJcbiAgUFlQbHhGcTNQbkU2azUxbUlBZjA5Nk5EZysvejhUMC90QjBVQzV6WVN0Nm56RXJsWk55YWFqcFhOUWZWa0c3em9jTkl0SDZTcEtaWFxyXG4gIGRuL2RodnRmRk5ndFlxZ2hSRnUzUTB1d243bXIyU0NRMEpnU2llQjBHazYzZisyc1g5eGY3QjhIYVgwUXc0UjBsN3VIY3BrNlBTdkJcclxuICBneHRYa0R5UnRCUUh5cklKSDhVWXovMTkraVV2YTZGakhJalRqcEU1Sm9MOW8zR2ZzNlJSMzNOMFZFWlZxMHNaZi9uTUp0MTFJZDhWXHJcbiAgOEdvc2JWWFgxRjJidlVuVHB6TTFnTzZId2p1c1c1c2x5MTUzdjhQdExjck5sc3IxMnN1UzM5OVFuZk1jMVR2NzgxbmpJUVB4UnAySFxyXG4gIDdZTzVQUlR1c0JsQUNSd2taVW0zODk2V05hLzBkS09tdVpwdGx3U0dQQ1ByS0owN09tbXE0eWs2VnpuU0Jlb09VTGZMRURYS3RuUWpcclxuICAzQW8xbThyWFZ6TDlyaDdTa1cvajNxY3JzUUxvOC9FcVdqYkJHOVhYVFA5Rjl4dnpZTTN5eDFQLzB1TXdpYkh2RG10SmRvSEcvYzdjXHJcbiAgaG5tVWxMalJwbDRydU9BdXdqK2x2YlBzTm5heWdVNG5QeVRqWDJZcUFKRitqb21NZnRUUEN6N2dSdUpDdkxxaGYxQ0cwV2E2ZmpqdFxyXG4gIDQxdVZHYUFhbnZmVDAvcE1TUlUwNzhjbnZDckx2UitrYzhyY0FtN25sSmxYdlpMcnkyMkczS3F1dklVTmpwUm1wN3dqelpzMWsweXlcclxuICBMNWROa3hJMzBrVzlSZitZTjJPbVRKdzRVYkxHUFM5elByNUJ4ajF5a0N5YU8xdktaMWFXaG5XOGdmeGtOMEltNldIVDBHeUFFRUxEXHJcbiAgclRkZnFOc1Fmb2lreFRhRThjMjN2MGFrQlQrS2p3VlNqTFZKUFpaRTlaWXNYYW14R2RSbHdpclcvZnA1VDZkNGxKU1U2UDBZNFFaaFxyXG4gIFlsNGF3c2RJa1I0K3g5cEpkTDN0WVhWb2V0N3hZOGo0a0NMTm12dTRGdHBGWlJkMlU5NVRZUHZCU3k0UmRwcUI5T2puRXlEdUVERWZcclxuICBBVmxVaTdXRGxjL3dISkVKOTZsajdydSt2RmJMdVBMNk9iVkJrcFN0NU9mcDhFMEdCRHZZTWlpTkRQWlZxTkZVNS8xZ3UxTGQ5c0s4XHJcbiAgSDBEVHVidUtHSkdabVM4c2VYaFkyVjNCcmRJcjE5TE1zMHlzaEdlSkQwWVVxZGY5ZUZrMjdnTnErZnB1OGFRMVNZT3JLamZvNkVaZVxyXG4gIGY2b0VzblQ4aHpxM0JjWmhEOSsrQi9YcjZTak5MMytxMm1pZFcxdTd2bGFTZEQvL1hXbHorUmlwVktXcVpHU1UxUkVmS2N5enM3TmxcclxuICB3WUlGTXZiT2xyTGk4eUJxdlV5eUkrRFhhODRoZjc3SXFxbmZhZzR3Y2hDUlVtS08rdU1EVXQzL0tYMnUvbEhhYUpxU0pJMWEzekxtXHJcbiAgYnBrMmRicXNYcnRPSjBjaXpRZ2VWdURBL2ZlWHVwZTdUdWthbnZieHpSSHBJd3l1Q1VGcWM5UnRidTNuSlFmc002QldTVW9yNzRqaFxyXG4gIG8xcGVPK3MzWlJqVElHU09hRUhnc0lFVTVheFJKakgvczVzM3dUY3hubThqZWVqUFJzSEhsWGNPMUF3dmV4TjczUFpPbk5UdG5CZmtcclxuICAxL3NIYWJuMzFaK3JKQUt6YUh2MFVNMHlIQzdqWkZDdHhYNzZuUHRlOTUwT2NpaFhiek5BT3B6d2dESjkxRmZLU054Z3dFLzQ1ZnFYXHJcbiAga3dhUlFwaVlhdlozRDJtWll6aEZiRzMyTCtsNTVYQnAxc2FOZUF1THBFeDZtaFM1KzFaaWtwOHZHMWV2OWtHbGJpSHAvTUVIN1NkWlxyXG4gIEd5ekxoSWNGMnNVVDk4R0g5SkdoamdFWWcramVyVjFrUWliRHVIRSszOWFNR2ZNajljS3dOazExQkZGTlpPdys5WlFqbE1oUzk5NzdcclxuICBYdFI5ZDl6NWJBelJONWczRlpIdUhJZEovVEtjR0pqdE13QnJpMnN3alRLdzg2UFgyZkZMcDY1ZFovcDBCdUVpbjN6eWd3WlF6bHV3XHJcbiAgWEkrUEdlTXpudThvZys2dWdweGV3YmgxRyt3MEE5a3hZaDhDVy92V3puWVNTSkdtMllhRGgrc2dMdnR0Z2dsOS9BZHpmdmdxNUhQYVxyXG4gIEpPbVZhck9oMjM2L0FVTFBQbjgrUzBIT0twMHJIV1lCMWk4WVN5MnRnODk2YmhCMURoRUZZU2FpeGFDTXhMRUpyeXUzU1puWUQ4ckxcclxuICBKMzdpVmttT2laemdxM0tLZ2JxclpzcVNQOTVVOTFwQVRxQkdmYzZScWsyNnV1TjJ2eFRKdXZ1Q0ptaEUrdkRYRHVadXh6Vlh6M2F2XHJcbiAgeFIwZ1NHdlYxTzgwN3FQcjlaT2szV212NnNza2xoTjd5S2FOdWJKKy9RYTMzaWlMbjk5UG1nOWtMaEZhMEF2cEdvTStEQW9KaENTSlxyXG4gIExjM3p5djNINVJrVkg2cXJwYzkxa1RXakg1ZVpNMmRLMGRaaUtaTlNScWRWVFhmaUl4TW85YnBocEdTYzhxTlBaK0hRY3ZCMUVlbERcclxuICBaN3R6aE1pWXhZelBQZVBBelJqR1Fjd0hXUDMzOThvY3dKYkNYS2xTMzBsekR0bzUzZjFBMkE2NmE1S3FZaWdUZ1YwNDk2ZDFoU1ZsXHJcbiAgSzhBODJBK1VlZmlmRnlCU0tCVldmY2MxOXk1MjY3bzdjUUxNd0pocG0yT0dhc0FoVEJqdzdGU3ljOFNlWjFhNzQyRE5Nd2R6N25MbVxyXG4gIGN5cFpJNUZNZU1YblU0TkpUSHo5WW5Xbmh2bkFVTWlxeTN0RjhzaDBrckVORm1BaXpRZGRKZXV6VmttcmkzK1hicWZlTHkxN0hDNzFcclxuICBHelNRSk1kSUNoMmhMWEI5endnTDhrbXpabjZxQmdPcUtVT1VpSHBBRVArYU9DTkNNS2xyVTdjYWpFRzBDUUxtNGdrNDUxTG43WGUrXHJcbiAgaW1GT3BRSG1jdE9ONStsNWxMZW54aUxTSGVKLzNybkhTYkw3cmV4ajJSNjR2NHN1UENGU2ovT05vZmw3TDQwOEo4Wld4NGllZStrelxyXG4gIHlYVFNVOXVPclNOTUZLY2JnTllBek4vQmRMUTdpNjVCeXZoRTB3cnZNZ09wVmJGY1VOb1JrdFI5MS8zWHlGYnpoTkRjVFE2a0t6ZVlcclxuICA0VHk1TEcyN3l1Ni9waHRSK0czL0owcUlvL0FNZ0FTS2xMMUxJZDVZekEzdWoyc0tCcmVQelRMSlpiWE0vZ2dUMGJKYnVUVWVWM1ljXHJcbiAgKzBkZDNGbGRtWmtIYzFaTWp4eGo4ZmRDdTBrYWVVN1dYYVFQRFNRYy9hcHNXREpSZGRDK1B2RG5OZWwvZ1NQcUU5d0hQVnlsQXpMN1xyXG4gIEJvZnNqL3ZyMTdVNkRGYm10Mm4xUE1ka0praXZ5NzZRNXEyY1pGVEJ2d2VlYWw3dUpwazVlNDc4TnJTTnpIblNNekFEMHBSM0pIRFBcclxuICB3VEdSYU1yMkpQbnV1Z1pTdm1aVHlWejdyVXliUGxQMW5FV2JTeHl6MytyZVdSbXBXNmVtTkduYVZCcWYrcTZtb1BCMzVHRUVwY0crXHJcbiAgSit2YXdDZ1c2V1BqaXRtdXpxMTZEa3lrN2o1SHlJRGJmcGQ1UDVORjJLdXJDamQ2WXlJTXdXd2RWUnAyaktpeGFsU1F4VjhPRzFTVlxyXG4gIFVUU1krOU16MHU1WXp6enkxM2xqL1k3Z2YrbC9CM2I1WHJaekFva2VpWG1aK2VWOVN2U3BCb013b3pwem1vZFZXVXdUemJ6cE1JNjhcclxuICByQ1V5NmUycjFMZ08vdjd3UmsxUWlhMHFMQ2t1Ry8rSk1pRVl6TUpmWDFZcGhHWHVENCtxSk1KRjErWGtTM0dWRHRMOTFrVlNvMFpOXHJcbiAgcVZLNXNxU25wNHVUU3lMRTVlSDducGNWeTFkRkNEMkVGTUllSnZ6aDhzQUI3bnR3c0gzYll3S1RweVRPRk1zMUlLd1FhbVlBUkxJSVxyXG4gIFh5TU1JdGVaTmJDMDR3YU8weDd0MXExYk04SVEyTCs5YzZtSHRBU3NqZGo2Tzk4ckpvNy9XN0p5Q3FSSHA2WXlNQzd4cE1Fa2tCMU5cclxuICBSN3V6TU5vOU0wRktrMTFtSUxqbFJyQ0QzNDNZaC8wRHZVdlp3Q3ZBNWoyUE1hQUg3V3dweW9zMG1ZYjZpZzNkRVJCNE94Z2NVQ0liXHJcbiAgSEsvV3pEMU1WeWJKVzc3N1FPeUUvTFVMdGV3Sk1ubTFtSkNHOC9SRWo2QXVxMnhIOUdFeWVGOXRXaDExR01EK29YWHMzT0FjVzJBY1xyXG4gIDdNT0lUbndIZ1lPVkczWnhCTEdMMXFDT3Z3ZDNEY2M4R05XUlVnVVZWbllnZldoYjJweXZCemluUWMrVFplWGtMNVFwSmxkdkw4MHZcclxuICBHQzUxNnRUUmFyeEFSaHdhd1o2Yko4a1YzUDRWdit0NXBIRFJLSHlITFpzTFpNNjM5MnVML0NjeElxNjZVNS9zTFpNbi95MzVoWnVsXHJcbiAgZkhxcXBKVlBkZS9OTWMrS0ZhVjh0d3VscVBrSlVseTRrVk1pMGdmTVk4SElGM1dFV3FGMkM1bjk3WU5lK25DVlpnUnFLMko5SUVZbVxyXG4gIGxWUnA3R2UxUkNVSVpuLzNxT3JqWVI2b3E0Q3FzWUxSTTBielg5OGMxdkRBdTd3S2tDbGNlMTN1NSsyR2VXUlVyYWRsdldnQ3NEZnhcclxuICBrZjk1N1BLOWxWSVp4c0M4TSt2bS9TbXQzWE9jOGNsUXJZczk1SThuajNNTXhrc1Q0NTgrTnFmTDJjL0xzajgvVUNiVC9yaTdkQ1pDXHJcbiAgeWpDSUNyV2FLNU9ZOHU0MUVTbUVTK0lkeDNaUmZyWTZhQkJBQ0pCQ1ROVkZxaFBkN3pwamhjNW5TNU1oRDBxblRwMGtzMnBWMTBCWlxyXG4gIFZXT0JWMS8rUkI1NjRBWEoyNUFkN0lreUJwTW9ERmRkY1pvUzJCdWRWTUIrRzJHSGdmb0pYSDdacVVxZzR3azQyNWJTSGMrdjB1WUxcclxuICBKNnFieUhJN2Y5VXFCaldsU3dUVTIxbkdZVEJEdWlIY0J0UHdoajczN2VKZEoxR0I0NDRhSUYyNmQ5UnlHT0hudVRmUkw0aW1YNS9BXHJcbiAga0w0YkRLUTQ2TS94djlwdDI2NWdqUUdkS1VhTGsxTWxLYU5heEgyWENrd21RejNQU0RpWGsreDJrbVJyS0J1dkJ5VmJ3a1ZmUUovUFxyXG4gIFdxV1pvRXE1YW8xZDJiZEJWQzdsekNZOWdoZm16L05TQ0VXL0RjRXZLU255a2tnd1RTY013ZWY0MFNwNnBpLzZEV0kvMkxmNDk5Y2RcclxuICBBNXFzQzFscm1STkVEOUMyTHI1TTVQbUNrYzlxOEtEZjU0aGk5bkszWW9QTXUyNWt0MkNzTWd4eVgyM09DNkwwOVI3OUtjMHYvbDJhXHJcbiAgTm0yaU5oRzBnenc1dXYyQ3YzK1RxZTllS3NYTGZ0ZG9jNllTNWQ3SFBIV1V6NE9sOERQS1pTNStXK2NVWjdwWCtIeCtnUk5SblFTU1xyXG4gIFdhbWF0RHJybzRpVUFjUGpvazMzdjBROXZsQmROUmx3WGlUWFVlMzJCMnZnSGd6RGJCL1ZtdmZTKzFRbTRoaUNBY01zak1MblF2UDdcclxuICBVTDkwT3VtaGlPcUs0Mys4TzZ3bHY2ZEtvODZxcXVuNzcyOTlaWWZ0TVEvMmJMdjN2eE83ZEsrbFZJUUJMLzdkZTd4MVBmOVYrZlA1XHJcbiAgTTNYT0U4QitKSktGWXorcGhEcTI3YkYzUmd6cUJNcmlBWWNVUXRicXZ6KzR3VW1KUTFRS2diRnNkZGREQmNrN21QdkQ0eEdtd3Z2blxyXG4gIGZJQjZpM0sxWnZ0cG1RcElOM1hPL0UzNjM3ZFMyclh6S2twQVAvM3VoekhTZWI4ejVZZXZmbzZvc2VLSksyRDdsZGMrVmRVVnhKRHRcclxuICBNS0ZtMjlRMVJzVGoyd0NmZi9GTDVEeU9KNnFUbmw1V2Z2anhkejNXczJkSHFWV3J1cFpMeTR2RmdpM0Ryc215STF4enpabTY1aHlJXHJcbiAgdkozRDluSEhEa3FZWFRpTWNYOU1sTWVmZmwrYU5hMHYrM1Ryb09lSGY3T3Q0eG5IM21Ja2VHS0J2QVE1eG5hWmdXek5TSlY5cXNlbVxyXG4gIE5FbmN1NU9VZ2VBOWxPSkdJcmxKcEREeHFjZDlCRHJuK0lXL2lFa1Y2NUMzeGJlbEJFYmh0Z1BDcWRCTnR2MWlSSncwNlVSMFU1ZlpcclxuICBCL096RnV2KzlDb1FHOGM0bXZhUXZEV0lZSFl1SzE4MkprTEVPZVdLdGR1bzRaelJNckVmSkRoTXI0dzl4czROem5FTC8xQmZzWS9ZXHJcbiAgRHpMdVZuUWpPdXdmR3MwZDFQZElVdFVWYzM0UVBHajdBUGZ2cS9yNkpLUGJ0SEtPTXBHYzVkT2t4YUNySFZIZUwzS2NaWjNVa2NaTlxyXG4gIG0wcWxpdVYxcE9kYndpZDh2dno1N0hHU3RuRzJ6dk9CblFNbW9yRWZlcjRicmZ5N3Vvd2ZQOTVKTHlXYUpRQldVSzFxcGxTcFdrMTZcclxuICAzTEZVMXMzOVBTSnh0QTBZU1VwYWVTYzVkWTJNUkVuR1NHczREekFGTG9GakpuSEVNdzVGa0FrWEtZUGI0RGhsR0ViTHdWZkhxSzVVXHJcbiAgaisrSTQ2cS9mOVFmbHRta3F4U3NENHZrOW1zOTJJcmQ4NzhITzMzdnBWVHFmTnBqeW1TWmw3MWl6YWJLaUFtc0hQdmNLWG9jZy9xa1xyXG4gIFY4NHFhTER2Q1RwUWdVR3dMemRyVVVRS3diVWJab0F0YThablE2WEZ3VmZyZnJJemE3eUlBNTVhOUFHQUNrdlZXQTRrRjBXMUZiMUJcclxuICAvMzAwdVhpY3REemlWbW5Xcm9OVXF1bVovcUxaOCtUSVk2NlVyNzhkclFUZWlLRk56V3BBL1dMRUZxTTVodlV3MXF4WnA3WUVtMXFaXHJcbiAgNk80d09BOVYwYSsvVFZDN0N0ZWdmanhvbTNvUFBQaUtwaGloRG5WTGswSTRObXJVWDlvK2RSTzFHWS94NDMyME8rQmFnSGFRZm1JalxyXG4gIDRiZkZ4UEZUWlB6VUJiTHZQczJseDc3YkJnZmFlYVdkdnpkUXVaSVB2MGdVdExsTERDUTMyNnNUUnY2Mi9adTFib1FOQk1LMmRVdWhcclxuICA1Rzh0cHlLeG9rejBza1diZks3NnZOWHpoT3llZHJKR29JZS9HTmNobzR6RDRNcTZtYVRlV3hqUlFUajZmTjI4MGU1RElYY1RFZVpJXHJcbiAgRk5Td3RyU29mL2pIZnd5TVZrYUNxTlh1RUZrKzhXT3RpcXNzN2VwQ2hXQmgzbWYyTFhJU3lPb1pQNm05WXRHb1YyVEoySGUxQm4rTVxyXG4gIDRWUnQwczFKSDgvSmdoSFBoQ0x1OVlxNnRoVkJrWnZ6MXJuN0g2T0pFeWUrU2ZScVVDK28xdXV5ejZYYW9ZOUtoNk51a2pxMWEwcHlcclxuICBhcklVRm0vVjNGUlpHemJKaWxXckpYZkJiMUswYXBMTStkclBQODdKQzU3dUtobnVvOXJrSkE3VVhvQ011UzFidHBUdXR5OXlqT01PXHJcbiAgcWRxaXQ0NHNsWG00NnlGMXpQM3BDVjFETENBMFRDZkxHcnNISUNPc2VWNXhpekNCRkoxYTE0bS84OGU1ZW5jcGcrQ2dmWjdVSVE0QlxyXG4gIFJsSzJYR1ZWWGYxR2VvNWIvSWoyMXdjT2puaGNwV2R1R3pUR2RWajJDcXl4M1ZuMkFuYXFxVklxbFVsSmxiV3pmM2ZQOGpaWk90NUpcclxuICB2ZzR3aVhFdm5LWFBmTldzUDlKelpuNjNwTnM1TDh1VTk2NVZaa0VxR1NheEluc3ZtUUtRSXJEZjlidGh1T2JQZ21FME8rQXlOL2pvXHJcbiAgbzR3R1JrSjJCc3BoTlZabTR5NlNVclpjUkpXMU5vaXpzcHRkVlpRcDlldlhrMmF0MitsQUJUejV5TXN5YWNwc3gwaEd5ZXV2ZjZxRFxyXG4gIG9EQVJSRUpoQkEyQkptMkpCUWJHdzZMRE05SjlQd3NESm5UckxSZHFIQWhJTkNJM0J0YXpCeG0vUFlHdm9QYkZ4RytDK29EN29pNExcclxuICBETXIySjRJZGd5SGFiK3phdFowOCtkVGJvZk5pcnpmdWo3L2swU2ZmZFdPdUVybm92R09rNTM1ZFk2NWg2cXBFc0hxc0UwMEJ2S3NnXHJcbiAgdngxWWxNQ21zc3NTeU03QlA0eWNuQndiZERva3laWkNUNnhJNm1jb0d4alFTYUJvajlEeVZ2bkZpR3NZYnA4U1pGOVdBM3BRNWwrNVxyXG4gIG1zMVVDbUc3Y3FPdTdqaUpFd2tPSklDUjg2Z2N0TUUyY0dVTkh0U3lZMkIxMnFyaFBHLzlFcW5mN1Y4YXlhdW4raHArelIrM0VQZkJcclxuICAwc2lKNXpVMXhvUjVNODcxQnVid05SeE1BaUgyZzBoZlBLU3FZa1FQNnZoZjZ4YjNuelQyMklLWWdwYmdQbC9GSDUvei9ZT09rUC9xXHJcbiAgcEpJK3NueDFqbU1JNWQxSFd0OTE1blQzd2gxamN0V3dmWTE0ZUxETSsvNCtxVk92cmhRdi9sbFdmMzZlTEZ1MlZGWTc1cUxxTDFlblxyXG4gIFJ2V3EwckZqUjZseHptaU5WRWVOQVloc1h6YkJFeVBBSkYvWVBReDZPdzdvNEdFYStldVg2YjZ3OUxIOHJ5OTBqWDBMNEtwTEhZaWFcclxuICAyVHNBakdUSU0xbVNVeWlxdXFyUnVxK09xZ2ZkbDJodUIzOWx1LzV1Z3diQ3k1NWdMN2ExVTZmSFZXb3o1Q1kxa29QNjNZNVJLUVRHXHJcbiAgdTNDVWo4TEdMakx4ay9zYm9JcENuV1ZTQ0k0TVpBQkFuYlZvOUp2Uyt2QWJWYzJJZEVHbTVJcTFtOHZLdjc5WGFRU213M25xMHV1a1xyXG4gIFRhQ3FLNGVhN1loSm9zKzIxK001eTZacEg5VEVpZzU1ZFE2V3VzZTlKczFkUDI3ZDJSTzRKTmRCSDNyMGRmbDF6RFI1N3FWUDVLcHJcclxuICB5TjdyZ2YwVUlnblJ2K3Z1NStYdU8zeXdhUmdRYndneWhISm1NQzk2R0FzV0xJMUlDTlNoVFZOOXhXTy8vYUl4R2hEMzBpUVFEUEpnXHJcbiAgMEVIN2FWMFdtN3dLeWFRMFVJL2ZZc1FkeWNNWUdzZkNER0hrejZQbGpJdnZsNDBiODJLQ0F3RjFTNE8xRGF6ZWtpWFlmUGNNSkxDa1xyXG4gIHUvRTg0N0g3REdRbmVqbFR1TnByWUNZNm9wQTVjWE91VjRFeEY3ZTNXWVFiUzVLaUhGSlNlRktxaUJEaFlFLzBnUCtybG5veStucTlcclxuICBlcmtxOVgyQW5DdVhkY3pLZDJJbktheVk0WnBLMEVhd0QwTTF0ZzhMSHZRSURPUzZJMWlvbitSbkNjU3Yzcy9HUnZ2VGRSOTJGQTg3XHJcbiAgQjNERS9VdE8xYXl6Uko2emFQekhBdmV5dFdyMGRaQTBrVlF1aFJ0WHFScUx6TUtjYjZqWmRwRDdpUHZyZEwydERyMWUybDQ1VWRwZVxyXG4gIFBVVzZIbitYZXNIQVBIam0zTmU2ZGRteWFzVnlHZlA4cVRMemo4OGt5MjNET0ZKU2t0VVZNU09qdkZRNWZZU21uY2ZPQVNBQ1hLMmVcclxuICBJMFlBZXdnTEVnZE1CSWF4YU5UcktqMzB1ZVpyR1huZi9wSmV1YTRlSXowSkRJRlJiYzBPQjJ1WmZGVXFmVGpZcjJCL21KSFVyRlJtXHJcbiAgOFpUM3JwYzJlRm9GcUZ5L25heVorbk93QmZ6WjBTZXhpK0JFVy81SjdPRjFkdXEwdUVwNFpjRTRZQkxUTWFnN3RITk1ZdUtibCtzK1xyXG4gIG1FRFpqWE9YRSt5cFU5a3FNNWtoZjcxNmdiNnJjazZLaHlGNFpzRWNMZjJsSUdlMWxLL2VTTGNCVWdtR2M3NGorb2lwc1RES1o3bHRcclxuICAxTGE0NkM4ajdZOERVa210RG9kcVh5VXhhWFUzNEdsMHdTZzU0T0xuUlJQL3VCSG1rbVZyNUwzM3Y1T0ZpMWZMYjhQOTdIZWtMaDhkXHJcbiAgdU8rZWVzcmhPbzlRbUhoQ0xOLy80RHN0cy8rMFUzMU1SeGpVZ2NrWVl5Q1V3R0lsd3VBNDloYmlLOHp3SGliR1lXQ1FCN2kwVXNmcVxyXG4gIDBiN0ZlU1JDK0ZYRjN5Y2dFL0R2di80cDl6N3dpaHg2N0dWeStxbUh5WkdISlBheUNzTVlqNjBUdGIybjRObVhobDFtSU5kY2VvYXVcclxuICAwMVBDSE5vOUhudEN3YnBLV3JFVWhHd3VCU1VwYmpUdDR6cDg1SG1TRkc1WTZhcUhINjB2K3dCQ0VEN21FWlVhZ2pQZE5ucFp5dVRkXHJcbiAgeWNQMjRZQUU0aVdUcE1pMHRNbUJPb1Y5YkxOb2tiSXJWSEhTeXFxL3Y5Vk4wcGx6QlZLREpLV2tTR1VpMExVcWU2UG5LOXdLQXpxSlxyXG4gIDQ3S1hURkwxVmZiaWlmNm8rNlAzcklzYjE3Z1BadXZXWXBWQW1qbGlUZWJiYXVUQWlyU0ZLL0pZTlo2WHJVRDBicExhUHZ4c2hycXBcclxuICBmMlo4TVZRbGhISlZHenVwNFg3SC9KaUgya2xjM2MrWFZxMWFhVHA0Si8yNmUvTHZpWEsrWTlqNStmbXVReVFGQVlsYm5MaGVVYnJlXHJcbiAgNWtkdlJPRFBILzYwSXd4K1ZHblNCbW9yUnA0ckpuL2xlRnl5TWhIUVlMOVRuSFQwaEI2RDJKQXFnL3RMcjFoZGlaQWxSalNRWG9iYlxyXG4gIE41VlYrK0NZTVpLNXM2WTFURTd6N3NsSUg2YTZxdEdlZVNZOE9GOGZ3YTVpdDAvMDJMUjZ2c3orN3ZFZEx0VGJCcnQ1N1owNkxWUUJcclxuICBockRzcjgrMTNQYVlvY3BNc0NQTi9mRkp2ODh4a3grZlBLOHVTU2hKTjhOeEJnZ3Jwdmg1MFhsbnVBRERURXphWUY4bHg4Unhldkh2XHJcbiAgMlh0cFVZWTVtQnFyalB1MnJFeWlUejl4bC8rK21NZGZqd2NESGdaM0tSM09rRU9lOWFxbHJYa2JwVUtsU3JKK3d5WTU2Nko3NU44M1xyXG4gIFBxYWpjQXNnWExSb3VmYlYrTGdHY3l0bG1sbWJrVEFNaUNrU2lCRlZpTDNsamdyRGptTlg2ZENoaFc3dmlCQ0hHUWRMYVVrWURXRnFcclxuICBDZUlaMVBnL0o4bHQ5NzRpZDkzemxKb0ticmptZE9uVUplcUVZTENzdXhZRFkxSk12SG91YTUxUGVyc3BVRkh2S2JqL05YSFRlWURkXHJcbiAgbGtEcWw3UEdFblZ4SncyVUpFbGFqY2FTbEJadzdOeDFrU2owU01KRWVsY0NlQUlkUU92UUVkMDZ2bnB3UGw0a01XMjVNbk0xKy9vd1xyXG4gIER0ZTVYRm5uY1hiSEl1M3JPYjZUQXhJNk1pTWVVa2pGT20wamFkdUphbDg2N29PZ2ZnQi9xcnJ0TW5rTzZxc3FEUnlSZC91WTluWGJcclxuICBCSXBFaFg4dm1lNWpJdmFET1VxVy9QbXUxTzl4Z2p2aTY5aDlZVUJINmlqYTVGTVdaTTM3SXhvalF5MjNhbmZNUGE0ZWtza2lqZEdvXHJcbiAgM2RsUDlrOGJHMm9jTEZXclZ0WFJGS004M29DWm5Rb0tON3VQY2F1a3BLWkk5V3JWcGRaK1BqTW9pRENPSWQ2R1lZR0NsUjN6WXJUSlxyXG4gIHlESThKZXlzTCsrV3llOWNwY1RHSm9aU3ljTnRrOUtlRVRIYnBEYUJHY3o2K2dGM2cvNUc4THhxMU85c1pTUVZhN2VVNnVWbFB2cDRcclxuICBZeHFKRUhsdnV3TC95SFlMeGpTbWZuS1QvSHhYZDVuMDVwVTdYRVk5TnFoMFpyS2I5N0xEVTBJVjZuVTVNaUtGTFBuRHo3MkJLKzRTXHJcbiAgbnExajBpcGRWSkRGVzR1TE5MRWxraDh4SWpBRWE4YVlCOUtGU1I0K0VER3F4bUs2Qk1wQXZiRWNjd0RXaDBpTlkrcXRMTWN3cG45eVxyXG4gIGkyb0NzT2V0bmMxKy96Q3dpUXgrSms4YTFxc3JkV3ZYbGhVcjE4cURENzBxNTF4OGoyTWdXeVJybFo4K0FHRFRDTU9JSnFvVmlMaEpcclxuICBMQWFJTkJLSWxhbGprMGVGRVNibVppQUgyL1BFQ29OWiswaTBPR2x5NHBnVXdMWEQ1OWsyRXRlOUQ3NHFDNWV2ay91R1hoQ3hNNWNHXHJcbiAgODRoS1MvTmhFZmFiSndSSkovR29CTldDL0Y2VEp5ZE9RYktyNEcxTkN5TGd3OWhsQnRLL2w5ZjMvVFZtK3h5NmNTWEgrWElXYWt4QlxyXG4gIHEvcTFaWE9lWXpqdUx0U2ROb0JOTHdwaFNLdG9jUjlPTWdsVVdNSC9FTFNDL2pOaVRwbjVEMHpGUTlKRW14dURlUzhBQkV4VHVFY1lcclxuICBnS3NaS3JQb25CK3VxS25iVjh6VU1wSUxPWU1vUTlEMXVpenVYQ3VqdmlvcGRwTEgwa211N0Y4bXdZT2tndEM2Q2wrM1Z2dERaT0hJXHJcbiAgNTRQRWlUNzdicTdHcVhBNFduZmM4eWVxOGJ4cTgxNmFGbnZadVBkOVMwRVZSbkhNUWMzRVV1d3E0dGs2V0JNWlR2cnFjUFo3VXI5dVxyXG4gIFhkMW1kK0J4cTVJSDJ6V3FWNWN0bWUzVWRoT0JPd0R6NE1QUGJOWXo0c2FMemNwR2wwZ2w2cUhqNmxBKzlyVXRhdk5ZTVBJbEpVYTBcclxuICBEZFBZVXJCSkNReWoyZFV6Zk1EYWx1SkNsVUpnR294b3lsVnJvSFdaYVc5dG5qUzFkeEtXUGd6K3lDNkFFM2I1SkE5akhML2MxVU9aXHJcbiAgd3ZTUDc1WENyR2orb2UwaFo5RzhDRE9aOE5wWmU0MlI3R3gxR0FmcVFrRGlTWmdKaVJmSjFrc2pNSVFaNDBZMmJIN3dsVTdhOWlxZ1xyXG4gIGluVmFxZVRSeGtrb01Cc1loR2NXWGhLWi9OYmxPdjF6UkkzbGpwRWFSNWtNYWl5M0FQWE1jbVg2TjRNbGczbnQyUnpxekpHdTRINWFcclxuICA5SFh0WHlUTkx4MHJqZi8xb21SV3FTSjE2OVdUWlN1eTVJOC8vNVp6TDcxWFB2am9CMGwyVE82RllKYTlNRkRkZUtPMzZMUzM4VEFiXHJcbiAgQ0dzSXRqR1VNT0tKdTUyenJkd1FCZWV3Z0xWdVpBNHpHemdnbHJHRUVXL3ZTRThwSS9jOStKcDg4TVZ2Y3RTaGZlVEpSNitYYmoxalxyXG4gIDh3MG1nbDJ6U3FCcXM5OXMwZUpwZ2NIYlZGcnhhV0QyTm5hWmdSeHcyQUZ5N2I5OUNvUkVzSTZlVkxSUjhwS1NsWUdrTVoydFRpMktcclxuICAxMVdVZ1ZoV1dJem02Wlg4eklPY1g3WnlyWUFZOHNjdDFxZ2hzdTJQYWY0c0tLUXJ3enlVZ1ZCZXUwQWxIelpJNGhobEFNRzVrYkpiXHJcbiAgdVF2aWdlVTMzSVBQeTFHbXNYRUZibmJlTmRpT0JhZDR1STBxRGIwYkwwdkJlaWFpaWtLdnlYKzNrTHE5U2Y4TFZYMVZ0VWwzTnpJYlxyXG4gIEZWSmZCWlhjZjlLdGMyMll5TWFWMDZYalNaYVIxTmZMbXZ0N3hIVVlLSk1ManJGTSsvZ0d5ZDZ3U1ZLWmtNcnRnVTJUMXdwZys2aFlcclxuICBzWnkwT3Y4SFZTbWdXZ0I0WGpGZExZd0JYVGJwVXdBcExjSUVBdlZWYW9icnZGdTNLdU9BaUZSd3hJV0FRdERzd0V1VXFUSkpGTUJwXHJcbiAgb0Z6MVJzbzBBS05nRy9rYStwNTYrM3drRXRRdGllQi9wZis3UTloajJBMUE2R2Q5KzJpRWNSUmtKWjVjYUdleGF2S3YyczVmYjU2L1xyXG4gIFZ4akpkcXVHRGlMNVpTK2FwTXpFYkNFQVpvSk5aQnJNb2x0L3ZSbFZjN2w5MmU2ZGVla2lWbzJWNWQ1djl0Sy9aZW1mNzJ0N3ZHK1lcclxuICBETWxDclY5VXhiM2NnVUZHQlNkTlZxemJUbFd3RzVlVHN5cEpwUk9DVnBzUHVrN3RvR0VhMFBMd1c2V2NrL3B0enZRS25VNlhyamRPXHJcbiAgbDNZZE8wbk5PdlZrZmZZbWVlYUZqK1NrYzF6L2JOTmNSdnhnSGw0ZU1BUm1GU3dOSEcvYnRwbXVrUktNQUljQjgyQS9heGFJUGV0RVxyXG4gIEtodEEzVXFWS21nZENQWFVJTlY1b2tBN2c3R2lTUlArbHBtekZzb3Q5N3drZmJ1M2x1T09HaWh0MnZsdloyZkFOYmNINWpjQm5UcjVcclxuICBqT2Z4cXEzZFJXWm1NTDlPSEhaTGhjVTBpcVhEOTJSY2VFbUpBZklMY2lVbG5SdHd4MkpjZUlrTFNkSW9hUTkvYmpRSGxvSDlqaFFyXHJcbiAgZ2ZWbFhkeC9SdjlzZWQwNU83WkVQTEJZMUxEdWdHZFdzTXYrK0tZb3UwTDU2azBsVjZVUVVwaTAxY2hibUE4Znc4Wmxqb2tFMTQ0eVxyXG4gIElYOC9sUnN3QWtoUzlSVkJiM1U2SDZIcUsrSWwvRG5CTlVMbm9iNWlxVmpmZldnWTBQV0lWbFI0NXVHTmljbHBGU1RMTVJKL3ZwNHVcclxuICA5WHVjcElaOWNsa0I1djhBV3NQOWFUcmdJdmZSOWxNRE9ja1FPY2VRVmpaWmVsMzhnZVlkZzhFeVhTOW8zTzhjWlNJR0d6VWlmWmd0XHJcbiAgaERXWldibUdxU2NnTWxXYjkzYUV5REVYeHdUUWxSTVhBcUZDdXRoY3NGR1pCdE9wMm0yVWJDN1VmV1k4WDVzdlRhYzZxUU1nZmJRNlxyXG4gIDFLY3NCNkZiM3pGMnFYSXNJTzRRK3NsdlhiM0hqQ01lSy8vNldSbkpqQy91M0phSmdGMjQ3KzFXRFE1QzZDZTk1U2NZSzFQV0p6RnRcclxuICBkNHhqSEk2WkVHUUlrOGpLbGFZd0FzOHMrcXVYSE16QkNKMHlFL2VPcWR2MTdKZlU0VVVsanRtL09rYlJYNUtTVXpRek5mM0Vwd2Z5XHJcbiAgNTZWWHFTczFIY05Ba3ExWXo3dkdBdFJXMmE3UG03ZVd1dHB6a3ZzLzQvUGJneHh0cnA3YlQzK3RlOXAzMHYzNktXckxxK3lra3FWTFxyXG4gIFY4blB2NHlWVTg2OVEyNGYrcXpjZTgvTGt1WklDY1FjVjE0anJQR1RSM0g4bVdmZjB6WHAyRzFmUERpZi9YYU1OZGx6RTRHNlRJUkZcclxuICBIUWgwKzdpMDlJa3cvZStaY3N2UXArWDYyNStRcHMwYnlrTjNYQ3pGYm9BZFpnaWw1ZUFLdzJKSzdEeHpZN2J0YnQyODNZUThXY0FrXHJcbiAga1QwRnFWc1NZYmNZaUtGM2srQmxCWjBuakFrejU4aldvaEtkdVk2MEdQaVhLM2pCV2grMWxiOHBueGZMTjRJM2h3ZmJickcyYlIzQVxyXG4gIEUwWFVYZFNIQ2VIaDVVcnVPa3lwQ1ZDUkZCZmdtWVdheTBlOFJ3aTFOaEFsMjdscjUwZm1LUUhNVmFIR2QxZlBzdnBHNEMrdVlBSWVcclxuICBEM1JFdnMzQ0hCL2I0aEd0QzJBYzBYM0JPdFFlSTM4a0R3NFJoMEZCajBhcnlPUjNMblYvSFNOeWRWRm56ZjdtM2tnVGZJRGt2c0tnXHJcbiAgUFhYNlZKMlF5c0NjSHBtVnEwaHVjWVorME9ad0FCYis5cklTQXo1K3JsVmM2R2VLSXgzS2J3OGNxQVFGNlFNaUNGb2Rkb1BiTjBBK1xyXG4gIHZ5aFRLdFJxcW95QVVTdE13MjYxU3BPdUVkZnRwZU0rRXVKZVlCcTEyakl2ZldBOGQxSkhXR1UxM1pXWlVUQnJwaU1rdWdlRWZueHBcclxuICAySWtxaVFCQlJ6cjRlVmhYSmZUL0pCWU1mMDBtdkg3T2Y0U0pXTUJmcDVNZmtiV0JUUVJtQUhodkpubXNZU1pCaDNyZGpsVm13ajRXXHJcbiAgc0dMU1Y3SngxVndwV0xmVURRQ085N05IYnZYOUNZMEN0a3hTb0FDWWk5bEJDRUMxQVlhSGQzU2h6ekhiSlpLdmdRQlgwdTNNK1k0MFxyXG4gIE93eCtVREh4STl6aS9xZlg3aVI5aDg2V092VnFTOTE2RFdUdDJnMXl4OTB2eU0yM1B5V25PbVl5Y2R3VUdUMTZvaEp6dklVU1phSWRcclxuICBmRWpmQ0lGbGJmTi9oTUg1SEF2WEsyM09kZW9hWWNiRkZZVFBEV1AweURGeTY3Qm41TlB2L25CajUyUzU4NWFMWk5EK1BhVlRWMzhlXHJcbiAgYlVVZEFHS1pYeUlZZ3dDY2E0R1VCb3VIc1Nsbzk1WUVVcVdLVjVuRlk0OFl5TGRmL3hDVUVpTTUzZHM0S2xVa0NwMVVJdUtuczlVT1xyXG4gIEVqV21XMmRQREVkQVF3VFdnMjIvTDM4OWVhOGNjVlFpbnlUbHFqYjBic0x1SEFJVGtYeW9hVkh3L0lscFQ4dEprcnQ2bmh1dHA2djlcclxuICBZMk13VjN2RldxMVUra0NpOFdUY0xiUWJsTTE5TjN2cFpDMlRSMnZENG9udW52QVc4YldBbGV3djZpdXk5aUlGbUJTaDl4RzZMMDBQXHJcbiAgTWZNWEtWc3UwMGVnYzNad3IyUWN0cXpER0NWYkhucVRQKzRXblVETFlmeXpmc2E2Rkl3ZUFUTFN5MHFseXY3andhRFpwTCtmVjhJQVxyXG4gIEFlRERoNUhVNmVSbk5xUDkxc3dINFFnRXJyc3dpdm0vUEJmWWVFVDJ1K0l6bFR3QVVnZ2dvQk9HZy9vS3lYREJyNi9xM2JVNThtYVpcclxuICArK05UVXExVlh5VmdBT001NTJuVStkU2ZJMnFzNnExOURpOE4vdHdlL00vZUxVREk1LzMwckVvSGhkblJIRTMvSkZaTkdpR2pIeitrXHJcbiAgZENheWs3OWx1OVhjd1E0bjNxL1B1Rks5TnBwekRCampVR25FTVl2VzNmclByOWFzcCs0cldMOU1NdHlBaS9jR2VOOU1tOXRrd0xtNlxyXG4gIEQrYlQ1WXpuSXJZdzFKbnNJNGlVYjlza1pvRFRSWEpLbW1aY1hxUHp6WkNMTFY4d3NMYyt3cjlmTTdZRHBCSDZlNFZhTFdUVG1qa3hcclxuICBnWWpRaHJrL1BpWmRuVFRTNkpnbnBFS2xDbEtoZkFVbHhnc1dMSmM3SG5oTm5uL3BFL24rcTUrbHJLT2xGU3ZHMHBJK2ZicG9za1NJXHJcbiAgTFdDOVV2TmR4UUxpYjNXaWpDRHhVOFpnYllRNVVYUTJodkViYm5sU3lsZnBJbmMrL0tibUFiem4xdlBranRzdWxMekNhSC9tT21RZVxyXG4gIHRqaVNuWDc1Y1FqL3RxWEwvS3ljelpwRzUxdlpHekQzNVhqc0VRUHhDUDNvb0ppV0hJeFNDdnpEeWlzc0NDU0FxQTBFcnc0RDRyR2VcclxuICA2d2hreElBT1lwNm5WdEIvdHA5eWhtTVlsREtxTmhLQ0VmMEJnZ3VEd0tLQTZIcmFISnlvb0IyL3pkL3l0WnA3S1NaU3hjOHdXTEZlXHJcbiAgZTBrdUczUktUdkVsRDdkUkxyTitaR1BUS2lkMWFTbjRRL3U2ZVBzSGViaEk0YTRxckFWL3Fwck1WOVV6RktpdldCajVseW1iSVN2L1xyXG4gIC90cnQ5Y2V0Rm5OK3JIT1NCOFRka2lVcVhJVlV4NkJSWHhtU1NJVWNvRmkyU050L3o5YUp2R2E1a2FEWmZIQTlabFRJUjQwOXluVGJcclxuICBCUnVpUVVnUURHd2VnTG5WelVnS29XblU3eXgxQ3pXN1J1R0dWYnEvOVdILzF1aDB2TWxzYkFValIzMkZqVVRWVnhqUGcyTnJaNC9hXHJcbiAgeG5oZXhra3RwU0w2MDNZTHkvLzZVbVo5L1ZDdzlaL0Rob1Z6U21jaVlBOS9GeUIrQmxzVEtNenp6QkhHc1hiTzZJZzBnaHJMQjdGNlxyXG4gIEY5L3kxY2tkaDJRNFZHWjhmcGZVNzNHOE1nOENDMkV3Znp4MWJNQk12S29MaHRTNDc5bVM1cjV0amZGeTU5SlBHRVNWYkNsMGc0Y29cclxuICBNYS9Xd3ZkSnNqTUErcHNmeUxrQmtaTkNhQS8zZHp3VVFmQnBxdnM2MzAyV3UyK3QyLzBzNmQ2emh6UnYyVUtxVk0yVURUbDU4dTU3XHJcbiAgMzhpOWo3MHZ4NXh3dmR4Mng3TXlKcFFwQTYrcThIemVFTzJ5cWQ0ZUdBYkUxNWlJRWVUU0pBSU0xdVROQXB6RHdzUk9aNXh6dTV4MFxyXG4gIHl2VXk3TjdYNWNtblhwV3JyanhYN3JqaEhMbjF4blBWUUU2N1psOEJiSGNKdktyMkZteU85TDJOeEU5aU54bklvQUg3U05PV3NUbitcclxuICBvM0JNWUVzWnFlUVlGbXlrVExsVW5WU0t6Z1ZNdldUYkZFamFac0NBcnNkY0R3b1QxZ2pDdTF3Wkd3RWd3UjV4SlRFVlhCdE1JQVZzXHJcbiAgSGhEZk00MmhBRmR3R3phRmJXbzVIM3RoMVluLzJGSUVnN1A3OFl2WlAvS2N0SkZXb2FZYUZYRkh4ZjVSQmZ1SE5hRHc1M2pHUWI0dVxyXG4gIE5wTmk4MzNwWDFLdmpGSHZLa2Y1OWVQUmp5elVWTmE4MGFxMjB2S2NVUkgxbFZYSlg3ZEl2cnVxb2hQbnk3aVBlS3VVaEZSWTVkSXJcclxuICB5T3BwUDZodEIrWmpxZ1FDdkFDZWNoamt6ZjZ4WU1UenVnWVFDMVJVSUh2eFpOMG1Hcm5PUGtmSUlpZGhMQjc5WnVRZTZHd3dpSmxmXHJcbiAgUCtEcTlZdW93Mlo4WVpOWmVmVlZvejZucXZySzJyV285UTBMdDUyRmJodUVuc251QU9JOTlXTnZPL3FmQUV4a3lnZlg3QkVUMlc0VlxyXG4gIGQzQkxrYmN0dGhseXMwb1ptVTI2K2R4aURqQU85cVZrVk5KVTdUQ1ZHWi9mcWZzQUkzOWpGcnhMMGhEMXZQaDkzYVp0M2ovNTRYTFhcclxuICB6STlJclFBSnhhUVVvSU1SVjUrK1hiL25TVzV3dEsvV0RVc2dmUDN6Zm41U1d1dFVBd2IvNjZycVRKbyt6MVcxRnIxMWdGTnV5TnZTXHJcbiAgL0lLZnBVR0RCa0dRbTJ1N2ZpMFpPTENIakIwelJWVmJOOXo4aE54eTI5UHl5NGdKVXF0YVpXbllzSTVPSlF1TWdNZkRHQWY2L2lnVFxyXG4gIDJSYWNUOTRzTVB5SDM5eTFucElUejdoZGZ2cnhkMGwxMHNhRGQxK2k3cmgzRGIxWWV1eG5RY1VlSmlIRWcrdmw1ZnU0bU8waGZPOTdcclxuICB5NzZ4TThDZW1naTd4VUFHSGp4UWpqZ2lHdHlWQ0dXU28xeCtjOWxxRVFuRTRnQjA4aWdIdW9rM2ZIbnlUQlM2N3pvQm9JNjZ4eTNoXHJcbiAgY2xBTE1Wa1B1WkVxODVaVDl1Njd2cjN5MVgzc1I0VWF6ZHdxZXA0SEoxb3BLYkRUYkJXeStPYlkzT2RhSjNST3NBdVkvWU9aRkJuRlxyXG4gIEU0R09hb2M4UWg3UjgwamZYaWJGR3pSSmFZOXFTa0hiV3MzWFZlYmh5cWl0Y0FldXFuWVF3UEdreUVoTWtlQjVrQ3dQa0VNSGhBWFBcclxuICA1SnFkcFdhN1FlaUZwRnlOSmw1bjdVNHo2VU56bGZsbUZFWUlTRzBmUnNXNnJWVWFZZUlvOGlBMU9lQWlLZS9hbS9QREUrb0J4RUxPXHJcbiAgTC9POEE0MzduT0h1YWJPWFVvSnJORzdTYkQ2OUFiVVZmWUJwY1RtRU5BaTJiRTZjZGlKOGo3c0RpUGJZRjQ2WDRpQkgwdjhVbHY3eFxyXG4gIG1jeis3ckYvakltME8zYW9NQzhMekFFRE9yWWxzNE1RVjRSdHIxbkgzc3NYQi9FaXpIK0RCSUUwMHVJUWI0UTMyeUpxMTFWVGZFWmtcclxuICAyb0M1UkFkQWljZW5tOXhnaE5RbTNDVjlqQUVLVXkyRW1RZW82aVFRWE55OStqWEpTWVUyME9DclRIS0R6a3lWdE9uN3VVN0tCMXZtXHJcbiAgZnlIRlcwdGtjMUdSTkhMTTRjWnJUcEUzWDd0YmJyL3hiRG54aEVQa3lhZGZreUozN0tGSFg1QUhIMzlYUHYvNGUxbm1pRGVFT3VxbVxyXG4gIEcwVkdScnFzV3AwbDZlbHBVcU9HL3pZaDF2R01oQnhWNTExNHA3enl4bGN5ZU1qNWN2aS9ybkNmVTRrY2Qvd2dlZVRlUytXTlYrK1VcclxuICBmYnBIblFmQzRGMkZKWVNKazJiR01BU0w3ZGdiTUsrcHBudEpsZFcwaVUrR3VXSkYyTDY3bXd3a2pGNE5vaCtoSjltdVE2UVZLVUd3XHJcbiAgeGd2ekdJSDZZMm1Wdk4xRGMyQUZoTmtUZGc4ZnJSN2ROc1RUY1B1VHYyNkplbUtCOUNvazJ3c3FXcVZnTTdZQnl1NXVnenFxeW5GbFxyXG4gIEFnMUpuWTRiOEtibDB5UUhGMTYzUDNLbU84SC9Scitra05Nck9FNmVLQWkrSmxiVVBSNVdIeHNMWWo1YmVEYnhNVVhzSCt3TlRpRTRcclxuICBzQm9xTEhUS2JwKzNkVVNQZTdWVjJQNFJqS0wxZUpKZUErbkRQbWxNSURWYTlwQkJqK1NwSzZWK3ZHN2Y0dC9mREdwNFpEYnFHakdDXHJcbiAgMnFnUnZUVk1vdW1BODkwb2MwU0VNZFpxUDBqNjMvQ0xqa1pSYjJSVXF1bEdvZ3VVUVFBSTFqb25hZUdwdzRpV1d5TlRMRklIU2Zld1xyXG4gIE8yQjhSWDJGQkFLbWYzcUh0RDdzT2kycm03QkRKSE5BR1BvN2R4OFE2OW5mUGl4Wk03WWZzUFdmd3R6dm4xUlZXcW5ZaWQ5YldoWGVcclxuICB3NGFsZnZyWHpFYmVveWhzQjFrdzhoWEphSEZ3WFNiN29nMGtpbzJ1bndMc1VyemZkWE1EMjRhcmdJMmlJSHVGdjU3NzR6MjNmTHdJXHJcbiAgKzdBRHdsZ0FmYWxpdmJiUmdhT0RTa1I2c2grMEFMNzltaTM3YXhvZEhVYVdTUlltUHZNSGZSOHZ5bDJ2S2wwY1d4cnNlNHJ1ejUzNlxyXG4gIHZxeGR1MVlhTmFvckJ3em9JaGRmNnVjUTZkQzVyZHgxaDVjQUhyanZLdm5xL2Nla2R1MnE4dWI3UDhyQmg1OG5uM3cyWEg3OFpheU1cclxuICBIdUZ6V2hrd2h1T2xWVkJRS0pNbnoxTEMvdXpUYjh1cmIzNnRFZ2IyREpZQmc4K1ZUUnMzYWQzUDMzMUVyM1BZSWIxazhFRTlwWGI5XHJcbiAgdXR1VlhGcUdvdUNwdDAvbjFqSDFrNE80dUIyQldVakJ2dnY2R0M2VFJQNE1wdm9GSFR0Nmg2QUdEZUk5V25jUDVsRWI3NnE4Mnd3RVxyXG4gIGQxQ3dlblUwVXRSUTdFYS9HelpIUjUvcHlaNndSSU1JWFErd3lEYUhTR0NSMjErWVkzcDNWeWZvYkpHMVFiZjlUZ3gvcHF0UFNhOGNcclxuICBUQ0RscEpDcVBtNkR5SEtmeHQwanpLd2lEUWZ0S2JFUGR1Rys2emV3aGJnUlJlUThXN3ZmV1pBanlTbDRVRGpwcFd5R0V1L0tta1dZXHJcbiAgNnJURm9vZmRhRzI5Mmo5SUs0OXhrcDFrM1BVTUpvQ3JqLzBqSE8xTnpBZXdXb3pxMTdtUkdCOFdJekkrckRDeXBuK3Q2ZG1CcFRIcFxyXG4gIGZPcXo2Z0ZqeUlvYkFjSlVpREkzenhrL0M2Tkl0bU1DMkZNZ0pJMzduaVhOQjEzcGljcjhQN1V1STFVem5DTjFNQTB4eGxuZERxUVhcclxuICAxQjlGT3ArSlI2dkRyOVA4U3RYYkJpb1BSK1FBN2FTa2xYUFBLVHBUNVQ4QmlQWGNIN1lkZ2Y1UFl1bGY3NVF1aGV3aFZrekdoaWF5XHJcbiAgYVpXUFZVQmRpT1NRWHFXMkRoRG9XTXNtZktwTWhXTTVqdUhBZUV5dFdGSlNyR1VZdzh3djdwSWxZOStUOU1EdVIvK3RWTDk5aEdsQVxyXG4gIDZBMWtNVmp2K2tuazIzUFhZZUJFNEtwS3ZLNC9hcjQ2QjNvcm5wZzY1ODdXTFc0L2traTB6NXNLQysvR1BMNXZkMlRObWpWU3NYeXFcclxuICBYSHpPRVhMNjZVZEZDSEY4TlByQWcvdkpRUWYwbE5OT09raU9IakpJWG56bFhUZnkvMXZPdU9EdUNGTmdTYS9ZV1o1NzhXTVpkTmg1XHJcbiAgOHZaNzM4bEpwOTRnZHozNHVvd2FOY0V4dGhLNTlKSXo1WktMenBDdlBuaE1YbnZsVG5uZzNzdmxvRU1IQmxmWk9jeEtrUERSVUtzV1xyXG4gIHprV0pKYmw0VEpuaW84c1pLQUl6NkRkdFdsK2FOOS9XdEtBbWhEMUVRWkNFTXBaKzdva0VFalMwS1gvYklKN2tNbHVsdkR2TTZMZWNcclxuICBleWdyVm9lOUh2eDVGb1h1Mi9IN3RrVkExQ1BIM1RxbXZsOTd3czg4NmxHYmdycmU2dUVrblJ6SEkxTFErcnB5eStiY2JDZnErK2h6XHJcbiAgRDFkdy8zMGdsTitNQWR0dUlZMEpZai9BWGtGS0U5cXRFc3krNXhGN01zYnpuS0Rkc08ySDMxQlNYT1NrbUw4ME5pU2pTbjFWejFWcVxyXG4gIEVCS0hYZHYyMFRGSENCOVd1UFdvOTRvZk1kaW9JYmxtUnoyUGp4WWJCeEh1cllmY0ZyazFWaGxWUFZGQVAxM1pFUVZRelkwRThiekNcclxuICBkb09FUWVkQnhiRnl5cmNSOTl4cUxmdElzU1A2UmtSZ0pCQ2ovQTByMUZnT1VzdkZ1azNDTEt5ZUVTcWJvalpta0JHUEJMdDJCUkJwXHJcbiAgUC9YeGZ4ZldUdnZ6SDVOQ2JERFM4dEJycFhCamxqNzMyZDgrb3RIbjYrYU4xV1BORHJoRUdRVk1QNjJDajVWUUx5djNuc0pPREV3aVxyXG4gIGhpcVNHUXdCQXlFWWpqcFh1QnZRK1hnQ29QNWtzTVFBenNkNUphbDMxcnlmSHRjQlMvV1cvcjBER0FjQnJkYTNGZnA5Qmt2dzR4ZzBcclxuICBJWVhrZjNPNlpHZG5PNFl3UUhydUZ6c1pVNkpvZElJSUw3dmlUTG53L09QbDJ5OWVrQWZ2dWtwV3JQTDl6UmdEektWQi9WcHl6RkdIXHJcbiAgYVA0b1V2MGNjL1NCOHNJVDE4bjlkMSt1eXdQM1hpRURCL1hicTZvbXc2cFZ1eDU3aFB0eUdOV3JWWW5ZZWNLWVAzL1A1MFkzeGhHc1xyXG4gIEl0aHRCbUp1WFhObUxwUWU5YjJSMUZDOE5Wa0tnOUV2K2tGRE9BTFZRQnhIV3VWb2tFcFpDeUswRzQzY2NNeFkzWmZkbi9US2RkeEhcclxuICBFZzNYTDlnWXRhRW8wWE5yNWhyUlh4NmNGTk9TMngrWnA4VHRKNDI3SFNZSFZ0UStFNXpuNnVzNnRIaGpONm1zMi9rY1dKRmpCaXU3XHJcbiAgdGZ2UHFBd2o1bFpHSFBwRy9IRlVSREFSTnN0VmEraEc1QlhjQjRxYllMU09qeVBCNE8wOWErenUrSnUzWnA2VUNieXV5QUJBYWIrTFxyXG4gIDN0QnQzSFpaVUNza0paZDFEQ0QybmVGU2JTblhnMHNwQ0dKRWN0cWM3NlVJTmFhN0JROGJDQXhxS2thaUNuZWVxa2djOGRHTXhpRVFcclxuICAvNUdTN2gwZWtHSVk1Wkp5QTRJR0d2WDJreCtaaW5NTHp5R00wRDN0TGlEU3M3OTlOTmo2NzhMNmhXTzNMNFhzNXU5blprZzkxL1V6XHJcbiAgaUgzMVZuMzhnUkJJdlQ3N3UwZTBYTDZXajRybTNXQUhOT21EZDhaTW02aXA3RmFTeTZaSCtnTWd6eHZRdEVYdXV6RWJtL1VQOCs0alxyXG4gIDl4WWVrK3ZjWUFwRWlGUFFjdGg3QzlqUkRjdW1hdHFpQmZQbXlWcHlaTGxyaEEzakZsUVhqNFVMbDhXa1dtL1hvYldxbmxpTU1iejdcclxuICA5Z055Mk9BK2N1RjV4OG9GNXh3anQ5eHdqa2FKSjZkdG02VFJrT3NZRFpJUEhsbGNmMzEyckhvbkVjSTJEMU5CR2JERC9CTll1WEpiXHJcbiAgdXJ1clNIVU1GWkFTUDR6ZFppQ0hEZW9sRFFNRHpmcjFzU0gvVlpJM3VnN2lHVWRlUVluVXJCWnJuS1ZzUnZRSTZFUld4NVhEMVNPSVxyXG4gIGFjTnZZS3duUlRwbm9FS3lLUGJJOUxtdVh2bkFYVGJTZ0s3NDQ3Y2ptekh3eHpldThFbktGTnZVY2J0OE5mMWpSdklvL0FuMmw3blBcclxuICBXVE1xODFQd0FuZlVWM0NNdEhaRTc0OE5CQzh2dFlFRXh3R0pFeG1KQVF5TCtNUGI4YWhSRTVXQUgzbVdxeHpWUVJ0bWYzTmZKSWdRXHJcbiAgSm92VVFmWmdES3Yya1VNdzFqdm1RZFE0RE1IaVBtQllPaDJ4QThSbHJTTTBhMmQ3cnpCR3NLaXNJQURNRFdJd2RWYTlyajdxSFZRdlxyXG4gIEovTlJlY0ZJa0VRTWVXdThpaUxaQWs5QjZQZnZDY3hHODkrSVJiKzl1MzBwQk96Z09TUTZYS2x1YTFVdDRRM0h1MEx5TjBPNk1udjNcclxuICA3T3UxN3JFK0tTbFozOFdxcVQ4RWdZY0ROSVlrak9KQUZRbER5Wm83Um0yT1NEaWV3VGlKSmVnN09Nb2daY1FHRTdyQm9TUCtTTTdrXHJcbiAgYWlONm5WeHdkdGZZRUUxVGdEM093UGRGS2hYMkZidEJUTm55MWFVd1AxOGFOYWdsZ3dkMmpWSFp4QWZWR2NqbUN5RGVscTdkSnBrcVxyXG4gIERWR2lXL3BEdDZqd05XdldLeU94Nk8vU0VHNEpJemVwNWNNTUpUL2ZPeXpzYmNSSDUrOE9ySTM0MU82N3pVQzY5T3dpSjU1d3NKWW5cclxuICAvRGsxNXVtc0xTd25SUUVEQWRrYmMzVWRpYWVJWU51WGt4TGt4OXJtV0dTVGd0K0lmeTZxUWxJa1NacnJhTWFHb3FOMFExRFdGYWxMXHJcbiAgUWgrSzY3SE1nUTdLcEphTk9Tc0t2NWNFaXZGQUZXYm4rRFYvRTdkU0xXSkVkM0RYeFEwWnJ4ZU02SnhpWGw3eFo1dE9tQU5STHkyUlxyXG4gIHVkL2NvdXZpb2kwK0E2OWJVaG96d1ZXMGhUSk9ZcUJkUE1kQVZOWG5SNGptamtrS0dGd3VPUlllWmNMNGlDcUhhTEFnUVZSdDJsMFpcclxuICB6cHJadnltelFQWEczQklHQ05PbWxiTTFJWi9weVRHZ1p6bkd3NldSWkdwM1BFVDNWMnJnMVdmRmdZcHNiNEhSL2RMeGJ3VmIvKzhpXHJcbiAgK3FZOVVEZHRXRXpBcStzMzg2TUcyekNxdEQwMHMxeWd3a1NGeGZmQ08xRUpKSkErMkNhYnRxa2NHYXd4WVBFTXlUR2NvSDhBNGtCUVxyXG4gIFlhRUdZeUh6TDhBK2lJb1NkM2VQNk4xbUI5SklJbFN1MzhIMW0zVXEyVEI0MnBTelVZNDVlbisxYjRBU1J3Z2c0R1lISWMxSUluQjhcclxuICB3NGFOT25rVVU5a21BbEpBYVpKTWFkalpXZi9DOFNqYnk1dTF0N0M5K1VsMkZUWVJsOWxkREx2TlFFQ2hJMVRGQ1poYjJaSk5NY1E5XHJcbiAgTGMyUHpDMTVJckNaQ0gxQW9aSDNKRFcwUmNGZWp2bTFYNktySXAyNU1FbWp6YU53QjRQanBDZnhzSDJzL1VHLzhtVzFmeWpZOWxkRFxyXG4gIHpZUTZDZmRnM2E4bjJPSStrdEFrVTNoZkFWUlFhaUNucmk1V0pVblZRSldDekxmTXVlN1ZSUndNSWRoRWJaVEVBd3dmMW5LU05OenZcclxuICBUTGRLVXVtamVqaUkwSUUwN2VFWHpJUlJNWEJ0SU5IVTJlZklRTlhtUGo0MTZOdDdjQWl1YVI1WE9ySjBpLzFHeTVtMGNvclA1TXJ6XHJcbiAgV2VjSTA2YlZjNlZHeTc0NmR3U3FQTEx1SW1HWTlKRWZKSm1FbU1GUXdEbzNpalZVYXg1aXBnNmNyd2cvZ3owQW8vdDFzN2VkVE9pL1xyXG4gIENVdkd2N0ZqWS9vdVBnL2lvd3dsdUx5SEFETW8wTUJkRE9tZjZab1pDZ0VTQ3dHallaZzZLNC9wRXh5cU9NSnU5NE96QjB6RWJrOEhcclxuICBJMjZiSlMvTEc0K3B3d0RGU3liWTg2SVNpaC9rZVh0SVJwVjZYcjBWK2ViY3QremF3UFY5MFF2N1M0VUthWExvL2xIYlJ4bXQ1OEU4XHJcbiAgR1RabmhzRm1OelF3ZVZScDZOcTFiWXdrMDc3OWp2TmM3U3o2OVl1MTEvelR5TTNkdnBTMUs3QzJUSlZsMkNNR0FpeFRSbktTRDlWTFxyXG4gIEtiTlZpaVgySWpZcGU2d05KRlltQUQ3eFlXaXZGUlBzQW1vdmNQRDVydmp2MDduSElzbDF2Q3BCT1l5Z3BjaEtHNGhBa3k4NnFCRXlcclxuICB0bXBNUFNXc2JydGd3eXJYMzEwaGRDeThzWDdCT01sWk9sa3luZFJCcWhRL3Y0ZUhQUWxzRXo3L0ZSdmhoaWo3YlZ3dDhSRERHRXprXHJcbiAgdXgzVG8rNHJ4QU9MUkFDUTMzRHd6K0kvM3RBNEZ6NWU3aE92SzRCUkgxaGFtZXlGRTNUTmg0K0x0RWtmQkVvQ1QwUUdxQUdXYTFadlxyXG4gIDJWdGpQb3lvb041Q3B3N1dMNWlnS2kwcXduU1FWdEN0bXdxc2VpdlBBQzM5dUJuU0FmTk4rQi8xZndlNEZ1OVFqUVYyOEZ6aUQ1czZcclxuICBzV0pENzVBUmxoWnlsbmxpYXdsTithYVFHbElEWTdvMVZqRmdKcnhIWE5MeG1ySXhJa3lGNlpWTk5XWlNyTTcvNDJBNTVyQjdxS2RWXHJcbiAgR0RFM1M5YnMrUnB3V0xKTkRGQ1NGUDErcDh5ZU8wVXVQdmRJR1RBb2R2QmtTRFN4RTdNYjdpeXdsWmliTE5KSXRXcUphTWYvRG1Sa1xyXG4gIEpIQ0QzMDJZN1NNK0o5WWVNWkFoQi9lVWxrRkVldFB5NnozektIRXZPcWxjVEFEYmhtei9RdnpVczFxS2RKeHcvMUczd2gxQlQrQVBcclxuICBiWVRQOXVXOExLOUR4ODdBQXJ6QjJSSFpTSFZmaUo3dFMwenZxWWhwTnd5M1AzU29pbWJpOWJzMGlOR0JXZjBTdzU5SW1nOUY1QnJSXHJcbiAgQnRVSUdXcWYzRnd4OStLS3FyNXlvM1B5YlJYa3JBdzFFLzE5TUhXTTZEYTVETUQ5VWR0endJM1dUck9QSFpRNGtaZFpIVUdTSXcra1xyXG4gIHlZYzRoR0huVlhPTXc1SkdGbS8yNmlZaklDSGhNL3h6UE55T1NvR1hsN3RKdnc1QURFNkNNL1lLdHBic3VTdmovMVpzWE9tRDc4S0RcclxuICBsdUtDV0dta2JIay8yUnU1eTNoL051MDBLSExmRDFLNmZ6OGVUTXNNOE42RHFlQWdnVU5GR0hncGhwR2FYa21Xam52UGxjakNFTGFiXHJcbiAgUnQ5NWZ2WXltZk45YkhvWk83cG1yUitBTm0zcHYrdGRRZXZXTzMrT3VjbldyQmxremZoZml0UUVLVnQyRjZrcHlmb2V5STRjeGg0eFxyXG4gIGtQMEc5SmFqang2azVaWExsc3FXclc1a20xU2lhcHhRQ2liMXhHSXpKUTN1NVVmTDRVaDFqOUFKNFhKNHR5SjJoMjRGbERORyt2QUhcclxuICA0cXF6a1dpZit4Q3FtVEhPYjBlcWFIVzJiSCswakZkS1BEelQ4c2M5ZkFvVEF6TUlSaEN1NWpac1FxcEtkWmtjeG0ycm1pd0srNmlOXHJcbiAgMGZtVTJGR1lOd3NvTGdrQ09ZTjlHcndZR05sSnR4NkJPOHlJRTBaUnhqRjR5NXFzTmdoM0RPSkFvR1U4YzFqeDF4ZkJQQ1NNWWtPT1xyXG4gIEJnNm1UOGNkT2N4TXFqYUxWVk5aNTdPSTlRcDFvOW1RWTUvTm5tUHIxcjJuRC82dndHNDhuMDNMVFZYcm5uMUtxc2JkcUJHOFRmOUFcclxuICBWWXNOTXBaQUFDUjRYTTV4cExCOGNlWWVuQjVNUDAyLzEvY1l2cTlRbVNKOWk0bmZRT2tEcmNSWTk5MDFzbkxsUXJuanBndGszYm9vXHJcbiAgSTl0WlZLb1ViMy9kRnZFRWw2REMveGRRbW5QQnJtREJ3cWgySUl3OVlpQmdjN0h2U011V0xKT3FaUXVWaVpTa1plckVSWVl0V3NlUlxyXG4gIDNoRFRzT2x0amNCdEMwaTFWb2d1NGJvVTFkQVMzaGNxQi9zamU4S0hERmJmclN3WWtSR1FBWStSbUJORDdVZGlPTnl1cU91dXFDM0FcclxuICB3Mi9iWDExdjgxdmRkbWlYRHpBTW5vMDdnTUV4ZklZUmJFV0Nwc3hUZ21kdnFrVkQ1VUFGaGRzenFPaVlsRlZCWFJXUDlTR2ZmcUtQXHJcbiAgRmFFMnphMDNERk9ObUhwTWsyU0dnTnNub0JrV1V5MmFGMWZoaG0yRFV2Y2F6S2J5ZndSeHIxL0JqSkRSQTc0UWljZUtZZld4NEQzYVxyXG4gIHQ3dE5kZ0MrQTlkVU9EbHFvbXNEMUdQWU4yS3hiVzBZVGZ5bnNqYkxTeC9FZmNRYmNuY0dPMk8wdHRuN2F0VHdrc2Z1eEdiOE42SjJcclxuICA3VzA5TVhjVkd3TkhxSGpzTVFNQm00TytWNkU0U3lxbm9ZTm42bEsvRDFobnNGRkxHT0ZVQnpHSTYwRGhUVjkyakNxVWF5bW1Sa3p2XHJcbiAgUXhsamNJUThjaWhhUi9XNWdZdW5KNHdjWXk3MWtGdHV1RWtIb3RQamRqa3dnWlVuclA3WXRqVU1NY2UzWVN4eGlEbk1SdW4xVVYwcFxyXG4gIFNxbVNVY1ZQYzB1TVNRVHVaVms2bUFpaERiL0FFSERGQkpvZVB3US9wNHVIalVvQnNRZWxnZWo5TU9MYjNKdlFtSnYvNC9DcGZqeHdcclxuICBhVFpQdDAwcjU3clg3dDk3UE5NSFNDdmtQOE9MTGg0d0RxUlhqYm1LVTBuR3dQVkhKaGZ6MmJNWlpJVDZYeHpJUmVmaCszcis4a21TXHJcbiAgbHBvczk5MSttZTYxS1d4M0JhWE43UkVQRWlreWcrRS9nZkE4SkhuNU5vbmU3aU0rZFgxcGFOWnN6L05obFNzWG9vVWg3REVET2JCdlxyXG4gIHA4Z041dVZ0VWdra284eG10OVpkaXZRZ2N0T0lheFJSZ2h1RFJNUXYwVDZJWFNtRUVrVG9zcTdERlYwNTJFUTJLQk5tRktGNnhHVVlcclxuICB3bWVEcFBnaHZvTm5RcUg5Rk9PcUJiS0lsbUlRMlRScFJUY0NzQkhzS0cxL0hFcWgveEVWbGFrc0ZPNUJRU1FNaVZ2ME1DSlA4a1NGXHJcbiAgM1pacmoyaG1FQ2JXWWMrNytJWk5zckZSc0VYRGIvY0cvbjlFc1l2UEtaSUoyd0gxbFFFanV4blJUUW9PZzVpTi9LekZrcEhwQng4RVxyXG4gIHVmTCt1YnhQTGVLWmpPc0FXamFnL293Ri9jTDNEVHowRW9GZ1Y1T1N3ZnIzajVDQ2dnTEpXcjlHOXVuZVVVajUwYUIrNmZtZHpKVTNcclxuICBES2E4RGF0M0xSVjdJaXhmdmpvU053SXMxbU52WVAyNktLMHJsNUV1NjladmtIbnpvaTdBWS8rTVZWbnZDUHZFcFlLZlBtTytMRmtTXHJcbiAgbllKaGIySnhLZTN1TVFNNTROQUROT1FmekpualJqS3VmMVJOeVkvMDdRclFxNENhbVd0bXhFWFRRZWZ3Q0Y2dTFuTGxIWDRYVnQ4TVxyXG4gIG8zVGN5RWs3T2p2dXVOdU0ybU5pajBYU09PajFRa3ZNZGhRcTV1dHU2dmg5a1lMdTk4VXdZbjl0Z2dvSjk4VWk4bkc0bGFVdktZMkJcclxuICAySXlQNitiOUhtbmFwQzlGU0RVWFJYakRsMDBTTWNBb21PTWRtTEcxU29PT09sKzZnWGxCRXNHaW8wa3Qvay9Cc2NpZzlIOEg5dFl5XHJcbiAgQXNuRFBPek1uaFdHZlVzd2RUTHZ4cngraDgzdTNSbWo1OTB6ejcwQlJrRXFkbE9GRmhkdWpBUzdBbXhzZ0NEZktJTWlRMitnT25VWFxyXG4gIDArdTVma3c2RXh4aGJNSzBXYk5tdWI2OFJhV1AzTHo4aEY1V3hIV0VFUTdPQXhNbVRKUCsvYnFwYWdwdklqTHViZzlFcmh1MjV3cHJcclxuICBua2sybzJDSERoYmZzbk9vbWxsWmxpNk5FdWJPblgxYXBKMkZ1UytiaXpLMm9maVlsTkpVVDdzS21IQ2llZEgzMmxkbE5vLzZ5YXRWXHJcbiAgQWtrSnJPaWJISCtJaVY1MHU0bHUzZ2ErZWl3UzdRdnZWR0lYcnVUTDRiOGdRcVJqVnc2K1pPbEtRT1NZS3lRYWpRSHFSRlUyYkVXbFxyXG4gIEJwMVhwRlJvcmRBNkRxWHNOcVRFNVpTS2hTT1JRWWRTTHl5M0x1OUUvYTNyWjJ1enBqN2N0TlpuVy9YdzlaRWNiTTRPUTVWR1BwZ0tcclxuICA5UVNMR2Q3dEZqTXlvN3BzNWt3eHd6bXdVV25aQ3JGZUxCdVd4TTdlRmp0ZWRmZUlHczB1c0xkaGpQSC9OZXpFOHlMdkZiQzBNUWJlXHJcbiAgRStuNDhiQXlOKzFHZmM5dzBnbVpCSlpIK2d6ZVZYd2hHd01qZkdyQTZHTVlrYnVQM0dBU045UmFTS1RFZ29RZE5zZ2J0MzdCV08xUFxyXG4gIDhRaVBkd2h1aFZtdGVPMUFUWmhZdG15cVhITEY2VkxlRWVxLy8vWWVVbUhNbnIxSW1VWTg0NGpIbWpYcjFLVVhLV1ZIZFhkMEhOQVdcclxuICBpMFcxTS9QaDlzN2pOeWFTa01DY3VZc2x6ZjNPbllGZEkzNCtrRjY5b2w1dmRwMi8vb3AxY05sZGJONWNuTkNXc2xlK3FzTVA2aGxKXHJcbiAgS1VCYUUvTHc0OUZqU0lsN01INjBzMjNQais2Sk94YlpqTjFQVkRXSUdnSWRnaXB4TFFRSUg0eldTTVhvR3o0aEtQdTRsRGdFeHphdFxyXG4gIGlSSmlUUXNTRU8vbzlMeldJR3NyQjRoc2h2ZEh5MWxJQjI2N3hlQi8reDNBSFdhS1hhRFpnUjJJS1Fralh2b28zTHhadHBiMWhtcmNcclxuICBmeTFkZXpnYkw5SHZ5YWtad3ZTekJKSDUrVVlnRXBYMWQrVmwrUkdOTVFPYTVrNHIxVzZwVS8yQ0RjdW1hUnlNR2RGeG16WVZSWmd3XHJcbiAgZ0lxMVcyaFVNd2k3aW9Kb1FPZmVSNHpLN3Y4UVNGVVNtOXd6aXR3MUM1VVpGR1N2ak1SVUxScjFodHBLVUZmeFhYRStzVDZWRzNUUVxyXG4gIHZwSnJnNFB5VlRXOWU1aUpXTHdKSGxtVzFZRGNXU2FaRkdRdmQ1SkZIMkVlZG82ekdJZ1BzUytBZTluMDhkRk9FbGlvU1EvMzdkRnhcclxuICB1OEYvYTlmNmZyUTl4bUI1cHNJNXNlSUJvd3JEdHhYZmcyTVJ6ZzAxMXpHQlJIT3k3d3hhS1AwTTA0T2RoMlhqTFczU3A3MkZSTG02XHJcbiAgOXNvVmUrL2ZXNDQ5MXJ2ejV1VGtTR0doa3pCQ3ozMXJ5ZllmakQ4YVg0ZHQyeGNxUjFidVh3eFJzTHJBbFNPYjRmMkpRV1paOHlJeFxyXG4gIEYxcXdiVkJpTEd6VUZzbTdWUXFJUXQ4R2NiY1Z1K20zVE9VQTJHUDJpMVI4OWgxczIwQWtPb0E5VThMN3JXQ1JWeXY1Rk5xL2FUbnNcclxuICBRbWxPREtnWkNQQXpkUllmT3d4RVo1eHp4MGc3WWlDWWtPQS81dml3UEZiVlcvUldkMUNJRXMvTmpLUTI2clZSSjVLTGRRMU5zZUhBXHJcbiAgdk55Z1NqQm5CY2hmSDNoKzdTV0VNeC8vdHlLbFFubXAyK1dJWUd2dlFGT1FCUE9yWkFSMksyYVNCTHhYM2hudmczZUttemZ2cldLZFxyXG4gIGx2cCsxYmtrY0g5R2JiVjIzaGpKWDdkVSt3VU1oWGNaRGtwa1VBSENUSVc1ZFF6cFZSeFRjb00rM00vRDhVZlczN2tQR0FrcXJGV3JcclxuICBWa2x1N2hyNStzUEg5Umd3RlVxWVNkaEl1N1NSUGFoZVBWT2xBMUJhZWcvT0x5cmFyRzJ6c00yc2cyM2FKSEFjQ05KNkpNTDI4azZGXHJcbiAgN3hGMUdwcVpvc0R6YTI5aDVuWlN4dThwV29mbU16SHN0YS9LSHR2S05XdGwyWW9WYnZRYjJDY2NzamY0ekxHR0dJbGhCNGkxRWNRaFxyXG4gIEtXaG5PMVU0NWcrSEt3VmxYZkZuYXhDSlRUbGNMdzV4aDRpUGlLL04zT2RSUkk5V2FkUk5kZnprMTlvVzBYcFpPaU1ocVQzMmN5T3hcclxuICBiVDAxK0tpUkpqSmRlM2JXbHBYakpQdlh1N1dNaTJONldxcXFFREZtRS9WT1JSZ0l0aWRHaHlVaGJ6ZythRXM3QWFxM0RPd1I2WlcwXHJcbiAgYk1UQUVoR1NrQStpcEl3aDdzY3YvUFZWalpDM1VTckV5YUxNZ1pWaE90WEt5L3lhUVVxVHpDWmQzVEdmeXR1eThHWmtSZzJwZXdNUVxyXG4gIDVyS1YvemtieTk1QTh3TXZrQW8xZHoxSWJtZXdhdXBQMHJEWGlZRkVFYzJmQm5JWC9hbUs4bXltRW9ZQXV2ZGF1OU5nZGNkZU8rczNcclxuICBXVHZuZDMyWDlKM1YwMzVTanl1RGRRSDZ5WVlnSGdoVlZZMkFRU0NsbXVTYnZjUW41TFI1L01OTWhETFNFRGFROWRPK2xubnpmUERqXHJcbiAgZ0lQNlNwOCtYWlNvNDRvN0pwaEtOaEdvOCtCRHJ3WmJVWHowOFErNkRqT2UwZ0NSTjBKUEhNaU1HZHVtbGlFSlloaTB5ejN1Q0VnS1xyXG4gIGt5YjdMTlY0ZXVFUUVEcy9lK25NeHhCbVFpWjVHRm81QXQra2lWY2wveFpJV3JiZUV5d05ET2gxNnZ4REtpeUFhN1oxcHB5Tm0ySWVcclxuICBSVXJJd3dkRWt4N0dJbzRlZVlSMkpqd2VnR1BiWmxzTnpuQXJzek52RDZxbUNkZHo1YWpmT3dkaUYyd2s1cnBvdWFYOHNXMEIwOFErXHJcbiAgWWlrYXFqYjFpUW9UUVEzU3dVUlM4YkFFaStzWGpaZXQyZk5rODVTbFp2SGVBQURFcFVsRVFWU1haUFh3KzJYR24xOUthdGt5bXNxa1xyXG4gIHNIaXpGRHRDZ0kwaG01a05IY2lPbXVha0RTUUs3QnM2TTJFQVBsNGtCSmhJZEhLdUNtcHdaejRRUnBtTVVFR2xCaDAxc1IwdzZRTWdcclxuICBEZmtnU3YrelREMEZvekUxQ016SG1FWldyalExR3doelBDamNpUnNXZVZWRmVIS2l2UUVJYzRQOWpnKzIvanVSWHRHQ1dYY1JwZlFqXHJcbiAgUURZQnNNNUprTHdqbUxoNkhZYk8yYkIyZVhsTE0yUE9FUVFGNG1tRitpc25zRjAxNm5PNjlnVlRRWVlsRGUwamJnR2syd0gwcWZBY1xyXG4gIElXVHpEVE1OTDZVbWFWOWtFSU1FdFA2N3F5UXZMOWQ5cjRVUjZZT3BJeUNjRU9ydnZnOFNpWVlRbVpIdno3OFRadG1GMEhLdUVkOTRcclxuICAyNEVoRVlNcGpXNkVHUTJJejFLYkNOREV6cDJpd2JKNGZCbDJocm1WQmpzWEc0WFpVWmhoRWV5TmhJckZ3WVJVRmVLaTBNRmVZeUNIXHJcbiAgRCtvbFRacEZQNEFZWGhyM0ZzS3FwMjB6OU80T2ZQc0ZHZ1RveTZUNk1MMnVFVHdQZnp6ODExYVdDajdZVkhqL2VDOEhoZmRYcnU4TlxyXG4gIFZzeXdab2huakZhZk5UbW5MTzhVWUk2RStMZ1l6Y0xyWU1aN25Rc2tmRkcza1p4V1FjcFZxaTVyUHI5QUZuMXp1L3orMWcweTlhOGZcclxuICBaZFBLNlU0NjhlMHhpS1E3NDNtMDNrazBXeFo4cnhKSTRhYTFPaHFrU1dZK0JIWk5jN25NWUxhNTRKb1E5bmhYekp3bFUzUXVFMU5KXHJcbiAgb2M4bVlXSzFGcjFpNW5HbzErMW9YWnZVVWF2RFFkdU1yenpSSWtkV2Y1VmVnRTNReFR6WWV4c1ZxL3VQNnY4U3lHY0dWazM3UmRkNFxyXG4gIFdkWHVjTEFzR3YyMnppZ0p5T2VHaEVGR0FWTkxNaGlyMy8wNEhRallvSUtVNjVvTExSaE1zSjcrMlZEdEM3YUVRZCt4cEtrR0dJVkpcclxuICBKS1JvcDZ2WjdJU1psZEpsNWFybGtwcGFScjU2LzFHVlBpRFNwbnNQRSt3d3pDMFhOVlY4SHpPRXo0MGZ1UnVvUTN4R09QL1Yza3lBXHJcbiAgbUtpdFdNWVI4N0VuQlBPNkcwemFTQVJqSktYOTFsM0IxT25lM3Z1UDJVQkF0ejQ5SW5hUWVCUVdlVUllenNWamlKVWFkdndBUFZ5OVxyXG4gIFVxcGFiQUhNQTRJSllyTDFKampQR0UwOElPQ1JZTVc0ODZLSkU1TWkwa2VsZXUzMW80aXRISHRpZEI1MHgxUVd1azRkT3N3Y0lKRmtcclxuICBpZzdrcGNxYWE3WUhmNzJVMlcvSzlPY09rYlZyVnN2cU5WbXlLZVJtbUpLZUxFbWJ0MFM4c1lyZDZBT0hCdXdaZlB5QVpJcU0rTllGXHJcbiAga2dtalVqN3FuR1ZUMVE1aW8wcUlBWXlYN2ZCSXM3b2pHaGhabVNDS3dEREhCWU1qSWxQZXUwNm1md3BCaVk0eXdiUlBQS0V5aVFWaVxyXG4gIFJSa0NsRFhIMzBkdU1GUGd4cFhiZXRuc0xhREd5cWhWZWd6Qi95U2FIM3paWHJkL2tPK3E1U0ZYYWJsV3UvMTFQZitYNXgyejN6Y3lcclxuICB4UzN2d1R6cXN1YVFMYmRmaE9rVEsyTHFxaGxmM0tOcmt6NEFmWVQ2TTcrOEp6TFFZRTEvNFJqOUtqNWdrSUdMNzRQUmR1aXRyUSsvXHJcbiAgVmFhL2VZYmtiTndvVElvMjhPQW9Nekw3QldqUkl1bytEQ0RBR2VscEVVSThjQWNFczdTUnZ1MG5QaU1ySzd2VWVtSE1uck5JbVE0dVxyXG4gIHJvQnp0bmNlTklOc3dXRm1GaTduNVNmMitnd0RRNzJoWWNNNmtmUEQ3UUNiOTJUUjRqMjNKYTUwa3BKS1R3bmNqUGNhQXdIcVB1cHBcclxuICBseWV3QVRibWJKSXFxWVV4a2QyUm1KQnQxRTdiUWJUSkFINjg0Uk1vZW1pMHJkWkxpa1JkYjV0M0t4WVEwYlNLb2VocFRXRUNBUzg5XHJcbiAgNEFnd0UrR3VnQWwwL0R6b1NDVGpuUFNDMFRqOG81TFVBd3Y3QjB0bTQrNFIyOHgzVjJYS2QxZFdrYWt6WmtuVzJuV3lNYmRRWGFmRFxyXG4gIFp6TVBTSWw3cGN5UFlENnlkTzc1WHc5VHRRVzJFOUszdHhweVcxendwR2QrYlFKMWxURk5QRzNxZFRzMlVHTkZQMmpVY1V4WGkrZVdcclxuICBxaTRDaGxDdjJ6SFNvTmZKdWczWXgvdEYwckI5Qm9nVWtzZXF2NzhQOW5pRVU0N25aeWNPWHRwZG9NWnFOZWlHWU91L0M4VEw3RzM3XHJcbiAgeDZ4dkhwTFVjbjd3Wkd6ZWdna1gvLzZPdEJoMG1USUV2S2tBVXcvenJzSjl5Z1lET0VsUXQrV2gxK25hR0VhN280YzU2ZWJIeUNERFxyXG4gIE13OUwyUjZWMEcyYmZoYk5PT0N2eER3eU11OTlON3BlSWpXclY1R3JMamxWOXdQVVRhYUNBdlhxUm1jdkJmYy84TEllZzRBbUl1QzJcclxuICBIOFN2d3pBQ0hHNGpVVDFnKzFzR3pJdzRrNTBGTmhVR2RtSFl0Y3RseEdabVNBUzdkanpEaUFmem5vQkdqc25zS1phdDhBNUd6WUlKXHJcbiAgQk1QWXF3d2tPYVdNRkZ0UERYa2o1Qlc0RWNRV1lqK0NydWxXaWFhM2pVRzRGOGNnZW9DSVdMYWpxUTkyQVhIdEYyNk1pb1poaE5OeVxyXG4gIGxBYWJPeU43MFFSZEV0MTZtZFRZem9GblZqeGpRNTIwSlgrak1wR3N0d2JKRC8rdUo2UHUyMCsrdnpvYVQwSGI2bXpsM2x6WmpCU1ZcclxuICBPZ3ozMzNPMW5Ibm1NWklhUEhycWxyaDZXVmxaa3Yvamxhb3lxOVhoRU4wZlZ1c1pBYkhSbzdueWJsZzhXWmFOLzFnL2ZuOHNrQ0FjXHJcbiAgTTdHeW9XRGphbGYzRTFueXh6dkJIczhrYXJXUFZWMmhzbXAzekZBOVZyMjh6RGVwQklNOXg2bzdwbEtVNjUwdUxONWdiNEpSZnRYV1xyXG4gIHU4YjQvMmswR1hqV1hwYyt3cGoreVREM3pHOTNrdUF3SitsY3J2dVk0QXViMzlwcDMrY2pDZkllU01NUG83ZjNOYzlKSzJ3clE0QXhcclxuICB1SHBJSlMwT3VWcVp5SFFuaGRJUDJoNFZsVHFiRERoZjE2QnVsNk5seVJqZkg1QnVzZDh4QlVHOXJzZEViQ0VscThaSzFxemhNbi8rXHJcbiAgQWcyc08yaEFOemxrY094Z0E2SVpaZ1JoRUZ3WUpxYnhoSlVnUHp1WE5VdjhYT0lBZzNiVE9BSVozNWFCL2RnWUV0MVBhZmcxYU91dlxyXG4gIGlUTWkwNEhiK2VhSjFiLy9qdFZsVnRja0M3UG5USnprWGVCdGU4Wk1iL3lma2lCdVpsY3hmWnFYVmhPbFJObXJER1R3Z2RGNGtERGdcclxuICBKWGtsYVhHMkNCQkxhc09wUTNZSHFlV2pVYW8yRndGZ0NrMlA4UFZDNVlpTFoxSkUraURZRVlOaXhNQWJEM2M2MDhBYWpJbnc4WVVUXHJcbiAgRVJxWVZRMmd3c3Awa2dqcmNKWmVRMHBHUlJuMzdERXlZZEtrTUErT29FSHQybzZ3cGtoYVJxbzg4K2dOOHZrbno4amZmMzRrMHlkOFxyXG4gIEt0ZGM0d2hSM1JyeTFqc1B5cGJnSjZVNGhvNWhNWGZUUnNkc0tucG00QllrSUFNZmRXRXdzUkF3bCthaVBLWkNIU0FWYXJlVXJMbC9cclxuICBhT0JaellCNXFBVGhqbGtLYi9UbjdZNFpKdjF2R3E3RWlPTjRqSm5rc1hhMjkrU0JpQ0Y1VUdkdHJqU0ZZZUFWVnF2OWdhRkFRLy9EXHJcbiAgdytrMjloWVk1VGZzZmthdzlUK1B0Q3BWcE0yUVcvYTY5QkhHNnFrL0JTVlIrd2ZQM3V3WTJTdm5aeUNKOEw0c1BZMU5KNHp0dzA5dlxyXG4gIDI5OUpneXRrMGx0WHVFSENwK29XelBuS2VCeGpZSFpDaXpaZk1PSUYzWWVHQVVjSW0vK2pSdXVCRVdsa3hoZkQzR0RHUzduelBqeFBcclxuICAzM2IxYWxYazZrdFBsTFBPUGo2R01FTVFqWkFuSXVnSERQUXFZZXdncFJGOHcrYkFHR3hHNFRDWWxwWW9iZ0lWYWNlM0ZVdWZ3c0JnXHJcbiAgSDc1ZTlKekVNTUxlWlo4MlVpVnU2dHRZVDZ6dHcrb3VXT0RuM3pFYnh6NkJlc20yalJudVR1YmllQkJFV05xVDJLc01wRnR2YndlSlxyXG4gIFR4T1ZVcmFzK0VsV3Q2V0lLVEV6RURyQ0haTWdjZGV3T1JTUFFUQ2JNYVN3TDNwQ3VNNnVFZVRCZlVOb3k1Uk4zMjV5UC91Sk1CR3pcclxuICBnV0F3TE0xRkdRTTY2YzFWaFpXVXBPc3dSZzV0SWlOdmJ5VGpuenRXVXNzbVMzSnFzbU1TVHNKdzViTHBxYnBzTHZoYnpqcjNhUG51XHJcbiAgeXhma204K2ZsNmJObTZxeGpQa1JHalh6VFBMVHozK1c2aldxeWJ6cFgrazl3b1NTM0xKNjlXclpOTVo3dGJRWmNwc2FNdGNHVStQaVxyXG4gIGZWVy94NzhpYWtlYkVNcEduZ3VHdjZBTU5YZU5mNDRXTU1aa1VSQUtDSkpHNXJ1TFVRWmIzUE8zNUgxVkduWlVWUmFTUjdnUFVKZDlcclxuICBXYk5HS1ZOWit1Zkh1bi85dk8wVGdqMEZvLzNHQTA0UHR2NW4wZWFJb2Y4STg0QlJJM1VBbURPWS9zbFF0WC9BTEV6cUFFZ2lzNzkrXHJcbiAgUUJyMU9VT21mM2FYcTdPZnFpaUJUZ2ptMEhEZms2VHpxWTg3UnVMelJLa2FpM1pjSDhGNVJOM0FYZmRobTZWbW00RmF6MVNmYTJZT1xyXG4gIGo4UkRtZlN4NXZWK3NuVHBjazBBbXJWdW5WeHozZm55em52ZjZMSFNFRzhVSmhJY2hqTnF0Qi9BeFVzRjNidjd1V2NnN2hucDZkc2NcclxuICBOelJxVkZkV3Ixa1hRM0IzSkJFd3VpZWVvN1Eyd3dqWHljN09pVEFiOXBPS1pYdk1Kd3lyWjg4aFAwZzViK2xaN0RwNzA0ais0MC9lXHJcbiAgVHBrSWU1V0JBTWdEc1FpbXlRSVphYWxTSVRXeE8xbHluT2ZTRGxWYmNkQW84RkxnbzhLM0cwa1N3TlVKcEJEbVE0Y1lscThabmNweVxyXG4gIEE5NVFDWUErbC9wSUh5a1pWYVNJa2JzYlRldkVVQW11aWcwRXlZTjV4VGN2SFNWVDNqaEhmcnF4b1Z1aW9tRVo5K3dzb3k2UjVXTitcclxuICBlMDl5cy8vU0JkQWg2Q1E4NXk1ZENIcU14ZU9QZUIzL3V4LzlLQmRmZEVLRVhPZHR5dE40SEFJbFZRSng5eHoyQXB2eG1Sc1ZPZ1pBXHJcbiAgMmdzSWdBRlBuTGFPbUVCd1VFZUJUY0VFUlVwa1NrcVV5TlR0ZklTT1ZLZDlPbFFONlhXNkhxVXpGVUtrc2hkUDhSSkxJSGtBNm01YVxyXG4gIHMwRGFkdXMvSDhJV1J0V1crem1tRWcxYzNOdUFZTGM5OG5hcDIzMXdzT2QvQnYrRTRUd2VNSksyanBHZ3htcXJETnd6RXBoTDlveHZcclxuICAxamM3NENMZGw5bXNwOW8vNkwrOEsxQWhjTXRHVldWZ2lnRkFuOEFEcjFpblp2YU1Bc2tVcnk4Q1V1ZDgvMmpVVUI1OENuanBWUTl5XHJcbiAgWEZXclZkK05vaGRJL3FaY1Bmek95M2ZMaHg5OUx5Kzg5SkVlTnh4NGdQY1NyRisvdHZ3eFpuSU1JWWFZUHZUd2E3cW1YdmlZWWZpSVxyXG4gIHFPZGovZnExdEc2aWV2T2M5RkV6U09QT2NVYndJMGNtamlybk9FYnFqaDFhYW5vVTJ1emF0VjF3TkRIc21xeG56VjRvVzBLSko0bXlcclxuICBEMC8rdGoxWU8wdUNIRm80RUlENHVVdkMxOXRUNU9ZWFNPUEc4V240UGZZNkF4bHlTQzlwRU9kZWhwNFNOVVdxSTdLR1NQcndQVUE4XHJcbiAgaVE0VFJPSWRBUE56aEpsQklxUlg5c1oyWEg5UllXa0V0anNQQnJFOTRMbEUvZXpGZjBXeUN1UDNua2lGaGRxS2VaNS92cVdGVEh6bFxyXG4gIFpQbjd1NmRqVW1jWEZmam5nUWNLaktOZzR5VDUvcXNYNWZNdnZQdWxnUW4vNmJBd0V2TGNtSzdUTVBTT1o3VFQzSEQ5dVU0YVBGZzZcclxuICB3bVNDdDB5R2dMOGY2U25WYTlXVFRDYzFiUW11ejhlUEFSMXNYREVyb3M1aS8vb0Y0NzJ1MnhFVjg1aURtVUJzWUFZd0Q5NERESUZ0XHJcbiAgVTIyd2JhQ3V6Y1NZVnFtR0kxQmU4bGo0Mit1cXhqSW0xKzVZYkNNamRUcmI5Q0MzMXViOGFKcjR2UW1ZU09lVG41SWE3ZmNOOXZ4blxyXG4gIDBYelFKZEx5a0N2L01kVlY3WTZINkRwN1lWUzFpdm9xZTlGa0hTU0FPYU0rVWw5cG1Bd3FTTjZadlF1ODdCcjFPVTJONTd4ZjRrRTRcclxuICB6cnMxMjBmL0czNldoU05maXFpdmtGYUpPeUVsRGpFZGpmdDdld2dESmdOZWhUTy9HQ3J6M2o5UDFtZXZsbkxsTStUMGt3OXpES1dtXHJcbiAgSEgvY3daSzdJVnFYZm02UjFTUWQvUDZIYlFjVk5qY0lkZmMvOEd3dGg0SDZoZStCWlZRZ3BjU0RjL0ZjN05XcnM5WmpPejRwWVR6d1xyXG4gIFNBb1Rad3pwOGFxcE1HaVRCYlJxMlZqVGp0ZzI2cTIwc29rQ2pMZUZYZE95K0pwcTdPK3BjeUx0bVZGL1VtQVgyUnNvelJpLzF4bElcclxuICA5ejQ5Wk1pUUE3UU1PWWZQNGhXVXZ5VlZkYVdHNHZ6WTZIUkRQRlBZTWF6THUzUExKRXY1Nmw2UGEwRnRPd084VDRETjJPZU44enNIXHJcbiAgbUVlVmhsNkZWYVZSVjZtczBzZTJHSDU3YTVuNjFobXFra0k5eFRxc25tSkJ5bmorNldIS1BPZ01kSlo0RVpUWnhjSjY0VGF0bThxMFxyXG4gIHdNZ0ZodDUyc2E3dE9KUGdQL0xvelZyZVVyaFoxcXhjS3ROZk9WRzlzTUoyRUNTUWFzMTdxY2RWV3FWYVlwTThrWmJFbUFLQWNEQ1NcclxuICBoTG1zbU96VkRTYXh3RXhxdHgra285T2M1VE4xSk92VkpmMGxyWEl0WlE2VjZyVjFCR3RvakRUQ3lKZ3krNlo5N0VmSmxnWWVmYnROXHJcbiAgeWJxM0FmSHVmczdiVXEzTmpxT0k5eVphSFhhdHRCeDg5VC9HUEdBSTFacjNWRGZlcXMwOWd6VDExYklKbjBtRFhpZnArMEVkaFNSQ1xyXG4gIGdDZVNDTXdGWnM5U3NWWUxaU0tvdjFCUC9YcmZBY280ZU84Tjl6dEYyNlF2TkQvbzhrZ1dBL29CVEFUUWp4YU9mRUhMcS83KzFra3JcclxuICByaCswNmkrcEtXV2tmTUVDV1RCcnJOU3BWVXVhTjYwblo1eDVqTmI3N1BPZll5TEo2ZWZubm4xTWhHakdmd3VrTnVubVJ2NTIvUFpiXHJcbiAgdlRRVkJxb2N2b1ZoYm1CMXlzbUh5NS9qdHAyZmhwa0ltUWZrc2NmZmpIdzM2N056WEx2YmZzc2NaN0g4VzF5YkJlUDR0T25SN3pBZVxyXG4gIDBEVWo5bmFPd1dzVmRteEFUd1I3SmgzYXQ0aTBiMjdGYTdQMlBCaDN4WW8xZXUveHo5NncxeGtJd012QTBVaEg3SUxtdDVaSVdrbHVcclxuICBaTTRCWUFGR0VLdUNrQUdYZWI1M0ZwNTE0SVhsOWYrMFpVaXJHR3Y4eGxDOFBlU3NtTzVHWnRIOCtpWjlvTDRxMnBoNHBqemNlS1BNXHJcbiAgbzB2RUE4dXJzRnhudTdPampMeWpuWXdZMWxhTjNveVdiTVJVbzNJMVpSU21uaklWMVJtbkh4bnB4S3h4K2JOdGd3VTZNV0tpMHpSb1xyXG4gIEVPdDh3TWRpSFRRdHJheGNkTkdKOHVjZmIrdDI4ZVlTV1R4amtzalVWM1RiQUJHWTlkVzlzbWowR3pJZGRWWmc1RFNDQU9IQWlJNTBcclxuICBwcW9wUnp6SXlVWFFvMGtmSkZCRVNpRnRPMHdaMndkcFNnd3dEaVFQWXh5Y3QzVGNwNnJHc2xnUnNHYm1iMDRxcktrR1hFQUN4bjhLXHJcbiAgRVBHZTUzL29Sc3VuQlh2K1diUTQ1QXBwZHVCRi94anpDQU0zM2paRGJnelVXTEhxcTlWL3ZMcSs5ZUZlM1ZtdVJtTmxHc3NkY3pHR1xyXG4gIHY5RjlMMGdzTUJINlFKM09oMG5kcmo0NGRQSHZiN3QzU0l4SFJkME9KOEgwTnBEKzJvZmFIT21sV3MxMDRKYmxuNTR2RTU0NVFwWXZcclxuICBYNkxNNC9YbmI1TnhFNkxaWW9ubVB1akFhQnlVcWF6dXZlOUY2ZFp0V3hYUkJ4OTVGM0MranpCQk5vVDMzeDRNcks2NzlpeGRoNEVOXHJcbiAgNHAxM3Y1YWVRZlEyNXh4MXBCOEVKOEs0OGRQa2xWYy9EYlk4RGgzY2R4c1g0ekQ2dVRiRFJEaDhiNnhMVTVlRkVhWUQxbGE0RGR1M1xyXG4gIGFyVzMzU2J5TnR0VlRKbzBRK2xzYVFQN2Y0YUJwR0JUU0hKRXFFUmpGVmlLdHFaRTBpUUF0UmNrUUZvUURiNnp5QS9tR0Vkc050VUxcclxuICA2cXZDT0tLL2ZjbkdzNktOeS8xYzR3WlVWTXdKVWphT0dSbkNYbGkvM2R0RHByNXpvVXg1NjN3WmVkYytNdWFoNklnQzZRS1FaZ1RqXHJcbiAgTjR4anlkS2Y1WmZoWTJNNkJiQnQ2eGdIN0w5dnBHd2cwQW44OGNja09YaFFiL2x0VkRUL2x0V05iN2REMTQ3eTY4OHZhcm5ZL2R3NVxyXG4gIHMrYktpaEdQNnJiK2ZNZmtVV01aTTQ0eWpxamtrVm8rTXlLZHFVcXJ1RWc2bm5DZk1nUnZCem5jMWU4bnZ6OXhyTXovNVFXVkFzbDBcclxuICA3S1VMM3c1U0JqQTExdStQSHh0Ulk3R3Z4d1d2eWRTUGJ0TTY0Y1IwcEJmL3B3QXh4eFcxNDhuM1MwcTVIZnZpN3c0cU4ya2xuVTk3XHJcbiAgVEZvY2ZQay95anpDeG5PRFo5emVqZGNZeWNSUEg4aHNmY1FOdW0vcHVJK1ZhZGpUMWphY0ZFbU1EbXY2QUZMbDhnbWZhaitnWEsvN1xyXG4gIHNiSmk0cGNhVE5wMDRBVzYzeHZWKzh1OG41OE9XdkpZL1B1Yk9rQlpOV2VNQnJiV3FGNU5YbnppZXVrOW9KYzhlTjgxT2dpaTM3NytcclxuICB4dWN4YzN0c3lOa2tUejM5anV6bkJrcE03QlEvQ3I3ckR1K1NURVpjQmsySllJTXB2Z2ZLOGQ4RllCOE1obnJSN3ljeFFlL1VxWlZjXHJcbiAgZTgyWnltdzR6OW9qRDVXZHV6MkVyMDg1SEZtK0k0VFB0ZDhFYk0xZ0ViUnI2MVgycFVrTnU0SnBVNzFVTlREd2RvdkhQOEpBamptaVxyXG4gIHZ4cXNndW5TbmVUQkRJVmxwQXp1UUR0QTRTNUlJQ0NqcWlkNFd3bzNSVVpFRWJqTDVhN3hEeUF0Tk10WmFiQnJZeGkzcjRtNU10TGpcclxuICBYSG1UOGxmTCtLY1BsT2tmWEM0elA3bENwcjEzaVdPWS9oaVNCZ3N3MVJSQXdzQ21ZUytlQlQybzVhd3hXQ2UwanM4Ni91T2dZMkRrXHJcbiAgd3dPRnpLRHhPV3JzZzhRSG5ycld3WHIyMjFjR0g5cFBISC9YbjVlVHMxSG1QQlFZNHBQS3FCb0xBbUQ1cjRBbFY0UTRtRDRkb05MQ1xyXG4gIGpSZkFQQ2liSkFKZ0dGVWFkWklGSTErV2xZNFFjWXh6WUJJRGJoNnVSTTJZQ2Vmc2U4S05xMlo4UE5ReEhYTzVkdGQyeDQxeDJHeDRcclxuICAveFFnNnEwUCs3Y011bnVxTk96enIyRHZuaU85V2pYcGNOSTkwdnZ5YjZTbGt6NytFNUlITUVZU1pob21mY3o3NU1ZTnpOTkJuamNjXHJcbiAgSGxvT3ZrYU43THd6ampjZGNLNUtIakNLT1Q4OEtTUHZkY1IvNm8rNnJlMjRZOHNjMDJFN0hLdlR1Tjg1c25yNkx6cVlvdzhCWW9wU1xyXG4gIFZ3eVhwUitlSll2blRsZXZ2YmRmSGlvRER4NGdkN2grZmQwTkR5dnhwby9HUzlLSHVNRVJxaG42TWtrSTdkc0E5ZzJoMGkxeEExVmpcclxuICBBR0dRZW9QKy8vd0xIK2d4azBMaXdURnJMOHBrRXRPcWI3OGJGUnlQd3M0dERYYk1WRXpBN3ZXdHQ3L1M5YzZvc095YytQWnNQVDZ3XHJcbiAgZlpoNmJXOWdwWk5tZUJMUW1rVDRSeGhJaDY2ZDVLMVg3cEJtVGVzcnNXSnVxZlNzOFpKV0ptcms5aW9zLzVMQ01RZ1JKSDUvRHZFSFxyXG4gIGdtMUh3Y1B6cTVzTnBId056NDBMTnhCNEV6bzNOTG9GU0Irb25wUjVPT1N1OWNicHpjdCtsOG12bnlWam56aEV4angra0l4NTdBQVpcclxuICAvOXFwRWFNM0tpbVlCSFlORnFTTUVyZXdqbGRQNGFsaEw5ODZBLzdrOGFCRDBObnB6TGZkZWxIQ2pzL0g5dHR2WHZKWW1tQVV3M1Z3XHJcbiAgWWVRRHV2T3U1NEs5SXJWclZKRjY5V3JxTzRIbnpWKzRVR2JjMjBLcTFZc0dFOEpFQUhOOHFGdHkrTEc1SlZ4SHBZc1E4NENadEl2a1xyXG4gIFdKb2lUZnFmbzZvUUE0ekk3Qi9HVEtZNndwYlJmRkF0dXd6RzlERlBuNkpTckNWWEJEbkxZaVhFZndJUStQYkgzcXZTUXFkVEhsSUdcclxuICBzRHVvMmFtUGREcjFFZG4vbGorbHplRTMva2NZaDVmcVNwYysyaHgxcSs2YjlldDdsZXQxUDBabWYvdW85Z0dPazBFWjlSV1lQK0lsXHJcbiAgSFRUQlJJamRJbWNXODhQdzhyR1hnSWd4ZmNadzNVWmlYZmpyeThLVUFRdytVR0dCMWROL2ttWExsNnNiZWVOR2RlU0JPeStSQVFmNVxyXG4gIDJKRGhybyt1WHpNNjhrMGM1Z1kzQmhzMGtUK0s0OWhId2lDb0xYdkRSbzNwNEZ1S0gyU0JuMzhabytzTHp2K1h0c0ZpMzEwWTRYUHRcclxuICBXOE5aSlJGT092SFFvT1JScVZMcGM3dkhnMjh4N0RuSnZleTduZWwxUzRNeEROb0xyMkcyd0lJSHd3eHJkekY2Vk9MQWFNTS93a0JBXHJcbiAgejc2OVZCeEZmVVhrUHZNYVZ5K2Y3RDJQM0w3d1pFMWg3Nmx0cElpZGhUS0VyZTVEV0NCNVFmNmUzTkNrVHp0Q3hicHRKRy9kRWltZlxyXG4gIE0wa212WEcyelBqd2FwbjU2VTB5Zjl5WEVlbWlTbWJWaUVSaDBnV01nZ1cxbEhsTzVRZmxlT2pVbXU1bHM5aEhrNmhEMDRrNXp2cWJcclxuICBiMytWZSs3MXFpY0Q1NXh3MHJXUmMrdlhpNDJXeDVET3NXZWVmVS9YWVpmQlUwNDdTcTV6SW5qdHVqVWwxZjJ1Z3Z4Q21UZHZ2c3g0XHJcbiAgdks5VXJOZFdDY0dDa1MvcDJuNTRSSjNsaUFZTWdBWGdmUVBEQ0RNUFl5Wkx4cjZ2aG5ES1lPV1U3M1dFYThaNDlqTWlObWFDVWJlblxyXG4gIGswTEd2WENPN2pQSm8zYm5ReU8ya01nODdQOHdJUFpJQzYwT3ZVWVpBTXlFcGZuZ3N5V3RXalFyUUJnVjZ0V1h0c2ZlRktuYjdjelhcclxuICBwZFhncS81akVzZXNieDZKVEYyTEN0Q1lobys5OGRJSDlwRDVUdnJBSTVMakt5ZC9JMjBDWmw4aG1QdkdKSmM2blE3VlRBUklHU3dyXHJcbiAgcDN5ckRLTk5zSzNxS3ZjdVRkTHd0ZysvWGFsZU8zV1RCdGxqbjlWY1ZwVXJsWlA5KzNXUmRUblJmRThqZmgwdms1MWtzV0xsV3ZuVlxyXG4gIERZWlNuVFFSQnYyZkNacm93MFlrRFhnaEhUbGtmMVZmMmJjU0QxUmZ3TDYxUkFpZlc3RmkrVWpkMGFOTG44Q0srN0Z2THlkblU4eDJcclxuICBJdGpjNWRSNTVOSFh0MkYyYjcvemRWRGFQbXlxM2ZoblliQjdPUG9vYjc4cHJkNnU0SytKTXlPdXdvbndqekVRc0UvSDVocFVDQm5LXHJcbiAgV3AvclJ1MjVzaVh3R3cvUGZ4ME52dHU2L2V5OE5rU05nZDhaem9kVlRqMnhZaXVYRDlKMXhDT3RhS1ZVbVBtTUZFMTVUZkwvZWw2bVxyXG4gIGZ2dTBiQ253THJub0ZNMVRDdUZwVTlZNktjbUxkVCtHWWNBczZCUjBQdlMyVm80SEw1aGpMTmJwRXRXemZheFJUMjFPTU9uTXhSZWVcclxuICBvTWRwSTlGSVkrQUJaOG5GRjUyNHpUSHF2L2ZwTHpMNGtENVN5ekVSbmxJWjkyZlIvSVd5L29laDByQlZWdzBVWkc2SStiODhxK2NvXHJcbiAgY1lENEIxS0hNUUgwMm9uVVdCTmV1MGlqMS8zc2cwZ2FJMlRtbC9mcE1RaVBUNjNoWFhZQkJPdXZWeStTakJhRGF1V3Q5cElmVXNqd1xyXG4gIHUzd3dXZ1hIM0VGeTJYUTNLSWkrNS84RWpKbXdkRG4xWlRuZ2xuRVJKaEZlK2wwN1V0b2ZjM2VrN24rS2NSaUlYV0lpcUJudTJacWRcclxuICBLa2I2T1BJV1plalRmM205Y3BNQjUranhWZE4rMXVPOEQ0WVlsQUhiekhtKzN4V2ZhQjBZaHpHUzZaL2RFZGsySUpFYWtEd3NFSFhTXHJcbiAgblkxbHpabzFVcmRPRFhudDJadWwvOEJlRVdKTjN6M2hlQytabm5qQ1lPMm45RTNESFU1cU5rTDd3NCtKcHpiZ09Pb3JKTlg0NzRqdFxyXG4gIGxpMDlVN1J2TGR5K2dYMTJMdk9INzd1dmo1WlBwRks2Nis3bnRhN1Z0emE1ajYrK2pqNkRlRHoyMkJzUmFRZ25tWFBQT2RZeERhKzZcclxuICAycFNidDgwQXNEU2NjY1pSdXJadk9yeTJlK0o1RURPRC9URFI3OTFWYkhhai80TU9pcDAvSm94L2xJRVVKL25ST2dOWk5hWnZORU5vXHJcbiAgbUxqSEVuby81dDBSM0RuQmFXYjAxWHhZc1UwcFNGSlhka3UyRkM3MVJyRXlCVmxTWnNLak12Mk5jMlhtQitmTHBFOXZrVDhuanBmbFxyXG4gIHExZkkyZzNyWk4yR2JCVm1XREQ0RlJWc1VZK1JuNzkvVHZLTC90WWxYalZGQjdJUFk4Z1JBN1ZjMnN2akdBc3YzQmdKd1VqeHNNN0pcclxuICBZbTJIWVowSGZTZFJ0UGF4QWM1aGRNY01hNHhDV0t5RGdTdXZPRTNPdStCRVpTS3RXamZSZHdQbXo1dnRtTVp6a2p2dUphblNPQ3JDXHJcbiAgUjlSVklVS2hhaXpIRUxUc0dFRllqWVhLaWhpSE5iTitDNlNNQWRMdjM5L3JNUndwdUJ4U0J2WC9lUElFSlZ3d21leUZrMlNmWTY5ZlxyXG4gIE10SXhEck9Qd0dUd3lGb3h5YnNNNDkyMUpkR2MrdjhoaEJsS2VQbFBNNHd3cG4xeVI0VDR3d2lhRGp4M0crbWovZkYzeXV3UC81MjFcclxuICAxWDFoeGxRaVRDQ1FORTM2c0c4UUZWWTRYNXRLaGU3RDREeGN1RTBTUlVLMXBWN1hvMlhKZTZmTDJGdnJ5dUlsU3lXMWJLcTg5OW9kXHJcbiAgN3IxWGlza2tTLzg5N3RoQlVxR0N0OTg5Y04vVnVqYmNkc3VGMm0vcHl6aUxoTCtCbFU1aUFlekxXcmRCUi9qVUM0UHQyYk1YNmpxZVxyXG4gIDhJZUJoRThkVzd3aE9qRVZ1dVhtQzRLU1oxQm1BT2MrRGovTTk5ZEV1TTBkdC94WEJPVHhIRXc2T094UXprdEF1T0lRdnZmV3JYMWZcclxuICBzelpnU0VZUFRGMzk1RlBlNjNKUE1NVkpoendKUzVPU0NNbERiN3ZZOTdKL0FBVGp0R3ZUVkg0ZjlaZDI3SnljWEtsZk5Wa0swK3BJXHJcbiAgU2xvRjk5eTJxUFNCeHhTVDBEQ1NJRDRCenljNk5kc3NpY3VPOTdtRmN2NjZ4Vkp1eTFvcG0xRlI1MkN1V0dhalZFZ3VrTm0vdlNZYlxyXG4gIDV2OGlLeDJ4MjdoeW1xejk2MHRaTS8wWFI3QjlCMHpDMXpoQWNYNnhJMHp1THQyN3hOTTJOVGxGamR4RmhaT2xRa2FxVEpxMklQTENcclxuICB3bGkwYUxtT0RPd0ZaMmR2bEZtekZ1aitSTkdiSDN6NFhjVEl4WEU4VHc0TjZYNEIrMm1QWTF3VEkrRFhib1FUdnI1MWNaZ1BMb2RzXHJcbiAgaDYvSCtjMmJOZEI5SE1OZ2FTT1lqejc2UVdyWHFpYnRPN1NVQ1JPbXkvNER1MHYyeGp4Wjd6N0c3T1Z6cGNTTk9ncVdqWmNOODM2WFxyXG4gIGlrMTZTZm5xaldYUnFOZlZqYmRHbTRHcUIwZG5EbU5nUDJYcWtENW05ZC9mUzlQOUwxUm1NZTBUVDR5SWhFYXRnb3F3emVITTg1NGtcclxuICBpMGEvSlkzN25pRlQzdjEzUVB5U05IbGY2MlB2cXJ4NDVBc0ZHVFdicDdRLzluYjU4L216cEVtL014MGhLNnVxenJRS1ZWMDVWdFh4XHJcbiAgZnhuVFBrYXRkSXQrRDE2eXUxMVQ1UC8xK3FYUzcvcnZsQ2tnTWJiclBtRHh0L2NlVlFjdk1KakN1T2RPRDV3WnZLMkM4M2huTEx5dlxyXG4gIFJiKy9MWlBldWx5Nm4vZXFuai9ETVpQMUMvOVM1akh5M29INlBsQlhtYTNEcTdLU1pOUFhGMGgrWHE2c1hMMWFLbFlvTDhjZnViOWNcclxuICBkdFhaMnBlQjlXR0MvdHEyYWFieEYyKys5YVZHWjlzeEJrT1ExRE5kZjdXQlVianZ3M1NZbVJCdnhNR0g5Slg3N244cDVqamd2REtPXHJcbiAgYUdldno1SFRUeHVpMzBINCt6Q1FIaDVQTDlSc0JDcm1CakVVaWVvUzFFdktFQmdOM3pkcFR4TFZTd1RxMi9kczV4S2poUTJGMzlJK1xyXG4gIHNGK1VoamZjdVZ3WHRHL243YnAyYmRxQXlITnZSZ2ZRaENSS2ZyZ3JlTW5SblYvY1FQUU05L3c2ZDQ2R09JVHhqMG9nY05yQkIvVlFcclxuICA1bUU4ZHM2Y2FPUTA4UUlnSEw5Uk9XMnpKT1hNbDJTZDJkc2h4SnhUcE1qdDN5eGxwVURTU2paSVN0RTYyVEwvSzlrODcydkpXVGhHXHJcbiAgc2lhK0kwbnJwK3ZjemZQKytFamRpREYyaythOFRHRnhaS1JkcGx5cUxtR1VMWjhxeWVuSlFuYmJINzUvUmZidDFVWHk4aWJLMjI5OFxyXG4gIEprY2ZlNGhjZE9FSlFjMVk4RkloMWphQ0lVSVZpY0JlZGp6K2Rmd2hrWHFzNlZBRU1NV0RFUVVqR3o0RUVsU0dKN2tCR1BsSVowQWJcclxuICBUTEZwSXhDRDJVRVlmYkVlN2pxQ29XK2ZMbHFmL2JnazFtdFFWMDQ3ZFlnR1hUSERZbTRlekNUYi9mNDhXZnFPVHp5b0tpeTMyUHdRXHJcbiAgTUErQWVvdDBKNml3bHYzMXVhcTE4TUpSWTdvYkFmZTQ2QzFOd0ZlN3d5QTlCNG1Da1N2TXdLU1FFWGNQREFnWTlwV1Jzczk1YjZSYlxyXG4gIFFDSFIwQkJKdkxQbS8vQ1U3dnYvRVlzeVNjbktQRklETi9tZmgrMG5SNy9vWGIxTmpUWGlqV0VOU2UxRCtkZDdEbkNNd0Q5Zm0xSFRcclxuICBwQThyMSs1d1NLU09JYk5wRDFWZjhjNE5OZ1hBbER1Ynl1eFhqNU9GQ3hmSWtpWExIQkdySzBjZTFsZjY5TytoOVpqQzFhUUlDT2g5XHJcbiAgOS9oNVN1aURIVHEwaUpFd3ZuU0RKZm92ZmZTbUc4OEw5a1p4em5tM3Fkb0w4TzJGenczanRGTjltaGpxUFBCZ2JOd1RZRC9McFplY1xyXG4gIHJQZUJzWjExZEhnV0Myd3VBRWJDNzZFdTl4aVcvdVBCd0EyZ3FycjVKaCtaNzY4aDh0NzczK3JhZnN2MmNQVFJQcDhaOXd2c21yYU9cclxuICBqenEzWEZoN2dvSWc2ZVNaWi9yNG4zaWdXdjlIR1FqbzNtZGYrZVg3WnlPdnBFS0ZERms5NlNOWlBmRURXVDludUt5YzhLNnNtL1dUXHJcbiAgWlAzOW5xeWQ4cTRzbVBDcHJKenptNnljK0xhc252Q3FwQzM5V3RLWGZDVko4eitYdkJsdW1mS2ViSnp5Z2F3YTk0NHMrUFVGV1RoelxyXG4gIGlxeHlvL0ExV2V0azNmcTFiaVM5UWZJM0YwbXVXOVN1dnNYeElNZkJDb3FaSVp5UHpZbjVlWnNqeS9pUmIwWFVVZGd6ek5YMjdkZnVcclxuICBrcVVMbDhvcHB4OGxUeno1ZHNLNWtlTmhIWklSZ0pYallhbEp5S1ZqeC9zbm1Lbk1aditDd1JBTDBpL09qUTczeFFiMWEyc2VIZFBiXHJcbiAgaG1HZGRKOTlXdXQxdUliTkVXREhBSEVrZkFRTjY5V1FHMjg4WDJyWHJpWXBqcWhnbk55NnBVUjEyTXNmN3hKUll6SG51U0YzOVFKbFxyXG4gIEFPUkhJcE11akFUTS9lbHBxZFBSZnhTTHg3d25TOXhvMXF1M2ZHUTZoQXFuaGJBdGhQMERiaDRoSSs4N1dDcldiaTUxVzNYUG11NFlcclxuICBSOU1CWitzeFBMRGFPSWxrNXFkM2Fic2dhKzdZb1BSL0V6RFdkdTZaR0ZvTXVqUmdCSjd3ZjNsNVEzWGh6Y3lRMmFpeGhqeTdXbzl2XHJcbiAgS1M3VWQ0QzloRUZXbUhGWWVlNVBUMFVTS3ByeHZFNm53VzZ3VjFOYUgzRlRWUDNsVVBUVFZaS1R2VjdXcjgrV3RQU3lrdW9HWitlZFxyXG4gIGVaUk1uYmxRem5MRWh3SE85R0JXTy9EYTY1OEpVNjFDK0dmT25DOFQvb29HRTRJakFuVVFOSU1vOGNzdTlaSHZocGRmdk1QMzZhQWZcclxuICB4eFB3dSs5NVFkdTJPaXhYWEI2ZFk4VEFmcjRqem4vMHNUZTBQdEordjM3YnVxeGlId0djQXlQaDkxQ2Y3N00wQmdaUVh3RlVWUVQyXHJcbiAgY1E2Z25XdXVQak95dlNOOCthVlhGK0pzQUV6aXNyV0Jiem04M2hQODlFTmkyNU5oNWNxc2Y1NkJnRjREKzhqQmdacG0wNlo4U1U5SlxyXG4gIGxncnA2WklSQkw0UU40RW5reUVrZE1qaWxTdGwwWW9Wc21MTlNzbmFzRmJXYmNxUkxNY2sxbVZ2MHJsSDNPQkxtUUlvVURYVUZzblBcclxuICBkWnpSN2FSZEpJdlV0R1JkSHp5NHJ6engxTzB5Y2NJSEVYdEdtMDVSdDdwd1FyUFo4NWZLdkVVcnRIUFpDS1UweEIvam5OSmVZT2RPXHJcbiAgcmZVNFlyTUJUNDU0L1B1NjJMdytIVHRHNTFJMmNJMndnZjNsVno0SlNoNkl6SFJjNmpHaWl4K2wwSGxoRkdEQmtsVnl5eTBYeWtkdlxyXG4gIDNTZDE2dFZVWXh4Z2lzK1pzMmJKakdITkpQZXJ5M1Fmc3hMeWppeVJKYkV5TFE2NlRDclhiNmRsN0NGVm0vVlF3ay9VZWpOM0RNa0NcclxuICBDY2FrRUdhT3BBMlRRaXd1aEtseElZeXRqbitnMnJycDN4Y1ViRmd0QTI4WkxyOE04L0VvclkrK1JaYU8vVkRMcE90WXZ5QnhmcVAvXHJcbiAgMTdINGovY2l6QU1KRHJVVERHREQwbW5LQkNnM0hYQ09ERGo5OXNXdm5wYlowbUpCWm4zOW9ESVYwdXZiZDJhTWc1NUFObDVqSE9IdlxyXG4gIDBFREtreklwZm5TN2NOVHJNdjdXK3JKczJUSTNnTXRXMWRLN3I5NnBnN0ZOK1p2bHNNSDl0SzhUcXhUR3NEdWZWZnNjL2UrcnIzK05cclxuICAyQWRBL0xkVHJXWnZxVm8xbXJHYjR5d0d2cjE0QXM1STN3Z3pheGFZV0R4UWZlRUd6UGxYWFhtNnRvVVVvcXJ5T0pCM2p1dGF1OVJsXHJcbiAgK2ZHbjMyUHVKeDVJSUpiRGkzYkpsMlZ0K1BPMnZWWWltRnR4L0VEU1lEVEluc1V4Z2NTeUp4ZzNZWnJVcXhNN0pYRVl2TmQvMUFiQ1xyXG4gIG96RTlIYnJPQzg0K1FyNzdjWXdicVRqaTcxNWNnU1AyNllFcUNlSlAvSVRHVURocFlYT1JMNmNFZGdwVVVWc2N4N0FseloyWDdCZ1JcclxuICB5NVl0MkVKU0pOWHhvOVN5S1VKQ3duNjllOGdiencrVmY1MXd1SngyeWhCNTRiazdOTlhBMGNjY0pOVnJKWDRvSkd5ekY4RjlJMm9QXHJcbiAgR05CRGpYRW1WZGp2Q2VQeEo5NlM3NzhmcFRZR3ptSE55Q0JSM1NwVkt1cHpxVld6bWw2TE9oQjZSTTc0UUNvNjJFTHV3ZFZEY25uZlxyXG4gIGliemhFUWZ0MEliZEYvN2Y0ZU9mZnZhelk2NUplb3g2WjUxemkrcVZBZWZ5b2ZMN01CeE9uVFpYRFlIMUd0V1RMdTJieXc4L2pkSHBcclxuICBjbm42Ulp1TEpXL1RScldOcEdSTmwzcE4yMG1sanNlb05NSlNzKzFBWFpObmlaUXgyRU9ZWjd0UzREMkY3bnpCTDg5TFcwZndGb3g0XHJcbiAgV1dNNzJoODdWTmJOSHk5L2YzaXpETHg1dUl4NzRXekhkSHBLaCtQdlVvSkltOVhhSHBneTVyR2ppcHNQdXJ3TU9aMm12SGVqTk9oNVxyXG4gIG5NNEx6NXdsYVJXcTZXeVNlSTFSL3IrQ09kOC9xY3dCakg3NEtMVjFBSjdiSWZkUFV3WTk3b1V6NVYvM0RsODU0bzFoOVhDRDduL2pcclxuICBqOG9vU0t2ZjQ0SlhaZUhJVjVSQndEaGc3dFNCQ2VITjljdXdYdEwzV3UrMEVQRzRpdU1tdVc4T2xEbS92UzByVnF6VWIrNHlOOGlxXHJcbiAgWGJPS1hISE51ZHB2aVVFNjc5emp0RDllY05Fd2VjbEpEWUJqZUFuQkZQaE92dng2aE54NWh4K1lBSTRQLy9sVlhYTWNOL053bjZiY1xyXG4gIHVWTXJOU1JUQjJrREcwY1l1TXJ5cmR2M1JUNm5QbjIySmJ4OStuU1J6ejcvUlFraDN5RGZCTjl2b3UvV3ZtdU9jVjJqYmN6U0Y3Ni9cclxuICBlSEFQeTVhdTBycW90ckdQc2c5dzNwSWxLM1Qvam1EM0ZMYWpzSS8xeEVsT09uZlB3K2dBNng0OWRqMitKQXhzUW5mZis2SmNmZFVaXHJcbiAgcGY0K3RETC9FUW5FMEsxM1Q3bnlraE0wVSt5d1laZEkvYm8xcEFRYmhWc0liSU5YNkEyNXpzcWFmU1Z1cEZMa0pBcFVVU21PR0VMUVxyXG4gIHRrYkRSaFFwcVZ2bHljZHVsRXZPTzFGSFB4cVA4ZTBMMHIxM04wMDlFQjdCYkEvMllua0JkQkt3Yk5scTNjKyswa0NITnBIWlFOa21cclxuICBmWWtISTVId3RUaTNORmRGUmtiVVNaUlprelpPUGYwR1pRU01iSGpSNFh2WTN6R0hPd01iU0hnL3NPc0RHT1NTSlNzakk3KytCK3puXHJcbiAgeFBTQjBxUnhYVW5QY0Z6WnZZZDh4K3hYcmw0cjh4WXVrcEd2M3lTVDdtd2p5eitJNWhWaThxSE1SdnZvNkxXNGNKT1VMWmVwYWkra1xyXG4gIGtNekdYYVRucGU4cEFTTTVYNk8rcDJ1NWF0UHVFWWtFZys1dkQvb2dMVlF3dys5Q1d1a3Y5WHVkbWpMKzVRdTBYS2x1NjRnOVpNT2lcclxuICB5VXI0MGlwV1UzZmhUWUg3Ny8vcm1QMHQ2VkE4d1ozeDZWM1MrK3JQdFB6QnFVbHkrQk8rdjQyNGU0QWNkT2NFbVQ1aFZHMVVWMzMvXHJcbiAgL2EwK2I4bzhXNTRoL0tEVm9kZEdwSSt5RlgwUUxremRNV3d0bDRabFQrNGpvMzhmSzZ0V3JaSG1qb0FlZXZCK3JwK2t5eHR2UGhUVVxyXG4gIGNLUFhjVlAxRzJMaFd6VFVkQU9uTjErL1Y5V3Y0TjY3cjlTMXdZaVY1YjQ2MUVreFlkQ1BHYkFSSDhKM2MwdGdWd2dEb2tmU1JQdUdcclxuICBUZTBUaHFtczhFamtXNkF0LzAzQUdyWUZ4K3ozV0YzSzhkOVZHRFlMSWJtcDduQlNGekFKeE00ajgvYU9ZSFlVd0xXQmZiK3NtY2tSXHJcbiAgTEFqaVJNSVMzTzdpazQ5L0RFcWw0NTMzdnY1bkdRZy9MdjRCWDNuZCtYTGdRZnZKRFRkZUtNTnVPVitlZS9aMmVmaUJhNlIvdjY1eVxyXG4gIDAvWG55NTFETDVhTHpqOVc3ci83TXJudDVndDBtdFpubjc1RlhubnBUbm41eGJ2aytXZUh5Y3RPc3ZocjFEc1Iyd1VNbzAzcnhqSWtcclxuICBTSUFXZnJGMHRnNGRXdXEyUGZUdGdYcU1UT3hGMldRdm5Oc3U4SDZJUi9obGh1MFJpeGV2Mk9iM0ErWW93QXZEUUIwTC9vbUg1WU95XHJcbiAgRHl1K1BWd0prU28rLy94bjljWUlkeDd1eDZMVTJZOGE2Nk9QZjlCdEErMHhtOXZYWHo0amwxMXhUN0JYcEVhdDZuS1hHeG5lZi85MVxyXG4gIGpobWtxeU1FM3haM2s1K3pWaFl2bk9OR2RrdGszcXZIeVlMM3pwZk1MVXVsZU5Wa04ySzl3MGtoUG4zTTNKK2VVZUlFeGp4MVltUVVcclxuICB1MkxpVjVKY3Rwd3lCV0RxSzFSY3d6R29PMG1GOHFpSGo5UnkyVElsMmRoRFRHVXo1NGVucGI2VFJBaUlXemZQcC85R043OSs0WjRuXHJcbiAgai90dkJvUy81V0JQY0hrZWVGK0JYKzdzTDkzUGYwM0tWYTBuMzEzZlRwbEV3elpkWms5Kzl6cFZWNkVpSkE3SHlrWWl5Y2FiWHJtV1xyXG4gIE11SnFRZFplVUQ2SUk4SHpLbXpyeUg5amY1azVyS2xNbmZ5M1R0RlFvMW9WNmRHOXJiejIrZ1BicE9RQmZFUDJIUm51dXVkNVhUTTFcclxuICBxeEZrUTdoTS9OT0FBODZLVEFnRk9FNC81bHV3N3lMUk4wMDluRU5zUUhYOXY3MjBGZ1lETTdLRWM1ejZ0dDVlU2hIN1BkaEpxRXM1XHJcbiAgMGZVTnhocHF1MitKakJLQUFXMzRuSjFKWVdKMmxPKys5eFBBY2UzdzJ0QWtrRkx3VE50VFdEcjdjODcybVpKQmVDWkhKSlJ4NDZmK1xyXG4gIHN5b3NZS0lXeTNoM1FWUlp0aTluVTc0Y2VkUkIwcU5uWjgweDgrU1R0MHJ2UHQybGZJWHljdElwUTZSZi94N1NjOTk5cEV2WDl0S3BcclxuICBjMnZwMExHVmRONm5qVnZhU3ZXYTBiUWxZTkVpejMxcGw0N0RHcEI3bndoVFhQNjROaDNGamlVQ2RWNTYrV04xaTdOcElhblB5eXBmXHJcbiAgTHFQVWMybVgzOVdzbWYvNEtJTkVIWXo3d3l1RWMrakVrNmZNMGs0VzN6WWZPa25hMkcvUERPWm1kZ3RBcDhGMW1HTjRkaEhORzI0SFxyXG4gIDIxSmhRYUh1NDE3MjZYYWMzSHJ6aFhxTVovUHhKejhxRTlMSmROeTljRTNxc3E3Z25oc3pyaVVuYlpWMjdWdTRkOUZKTm0zY0tLdXpcclxuICBOc2dXTjNMYXVtV3J2c09OeS82V3dtVVRwR2o1QktuWjcwcHBzTzhKc25xNlkyaDFXanRwb2JFeWxQYkgzYUdFQ3BkZm1NcldMY1U2XHJcbiAgSHdobDFGOHp2M3hBQnR6NGc0eDdBYWttU1hwYytLcU1lZnBrTFhjNCtlSDBtUi9lbUpkUnEwVnFrMzVueU56dm45UllrSHBkaDBqV1xyXG4gIDNERlNtTE5HZytpSXhONndaS3JHamZ5L2hoV1R2cFdtKzUrcjVlbWYzQ0V0RHJ0R2twUExLc090MVhhZ3hxSWdxY0VJZXA5eSsrelBcclxuICBieDNZRW1tUDV6dlMxU0VlcXR0NUw4bW9odzZYOU14NnVuL3VEMDlwWm9qRzdwbCtmWGs5WlREWXI1Yjk5WVZLaHNUNlZIVHZjTzFMXHJcbiAgQTJYbGp3L0p3Z1VMZEg3OU5QZDlGaFp2bG04K2ZsU3ljNHVrYlp1bWF0c3owSytQUGVZZ2xUYjRibXp3UTlrOHJMNys1bGNaNmtibFxyXG4gIHFLc01Bdzg4V3dudFl0ZlhjYTlsa0dYbkFzcjJiWk5ENmhRbmZWL3RHRUVZUmxUcHYvUjM2aWI2NWtrRFpNZXR6U1QzRCsreGVLQjJcclxuICBldnFaZHdYM2U3eXZTQ0hQT1Z5THRzUDNHQWEvQXhVMDEwSER3S1JWbFNxVmwvTGxNL1I3ZnYyTkwwbzlOd3drRU5yZ08vWDM2YjlSXHJcbiAgN0NGb000dzJtSG9MK3JVejdXNFBOOXp3c0N4ZHZrWWVlUWkzZXcrWVJ0bkF1NHRaRmU5LzRPVi9Yb1dGZjdjaE45ZW5NU0Q0Qi9CUVxyXG4gIGVBSGdvZ3VpYnJMaC9UdUxFU045aCtBOE81YzE2aG13dlVqUk1ENzU5Q2Y5SVBET3NMYVk5WXdYc3IzN1ltVEVpSVBqcEI2aExrdHBcclxuICBvRDBXdkZRWXlTUVNPem5mdkZjNHp2YW9VYkZHWS9iWkpGSmp4MDZSZXZYOHJHc0dSaENreVVha1ovK2pEMThmRWEzcjFLa2hpNWVzXHJcbiAgMVB2Z3crQWFkaCsweDJocDdKOS95N25uL2tzYU42cW5CT0gxbDRaSnd3YWVRT1BFZ0VxeG9IQ3pMRnE2eGtsY2kyWDY4MGZLNk90cVxyXG4gIFNrYUpmOGQ0V2tISUlGWWs3NE13emZ6aVBzbGVORW1hRGp4UFZrNzVRYVVORE9KZWxUVkNKUkxLQTI4aGxzU25mKzk3K3gvbFJ0emxcclxuICAxVjA5TDM1VHMvMHUvTzBOcWQvaldObWNteTBiRnZ1Y1lwVWJ0SmNDeDFEK1h3Ry9GOG1qVG1mdjFUYjJ5Uk1kb2I5Tko5MkNlZkE4XHJcbiAgWVFhb29waENHT1l4K3UxaExkZk0vRFd5SHpWaTMrdS8wM2ZCdExJOGQxTmRRUUFvOTc3bWExazE5U2NOSGtRTnlYV0xwNzRwNjE0YlxyXG4gIExLUCtIQzhMRmkyVXJJS05jb2tqMkljZjFsZHV2dUVDK1duVVpPMjdZVFVNUkpWOWllSWFZQmhEUTNOMmhNdjBhN1puenZRMkFvZ2hcclxuICA3Y1RER0FSQmZXKzlmcStXdzhCMTE0Z24vWjFVOExRWGoxK0NUTmdzRUVZSWZHblNBSUdMM0F1QmoxemY3b0Y5aWU3UlFBcDN3NkNEXHJcbiAgOW5QZlRlMFliN1RiYjl0Mi9wSkVNQW1FbEMvQXZsRUxHclRmWi9kaTBzNmVnSlQxclIwVEQ4TThRd0dwWkZhdStnOTRZV0hBTXBpT1xyXG4gIGpvbnJkNFJwb1FlOU14alEzeHZKc0hmWUF5MG9MTkl5bmNRNjFZNVFwM2IxeVBtc2VWbmR1MFVucmJGMVBIaDVkbzNlUVVwcXJwdWJcclxuICA2d09UNGtFN0xOUUJwZDBmaEIzWWNlczg4ZUNGWWdnblJVSzREcDR4K1FVRjBxTjdlNzBlV1pKdkR6NEFjTHI3NE1oMENoZ1podlhGXHJcbiAgazkxK1BxN3dkSjNkZW5XVEx6NThWTTQvOTFnNS9iVERwVjZET3BwMUdScFNWTFJWMXEzUGtlejE2MlR1VjNmTHZOZFBsRllOTXBVQlxyXG4gIFZHN1FRVWdmRGpIRGpaUjVNUllNZjlGSkVIOUVWRm00K1ZKR0JRT3pxTkdtbnd5NFpZVGFRMmpqWDI5djFmMTVXVXZWTTJ2MTlPRXlcclxuICA4NnNIcFc2M0kxV2R0WENFOS9WUHIxUkROcTdZY1IvN2J3ZU1BNWpxanUyZWw3Mm5aZEs4aEptSE1vbFRoeXJ6Z09rZS8rWVczWS9kXHJcbiAgbzhzWlQydTVja092WGtWcVV3bkRQZE0yN256YXdEdkw1azdQbnY2dEZJeDdWbGF0V2lWL1RaNmlPZE1xWmxhU0h6NTVVaG8xcVM4TlxyXG4gIEd6ZUlFS3RWcTlaS2JmZk54SU1CbXpFVGNKY3JNM0srOFFZZjF3SExDUk5mVW4yd1Rid1YzMFNnb1lxQWZjUTBoWkhvV3lRbzBiNHRcclxuICBSdVYydlhod0xZZ2tZQklySlBsRXNTTEF2bE9tM09VOEZuNmIyVFVTd1FacHpGbHVER2VWSTdnRzJoeDJSK25uRzR3K0FHZ1RNRWNZXHJcbiAgdXc5Z2EzVUdjRkxKbmdCdERTcnJFK0lTUjRhOVJZM0cvT01NSk15MVRLMFRodDJJdlNSRG92UWUyNGQvYUVnUWdMWlFDd0hhM2xsWVxyXG4gIFhjNG54aUxzd3NzK1JObnRnYnFNK0EzTVl4RCtYZkVJSjFyYlhqMDdub2pSUVBqeElFUHM1L2pHSUpyV1VEYlZpNTJjWHprdWV5anRcclxuICBJbzRDM2dVcEpLd3pjb3oyd3RmbFdNZXVIZVhrRXcrVHM4NDRScTYvOW5UWGtTK1VPblZyYUc5S1QwK1J6WTZickZtMzNvMllWc253XHJcbiAgMTIrUkdTOGRKeG01YzVTSVFiZ3ExR3F1WmJ4K0FHV0lHRUFOUTduNWdaZklCNmNrUlJnS1RBUWM5M3FSZkhWNUE4bGRzMGk5aWJZVVxyXG4gIDVpbGh6V3pjV2VydmU0S3NtdXc5a2xCcEVkQ0loUE8vRGVUN212M2RFOG80K1AwUWVuNmpNWkpQejh1VU5rTnVpakFQcEkwajd4dytcclxuICBlMVRBUElZOHZVclBnWG1nbG1wNjRFWDZkV1F2bnF6bkVMTURzOFllOHRGcFNUcHRjSjlydnBKVjR6K1VCazFieTRSblQ1UnBvejVWXHJcbiAgZ3JIRnZkUE16TXJ5OFR2M1MrLzllMnZhREVBL2dJQzkvNEYvM3NEMnNZNVA3V0hTQnhJQmtqSjlOaEdzNzhYbmY3dHQyTk1xZGRBK1xyXG4gIDMyQ2lid1VHRTNhVHhic3BVVDJTakFMc0pQUnhSdXg4Ty9HdTg0RDdJV00yOVpoeWw3bkhhUk5YNGUyTjlFMzZPT1RnUG5yUGdEWllcclxuICA3SjUyVmdJQm5HUG5obitYdFcwMjFNWTc0ZEcxSXp3ZmhCaVFSU1FNbTdLWFFiRU5OUDl4Qm1LemZBSGM5MENZQ0JJb1pBaVBuTkg5XHJcbiAgN3dvUVAzSEhzM3cxdEdXRWtVNWdENS8xamtBOXpxY1RXd1I0WGw2KzdyTTBBb25BZVN6WUtRRDFiWW1IZFFBTTN3YnFUWm5pcFlGRVxyXG4gIDRIaTRBeHJZaDY2Vm5FR1VLd2I1aFF6c016VVhFZ25QLzRzdmZScHVFTThrNG1IWFJUMEdrRXJZWm4vcnRxM2NhREZKYnJuaGJEbmxcclxuICBsQ0ZTdDI0ZGRjTldEem8zaXR5MGNaUGtiTWlXMzErK1F2TEdQeTlMM2psZDF2OXdxMVN1MjBibU80a0Job0lLeTVoSVJtWWRkVWZ0XHJcbiAgY3VaVHVwK1JOb1FUSmdKRElRWUJTZVRyS3h0TDRkeWYxb1ZINXlucDVhVldwME5VdlFYU0tsYVgyaDBIL2E5U2FjMzk2VG1kcUt2bFxyXG4gIElkNFRLaXlGb0ZiaUdmUys2ak9wM2VFZ0dmdnNhWkl6ZjNUaGdKdCtsai9lOGN3REZXQis5Z29oZFF6TWcyZUtZd01EZWxSVHBJdXhcclxuICBaODRVdHYxdStGbm1mWDJYakx1OXVhejU0eVVaK2VScHNpa254eEZLZHcvTkdzak4xNTByeHh4OWdQVG9HNTFRQ0tKRklDemYxZVdYXHJcbiAgYlJ1Z3QvL0FubnJNaUJ2bDh5LzRWMFRxd0drakRJNGJJSVFERGp3N2NxNWg1Qyt2K2JYcmM5Z2lFbjFUZlB0ODh4eWp6bHR2ZTJra1xyXG4gIEhneE9rWGk0THUyRnJ4OFA3Z01IQWVxeFdDb1QxSFpzbHdic0Z1WlphZWVHNisrTTlBSHNuRVMvRjlpOTQ3SVBTcXUzSzFnV0RONHRcclxuICAraDNnRUdSWXVuUlZaQks3Zjl5SVRnUm5yVnJlUjMrakc5RWdWckxnbG9yb1M4QWEyNENIWlVRTU1jcjI3eXhHai81TGZ5am4wUTVyXHJcbiAgUEFmSWFVWFpqRTFjWjN0dEl3WWlKbmJxNUtPNE9ZOHBMMm1UemxQYStaeG5jUnVBVVIvMVdyUm92RTJNUjZMN29ENmVGcVVSY211UFxyXG4gIDY1QmlHWFdVNGZQUGY0bjhadHExdWdiT1FVd25nQXQvOXZNdUhLcjJGMkJ0c2wrTmUyOStvWGw2OEY3akdHMnh2MXJWeXZyN1J2OCtcclxuICBVYS9GZmtZaXA1NXl1SlJOUzNjTWZMTU02Tk5KbGl4ekkrQ3NEVjQzN2lvVk9ZWlNXRlFzMmU3OWI5cTBVUlBzclozeWxhUWtsNUhVXHJcbiAgVFF0ay9mSjVVclBqb2JMd1Y1OTNpWHhiR05pUk1PWjgvN2dzK2VOOU5hclRtS1k5T2RZUlJyZDhlMHZ2ak9UQ3JBMnRqNzB6blJIM1xyXG4gIHFFZU8xSlRsVEtPN2RPeEhzbXJLOXhxWVNBcVAvM1pzV2pWUGxrMzRRcHJ0ZjY2Nkp2TjdGdjc2dWpJT0hCRmdKQXQvZlUwT2YzeUJcclxuICB4dGxnLzZqZHVPMkdUdWU4WGg3bWE4eURwSTdmWGRkS0d2Yy9TNW5IQkNmUnBXUlUxREwxU0ZHL3lEM2IzQlhUSkwxOEpabng3aFZTXHJcbiAgdU9oM2pTSmZ2WGlPeGw1VnpxeWtSUE9LUzArU1R2dTBrMHN1UFVVSkZRT1VYMzRacSs4ZXh3L20zcVpzaE5qNm40MlEyUVlZeDhlTlxyXG4gIGVTOW1YeGdNWnRMVHl1b3hDR0gzd0VnZEJ0ZXc5bEVwSjhvUVMvdjBZZEtlTDEreFJrNDhJVllGWTZBZGJCRmRuUFMvZVhPeG5nTkJcclxuICBUM1J2Z0d2bjVSZktjY2NOMG0ydVE1NnA4UGNWRCtpRTVhS2lIdCtQTVRPMlM3dFdQT3djKzU1VlJkZXZtOHlZT1Y5YU5QY2FCMkRyXHJcbiAgK085K2QzRHNrWmVvQ212WTBFdjlEZ2NHREFaVTVTKysvTEdXLzNFSnhGeG9nVDBNWUdrMXdsZ1RKQmtFUnFoM0JZa002UmpEN2JvOFxyXG4gIGRMQWpMczNMc09BZXpxVSsrNndkVzhlRE92WWlBZld3SHpScGt2aUZodThEUm1xU1N6eHNrbnphczk5bExuMkc4UDFScmw0OU0rYjVcclxuICBmZkxSWTdxMmF4N2dSb25oNCtYTGw5TnRqdi95MHlzeVowNDBaUWxnUDIwQzJxY3UxME9pd2J1RWNucDZXZW5TdmJPY2M4N3g4dXpUXHJcbiAgdDh2Wlp4M2pScHVkNWZycnpuTFNpdy9lTEhiTVpOWHFOWktidjFIbS8vbUpUUGptUlNtejdIZVo5OHFKa3BucDIyY0VEaUI0Zys2ZVxyXG4gIEtPc1dUSkFSY1pJSUJQYUlaMVpJZnBGVUpzc3N4NDU1YVlOOGZtRk5KYmE0K2JZNDlDb25qYndvQ3dLSkJKQzY0NzhKVExvMTQ4djdcclxuICBwVUt0WnRLay81bTZiOVJEUTVRUW1IUmxhZTI5M2NkSklhY21TZDJXM2JPYUgzTnY1VER6U0t0WVE3NjZvcUZPNHFXU2h6dVdubG5YXHJcbiAgenpDSUNpeGdJaVhUM3BJTjQxK1RjVStmSU5uTDU4aUsxVm5LL0ZOU2tyV3ZEcjM1WEpVVzFxejNjMTBZTExzekJOVU15MkZZMytLNFxyXG4gIEhidlRsWThQak0veDlRSDdIMzM4ellnNkNEdEJvbnJBK2l0OU5SNjBZL2ZLNEErRGR5SllHNmpZdW5YemRrR1FTSjFrZGJrZmJETXZcclxuICB2UGhoekhWS2c4VnRVTmZhNEp6dzlzN01nZjU0Z2h4NUZqU0pxeTd0QVZPcjAvYU83bTFud05kMy9mWG42dnMyR0wxR3l4UE8zZmVQXHJcbiAgTXhBUUpwVDJBUEVLQXZ4ZzIwZEgyeE5jZkpHZmloUlhYR3ZYSGpKbG9qVkJtTWduZ3IwRXV5OGp6bXh2enpaajUrRitTS0FUOVNHd1xyXG4gIGVEc2xRdmcrY00wTjIwN0NvQTI3bC9DekRJTnJ2L2pTUjFxbURneHBaQ2lCSW5wczFGajJjWEp0dGczb2czOGVQbGFPT0h5QVhtdWlcclxuICBreERmZmM5SEk5TTI4UzNFa0hCKytEejg2Ykd4OEp4SkN2ZnRkNzlKeC9ZdEhQTTRXazQ5K1hBWi9ldWJUbHBLbDJzdk8xbE9Pbkd3XHJcbiAgcEtTV2tiVDBWTTBta0xTMTJGSDBMVEp6NnAreU5udU5qSHY3R3ZucjViT2xKR3VtbEd4WUpDWDU2MlhxVzVjNXhwQWplZXVXeHFpelxyXG4gIHNJbEFGRHVjZUs5c0xsTytHaW5nYTFTUXhVYys1K2ZDbi9pR2o1ZG91djk1VXEvbjhaRVlFVXNlQ0hBRlhqRFNxMGIra3lEOUN2ZU9cclxuICBTcXBLdzQ3UzVvanJkZjhNdDIvNnAzZEpuMnUvME9sOHFRT3o5QktYSS81dW15QkJtQVdwWHBCQ1lCNy9lZ3R5ai8zb2ZKMzNBM2ZkXHJcbiAgUHg0N1Zwa0E2aXBtR0d6UTdVZ1o5K0JBMlRqbUdaazFaNjZzV0xsRzNidUxBbjdLcW5MVlN2THArdy9KcFZlY0pUOTg5OEkyS1hiQ1xyXG4gIGZjZnlVL0hlemVNcUVlRW5iVW5Yd002WENHWWJlYkFVQXpaNCtCSC9qdXo3aWdmM3dMWHRHd0gyM1llQkZNQzNRZjR0MUV1b2l4UFZcclxuICBNOWczYjkvVitlY2RyOWN4OVZkcHNPK2F1bHpQNnJKdHYyRm40ait1dU9JMFhYTVBuTWYzbDhqK2NlQUJQb2FIa0lBOUJjNE9JTDFzXHJcbiAgYXNSbEY1Z0VnaWZ0bitPaXM2aitSeGhJR0dTbEJOZ1VER1NWQmZiQ0RLVVJ5OUpnTG5JbWFjQkk3R1hTbHJWdkwzRjdRUFhGT2VINlxyXG4gIHJESEFJY3FYQm9JTjhRUWpXSEJIOXgvL2UwR1lxWVJoOThLb25qb2tRYlJnS2dPVDFWQUhxUThtRm44Y3d5VVRUZGsxY1JBSVh6K3pcclxuICBTcVZJMHJpclhPZjlQZlE3VGNWQTdoOTg5KzErREJ3anRZSGRQOGY0Zlh3ODdOdW5XeWRwMWFLeC9EWDZiZW5UcTV2VXIxZEg1MXJoXHJcbiAgSGtrOVU1QzdXYmE0N1lLc1JUTDI5U3RsNFI5dnl0eWZucFE1UHoram8rWkRINW1qN1g1K1VTMGxwbmhuUVR4MVpPMjJXeDcrYjNubVxyXG4gIHlLU0dNei93MHNnK3B6OG1uNXhiV1krWExaOHBtWTMza2ZuRFg1TGxmMzBsbS9POGJReTNZa2I5SkdVczJWSXNTNTFFOUU5aHpjemZcclxuICBaSjZUaEJiOCtycGtWSzJuOTJ6ZVp3UUZqbnJrYUUwVzJmYm9XNVN4ZkgyVjk3N0Qza005bU9lYXY3L0xnMWt3TWRRWGwzcXBsdTFGXHJcbiAgdjcrcmpLVldoNE4wM28vcEh3K1ZTbzR4d1R3V3ZubWE1STkvVWNiZXU1K3NtRFpDbHF4d0ROYTZoUk56MnJacExBTUg5cENISHJ4V1xyXG4gIG1qV3VMMWs1K2ZyT3NFMUNvQ2p6TG5tSDlrNlI2c1BaSGFaT25ST3BDNHl3c1ExanFsaXBRbVJmR0ZZZmFldmYvejVIdCtQcnNZK2tcclxuICBnenNDOWV4N1F6MGV0cTBhSUw3OERnei9mTU9veTVoMGJYdjJDTnBzR2Jpemtsa0N1a1Z5MDBTL3g0QUIzV3lNMUdPeDM4cDZaNlFQXHJcbiAgRUk1QUJ6WmxiZXZXM2o1c05oYkw2c3VnZFUreFpNVWE3UjR3TDZNZk52OEtRRE1ScGl2L0VRWVNmcGw0SlFFak5BQVhWSU81MWdFTFxyXG4gIDVOdFplSUk4UHVKcHhBOW5INEJZQXJORmhJbGZJcEJqaDN1TUovTHM2OVhMUjZjblFsak5FLzZOcFNHZXljUmZ6MEJiMUgzbDFVKzBcclxuICBEcDBvM2wyUEVRUHpSRStiTmxmcm9CSUx0OFUrODM2aHZINTl6amJTaEJuYkFSTk9XY2RuSDM3b0ptMjBDWGxvY0F4YnlCK2hoSFc4XHJcbiAgYzY3Tng4TjlFM25NczRGQTNYUFhGWEx6ZFdmS0ZaZWRJdWVjZVl4bVMwNTJrb21tMHkrYnJBU2xlSE9KcExveW1QM2xIZkxabWNsU1xyXG4gIHJXaUJWRWd1MUZFNWdMaml2anI4emdFYUozRzgyeTVKTGw4TnBvRTBna29MVUo5OVRMUlV0OHZoN2dNbzBkRStFZTJBR0pReXlTbFNcclxuICB2OGN4a3IzNGIxa3k5a05WZFMxeXpHNTNBUk5ZL01mN3lyQW8xMmpkVjVydGY3NFFDR25SMzB6ZlN5d0xPY0w2WFAycDFvTlJrTXIrXHJcbiAgc0VmbktaTlpPdTVUdmYrRys1MHNBMjcvb3h5cFRINit2YWUyUlE0eG1PdnNieDVXcWN6VVZ2a1RYNVBOazE2VHlVOE5rYVZMbG1oNlxyXG4gIGRVYU9tN2VJcGc4NjZxZ0ROT1Bzc1VjZkpJY2QzRmQrL3VGbDJaaVRLL2ZlYzFYazNZZGg3NDgxN3o0OFh6ajdlTWU4NjBVaFF5c3dcclxuICA2UUlpelR3NDhZaVBDNGtIeVE3RHdMWmgwa2dZWEovNzVodmgvc2dibHlnTlBLQ2VFWFVXQW1VVHFhOElrZ1BXTnUyKzhlWVhVcTVjXHJcbiAgaHU0dkRhanN3TVNKTXlMZkRzL213QU42YVpuMmVHWTdBNHYvc1ByR0tKNTcvZ05kRTFzQ2FCT1FsbVZQOGJxVHRtQUs1TWN6K2hKMlxyXG4gIDA1N3ZtQ2p4SDRaLzNJZ093b1p5YnNtTVN2SDdBQ05jSTd4TUJyT3JCaUU0L3duL09rUmZHcHlTOHltM2FlTkhkTSsvOEtFUzF2QUVcclxuICBMWW5BUFhHY2MzbUIzQk8vbzBtVCtqSDdTb1A5eHZEdlRBVDc3YWdML0d4bzN1QWQzeloxckM0TDNpQUVRL0Z5TVhnYlNMaUlQcGw3XHJcbiAgSERpdzV6WnRjVC8zdWcrVFhFUVl4U0hxK1hrRmtYdkUwSTVOQXk4NHBKRVpzeFpFb3R0eGRTUUNtQTZia1pHbXo1cnIwRDZHUFZKMFxyXG4gIDgxeU9QWGFRR2xseGYrUVk5NDE2YnZxTWVXcXdaQVRZdGwxTE9leXcvakozN2hLNTNqR3VUZTRlK3U3WFJWcTFiQ0lIdVk5dCtyUjVcclxuICBhcmhNS2lhcEpxUHVNckl1ZTRNYjBXNlJsRExKTW5mNEs3Sm01Qk02N1dyVzd5L0k3NjljNGE2Q3VzY25CL3oyOW9GdWlKd2tBODY0XHJcbiAgZlhHVEk0WldaaDhHZVBiVjZYU0kxR2c3UUtvMTY2R2ovM0kxbXNpOG41NVJJZzl4SjZzd0h3L3FKVURtV2d6Y1RNUkVmTW1xYWIvSVxyXG4gIDZ1bCs3cEkxYnAyellwYVVxOXBBTStTV2NWTE5scUlDeVd6VVNZTWFjU2ZHQ0E2b1ArbjF5MlhadUUrY3REQkltaDF3dmxSeDlXQWNcclxuICBUSnlGYXkzcUtpYlNZdCtFNTA0dVdEdHZRc3JoankyUXFrMjY2djNqUllVS0MwYkU5c0xmWHBPZTU3MGttZW5GbXRJa2QrRll5Y3ZkXHJcbiAgSkt2WHJGR1hVOGFLUFArcTFTckwrV2NjSmxkZmZaWmpBRjNkZStraC9mcDBsU2JOR2tyRGhuVjA5UHBhNEdoaGZZeDNpd01Jd1hsTFxyXG4gIGw2elVmUXpxR01sREhEbU92WUgra3BhV3BvNHYxdGM0enF5WUZtbU8raVhjRCszNG9ZZjBsWnR1T2wrM2pSQWErZzQ4STNJKzF6cjZcclxuICB1Q3RqOG1vWitNNjViL3A2Mzc1ZEk4NGhZZURlSHg3MDdBaDllbnQ3Sk5mbGQzUHZMRC85L0ljYXNzTy9KUXlqS1J6bnVmTzlzWTluXHJcbiAgSEc1clI3RG9jMkQxdzJ0cmkrZkdOdXVERC9ZWnEvY0V0em1tRGlQQy9UaWM4UUxheC9zOS84SmhtdHZMOEIrUlFJd1FBOUtLZ1BDK1xyXG4gIDByQXpkZUtCUnhEZ1hEdmZPRGpsWHBFNWo3Zi9FdTFjY21IWkMrT0JXbnYyTXJjSDZ0bTFTNFBkQis2OHRMMDkyRzhDMUNVZFEzendcclxuICAwNjIzWEtnSkZzTUl0OHY1TjE3dlUySlF4aTM1cW1zZjBHM0FQcUtDellpT2xFTDZDUUNEczJkQjhrWG1uQ1k2UGR3K3h5ZE1tS2JNXHJcbiAgQ1JVaUhaczJlUTRRQ0xieGZnR2tuNGZaL1Q1dW1uejB3V09TNnhqR0dhY2ZKWWM0b3ZMNUJ3L3FCN2cxcFl4TzhnV1FTallYYlpFa1xyXG4gIHh5OVRuY1N5T211OWZITkRlMW16WnBHa3VUcW90RDQrdll3cytQNXVTUy92cExFL25wT25qMHhxaUV0ci85TnZuNC9FQWo0Nk0wTWxcclxuICBrdlVMSitub24rU01iWTY4U2ViLy9Md2J3ZDhoYzc1NVZLWi9lcWZXQmRWYjdpY3RCbDJpYWpEVVNjeFIwdXJRcTZUTmtCdFU1ZFJzXHJcbiAgLy9NMGZVclRnZWNvOHlsZjNhZXpnV0dvWFlQbDA3dVVtUGUrOWd2cGRjV0h5ampJcXZ2Ukdla3FjZUMyakpFY2pMeGp2M3oydFQ3dVxyXG4gIDNuU2tqT21mMzZPRzg2M0ZCWExvQlEvSTZvL08xZTIxczM2VnhvMGF5OHczejVWUkwxMHBSWVVGc2lsbm8rUnN5bE9wemowNm5aV3lcclxuICByNU0yU0k0NTVMakRKUzJqbk40SDcrVGJJTTA0RWlzdzFTVEhlS2VVdy9FWVpKQ0FRSWRCSFZRNkRQeU1BVEJ3Z0xodDNmeTN2bS95XHJcbiAgMFNYNlhwQStya3NRZXdFNHo2UVR5aUNSdE1JeEd5bHpmVnlJRTRIZ1pmc1c3VGRadTZXQjQzWU80SmtnU2NRenVqQXdObHU3UEVjV1xyXG4gIDI2YXRuWFhmNVR4ZzU4YXY1d1phRzJKVHdQYnVhV2R4VDlBMk5xdDRleXhNZXZic1JlckNIOFovUkFJQmpGYngvOGFnekl1Z2c5bm9cclxuICBtTEx0b3l1d05ueit4WERaTjg1dmZIdXd6b3NQT0hOb21BVEFZcTZxWElzWFJLUjFvaWhhQS9YM2R4OEg1K0o5d0lkR0orQ2U3U01MXHJcbiAgMzJzODdMZFlIYTVITHB4RStsazZCaTZ5NU4weDk4aEU3ZHMrZmhmMTR6c09IeE1mQzk1Zkd6Zm1xUzkzdkJURU5xb3FSbTM4RGxSOVxyXG4gIDRlZE9HWlVGblFpOUs4YjBmRWZjdTNkcnIzVjRCdGhMR0F4TW16NVg5OW1DbUcvQlRGVXlLMGxUSjdGaGRMdms0cE1pOTg3NTloNllcclxuICB0WkxzcWZ6K3h4NjVRZjU5d3lNYU5WK1NsQ3d2dlhpblNoOU5YWHNWSzFhU3M4NDRVcVpNbVMwYmMvSjBQNk9mNHBLdGppQTRhbG04XHJcbiAgVmRKY24zY0RKU2tLTE1ORmp1Q2lCb09RajMxbmFHYk9tQmVrWGVjZU9TMTdINXRXOThCcmxHR1lWT0llbktaRkliZ08xMS9XUkx6alxyXG4gIDhrcHdZdjZHVmJKdytFdXlhYzFDV1RIeGExazM1M2RaNHlTUk5iTkdPUWxsdE16NTdqSFp1R3ltQnZYbExKOHBKWVc1a2xHdG9kVHJcclxuICBmcFJLTzBUVjQxMjJZZWxVbFRadzBXM1E2d1RwN3FRSHB1eGx3cXp4ejU2Y3Yzcm1xTlMyeDkyVmloU3lhY2xrR1hOUEwxazA0UnRsXHJcbiAga0JWcU5aTDVZNzZRSlV1WFNvcmpEdXpMenM1MnZ6ZFBDZ3B4U1BEUC9Lb3JUblcvdTZ4Y2V1bXBVaTJ6b2h4NFVHOU4ydzk0OWtnTlxyXG4gIFJvaDREN2paODg3SE84YnZiUUxQUk40bit6YVRFZHYxQndzT2hFamU5OERMOHVvcmQycy9wYjU5eDZCKzR3UGwwNDhmMXpMditJYWJcclxuICBINU5YWDQ1T0JHYlh0cjdMZG53L3h2VTNMSDJnN3JMdE1Eakd0UTNZS0JKOVg5UkR5c2Q3OFRjM1FHSks1MmxPeWcyZmE4QVJoRUhVXHJcbiAgbFZlY3JzZVI1RjU1OVZQTjc3VTlvTDRhNUVidVhNdnVpK3RaOENYYlNPbDhFenVDUFV2N0x1UFhOZ2pEN3N1MnZZTTl3VE12ZktBdVxyXG4gIHVrOC9lWXM2N2dDZUdYTXJyVm16WGthTi9rdmVmdWZyR0dQOWY0eUJoT01iakhHRVgzNGlaZ0orY09jWk45NForUE85SFlTeUxYaGNcclxuICBXTUpDdTliMm1BZXdsd1V3R2tJY09jK1loekdUMHNDNXExZXZVdzhHREhiRXFZeitmVkxDYyt4YXFKUllFK09CTTBETEZsNzlZZURlXHJcbiAgcVF2NCtJa0t4U0JvOXdrNHppeHZhV21wdXQvT3NUcXNZVkpNcjh1SE11U0lBWExSSlhkR1VpUncvQzBucGx0OXhOay94azZXZ3c3MFxyXG4gIGVsd0lDSE11WTFqbkhtaWZTSGdZTnM4R0VSODFCNHdLUnNPa1Zqd3ZqbEdYVk4zOEx1Nkp4SExNbDBBN2ZBUjBYdUpNa01pV0wxK2pcclxuICA2cE9LbFNxcWlveFVPRU52UEVlbXpmVHpzelJxWEZkT1AyV0lHbkh6M0VmdWVJcTJDV01oQnFYSU1SYWtsclFNNW9wSmxweU5HMlhtXHJcbiAgdUYvUzVqbUNQTytidTZWNjhUSnBpREYvMlFSWk9mNWorZVBWcTJYcGo0L0loajlmbGVRcWphVmljcUZVYTlsSGFuUStYTlZSdFRzZFxyXG4gIElsV2JkcE9hamlGVWI5MDN3aGhRZlpGQTBtLzNseXJsVTZSODQzM1ZSVGQzN1NKbEdPUGNRcUpIem9VNXdEUlFiYTBmK2ZDNjN4NDRcclxuICBOR1BGbisvSnBxd0ZxY1VibDhxUzBhL0wzeDhObFVWalBwRGk0a0pKZC9mUENEQjcrU0lweU05VHhwR2FtaXdGZVp1bHJ1dlRiZG8wXHJcbiAgZDgvaGNFbE9TWkhYbnJ0RkdqWnBLTGU2MGZvSEgzMHZSeDExb0VxRGdQNEtvVTVFd0puem10RTc3d2sxRlU0Z1BPUFpUaEpsb0lMelxyXG4gIGh0VmxHemRaM2k5TDFXcFZaTkNnM3BIajV2MUhQN2R2UE56bmJSL3Q0eExLNEN4OEhIZlpibDNhNmo2NzEvZzJBTWZpR1E5NTZPTHJcclxuICBBZExMbzVMTmRBd1doc0Q5anh3NXdkWGQxaHZxSFVja1lSNkFhNkRDTmViQnZkdDNFUStqVTF5ZmZzaXpNZHVIbmJjenpDT3N2cUlOXHJcbiAgenJOcmN2L1laN2dHYlZLUEpMVW5uM1NZSHQ4VG5IamlOZExEZlpzbm4zeVlPa3JnMW8xNm5QTHk1YXZsZ3crL2x3a1RZMmVQVEhKaVxyXG4gIFpwU2QvSU1najR5Sld4akNiRHBIZTFCa2hiV1hkT25sZDh0VFQ5eXM1WENkbmNXd081NXpIZXZDaE9kQ01Ca0Y3R3licUdNc0Y1UzFcclxuICB4OXFZUjJudFdFb1ZteG1NY3d5Snp1RTRuY1RpVDBDaSt3ZElHSGhaY1E4d0p3aDYvSWRFeCtmK1lFaDRoc1YvYk9IN2dWaERuR25YXHJcbiAgNm5BYzd6aWJ0Mkc0MithakNCODNvTnJESHNPOXc0UVlGZUh1elAzaDJzdEVWMlQ3eGNodkRnajIvR3dOK0sxMm4rak1hN2g3NXpqYlxyXG4gIHBNQWdyOUdubi8wa0J3M3NMZzgvN2czY3BLdS8rcElUNWVlUkUrV1dvVThxWSt2WHA0dnN0MjhuZlFjNGFEQjlERXpGbUF2YnlTbEpcclxuICBzdGxKTFdWVHk2amhQb3p5NlJXbFRNVTZrck42Z2VUbmVhOUJaczlrMHErMHNtbjZPMUtTVXhGYUpDazVTVWRrTUhMeUhwVWtwVXJ1XHJcbiAgeG13cGw1SHVwSUpDeDdpWTdDeEpSM0dHek1wVm5kUzNXcGxjc21zdk5XV0wxaUdJcjdDd1JKa0ZLanFZSG1XODFjaCtER2lsUnMycVxyXG4gIDBxcDVJMGx4SC9meFJ3MlF0aDNhYlBNOGtUQnhtT0FzdTdJOVgwQWQyN1l5c0cxZ2JURXJKWEVIOXQ1QXVFNjRYMVhLN0NuWE9JbVNcclxuICBmZFFuSWFlbHdBQjRBWm9rd2NSUDEvejdJVlYxaFhIcjdVL0tuY1A4bkNmY0Q5SkhmQjFnZmNVUXZ4MEdUakUySi9tdUFGVXRqamUwXHJcbiAgVGJacm14ZTlOQ0M5aE5PcDJ6MnhwdmRCbDNZRTNJeHR3aXc3Tjd3MndIaFJLek5ncy9uZmR4ZWtxTC9ZRFNMUGNkSVM2WXpJR29JMFxyXG4gIGg5TUExNEhwdHUxd3BBWm9oc0gzOUIrQnBnc1BRRHBrUUtjMVFsUTlTQmtDd3ZPUGgrdnNMR3hVWVowOWZIN1BuaDIwemJBYjhmWkFcclxuICBwS3JCN3NVK3JPM2RHNk0rRy9rQjZob1NUYThKd3N6RGtLaDlBaTdwMUtlY2ZMaW1uYWRUeGVjTzR2N3dhQ09sZ3lIY0Z2ZGpIbGlMXHJcbiAgRnZzb2MzNFhhamJBY1pnSCt5Z1BETzdmMmdqL0hwZ0gxOE93ei9Gd0FzaVpzeFpFM3IyNUhYSXVkVmM3SmtNZGUwL01sVzBmQ3N6RFxyXG4gIGttOUNkR0FlN0VlRkJmTWdMb1c2dmZmYlJ6NzhiTGhrcmMrVzdLdy9WRS8rcXhzazNQZlFxM0xBd0I1eTU5QkxaT2d0NTB0ZngxUmdcclxuICBITDE2ZDVINjlXcEtFaW92MS91UlVwZ0NtU1V2V0svUFdpZHJGMDZUSXNjOGNFOWcyZXcrb2tJMytzL08zcUJKQnBjdkpkcDV1V1M1XHJcbiAgdXF0V3JwSjE2OWU1RHkxUE5oZHNrR1RYYmtGQmdTUGVXNTBFNFYyVm1YR3owQzIwdjhJeGp4VEhXTW80SmxGY1ZPZ2tpV0s5ZG9GalxyXG4gIEZDbU9zWlZqR21iSFBEZ24zeDByVjc2Y25PWWtqSFBPUEZwdGNrTUc5M0g3TWpUZ2MvVzYyRmdOMU1Ub3h4bU04ZjdKNXdaNDVqdy9cclxuICB3RE1uU3Rxa1FYdVhIRC9zMEg2NmJUcHczbzBSUkh0UDlzN29QMkdDbHBUYVFYTFdqNDI4UTQ2SG1RZjdPTmZpTDdvNktTT1JYWU1SXHJcbiAgUHpUQTdyYzAyMGY0Mmp2Q3JqQVArckJkTzV4Qlludk13K3FqUWlkckJjRHRGOWQ2d0wxV3J4NmxCOXNEYVdTQS9UN1RETmcyRWdjd1xyXG4gIEx6V2J1Mk5Qc0hybFdoMXNYSG41YVNwMTZMN1ZQdVlOSnNXM0czYm5OZnpIR0FpZE1reDhyR3h1dStGOWNNQXcwRm51Q2l4SWg4QWZcclxuICBRR2VIZ3dMVGo5b0hZdGNzRGZGRW5iYjRDT3grN2FPS0I4ZUJ0WThJaUtzcm1XL0RrMDRad3ZWdEtRMmtaaUVOTy9NREFPb2l1b2RCXHJcbiAgZTR5SzdUN3hUSXVIR1UyUENpYmlZc1I2NWRYM2FSbHdMc2M1bnpLLys1WFhQZzJPUm8rekgyQy9NWEFNSUlJRE85OCtOQ2I1UVZJeFxyXG4gIEpySStPMGRIZTBZWVVKUFl1VU9PR0JoNUh1UTdZa1FOWTZjdUg1ZUowTlkybzFXSXpyTXZmU3czRFgwYU1VRkdESDlkOSsrL2YwOVpcclxuICB2R3kxUnR2dTY1akpUZGVmclM2ZkxCZGQ4QzhsME0xYU5sSm1neVdGWmF1N0lOY2dKY3RtSjcwNlFVR0tsVG1VcUZva3YzQ3oybDYyXHJcbiAgbENScHBEM0hFUmd3Wkc5eDQ0OUN4eGlRVWh3cjBiYWNqS0g3dG1DN0NVQmFGeGdIZ1pZd0RoaEt3d1oxMUhZMGRzU3JhcWM0K3VnRFxyXG4gIG5HU1RJYWVlZHBRd3A0czlLOTZCRVJkUzNLQk94SGJGK3pkM1ZuczIxbmR4dVNaVE51cEZ3UFBsR05IWkFDbWRiV3VYNDJQR1R0RnRcclxuICB6bWZOY1FQdDgxN3NPaUI4SEhDZmVFQ2l6bzIvN3pEd2xzTHRsMFNqMElkRWRlSmh6Mkp2Z1BzeUdBUGVVZHNRMHZYck4yZzlIRkM0XHJcbiAgSHp3Mncrb3UzdVdPZ1BvS1NRZmc4UVZ3WHdhOEE5cmxIV0dic0h2YUc3LzdIaWZsOGY1cU91a1dyUVV3Mm9kbWdzbWpFZ1VxL3Nkc1xyXG4gIElJQVJqM1dxbjM0ZUkxM2NDQ1RzdG92dXUyT1FmNG1IWlE5L3hJZy9Jd1JwWjRHRVljRk9QSmptelJ2R3RJbEtqWTlzUis2OEdJcFJcclxuICBlK0dHeDRlSmJZWDZ0R1hFTTl4Snd1RDNRZ2k1UGlxbjA5MW9aRWNPQVp6VHZYc0gyWkN6VVJtRlhTTU1yZ2R4NVQ0d2RxRXV3b1pnXHJcbiAgK2NVTW5FZUhxK1k2QkFRWDlSRy9KWHkvakY1d2NPQjgycVNMUU1nN2RXeWx4ekcwa3hZZk93WFhZL1RJUjJYZU9QdzJBMjI4L09vblxyXG4gIGtkeGpMTWE0S2VmbEZhZzB3dVJoR09TNXY0OCsra0hqUzg0OTV6aTFjL0JjV1ppZ2lQWW9Nd1V5ODduVEJsSFBoN3BSTW9iOUN4M0JcclxuICBSeDFLaDcvdTJyTzFMbDVvL1FhZW9WT2hmdmorSTNwL3FFQ0lpS2JNeHdhalJLSkNiWFRuUFMvcUFBV3B1RnJWS3ZMR2EvZHF6TkR4XHJcbiAgUi9hWFdYT1h5dW9WcTFRSGpEU0J5b2syOUROeUJjaS9zUUNTUjlwQmpsTWtTTy9paTA2US9aMGt4SE9FWVdEenlWN1BCR0IxNVRnblxyXG4gIEpWeDk1Wmx5M0hFSFM2dldUV1g1c3JXT3FHZEovNzdkNUxXWDc1SkhIN2xleG8zN1c2Yk9YS2plZ3hNbVRKZVhYN3hEK3dqOWtlZEJcclxuICBtYWh3dlBIb2F5ejhSdmF6NXBrQTZ2SThXVk9YeWNST1BjV3JQYXdPZ0ZFeEFxVy84SDBDam1OYzVYdmlkOUZQY09zOCtpaXZualdtXHJcbiAgd1hPbGZZNjNiZHRjZGVrRzZyQ05UY0Q2NVVrbkhocEpWbXBnUHdaYjdoMVhjano1YURNTTZzUVRUZTR4L2p0SkJLTEtrWHhLZzdWTlxyXG4gIFd4RE9yNzhadVZQdDhtMVk1bkhxczNCUDNEdHRsalpaVlR6b0grYTlpTjJKTmUrTktYaFBkTS9MN2dVdGhyVzlNL2UzUFpDQThoN1hcclxuICBKNUErVVRtakhTQ05DYW8wNk4raVJTdmt1dXNmVmhWdFBQNWpFZ2dneU0xZ28rZndqNTgvUHpxSCtBK09zUmkyUitCTEF6bitEV0dDXHJcbiAgRHhpWjFRM1NpK3hNMjZRdUFKWk5HSnNEVTIxeTc1d2ZEb1FNZzQ3SVl0ZmdIcEJFNkpSMGlFU2dUVlJBUFh0MDFQTXM3aVFSYU1kY1xyXG4gIE1LbERBRlU4WURCazUwV1BiUkgwNGZiTU9Jcm9EU0FDQkNzYXVBZU01VHc3enVQK0NvdUtJaW14dzgrUDR3ZnV2Njg4Ky96N2FnZ0ZcclxuICA0ZC9PNkFZd1lSYzJMOER6SVNpU0Q4RzJyVSt3ajIxR1lFaExQSDltVzBPbFJSMG1INEtnNGVWaWRiSEh2UFQ4TU8zOE5ldjQrYlJOXHJcbiAgSW5uaXFiZFZ6ZEtrK2NINmU2alBNUllHQnV6ak9NdVpGOXdwN2R4OUhYYjRBWExkZGVjNXhuU0p2UHYyUS9MT1d3ODV4dlNZZlBUZVxyXG4gIDQvS2VLdzhaUEVEYXRHZ3Fndy9wTHcvZGY1MWM0eGhDMTg1dFhQK3FLZVhMbFpjNzdueGVsMWRmKzF6VmhLKytlS2RlYjhHYzd6WFZcclxuICB5MHN2ZnloMzN2V012UERDQjFMTFBaOFJQNzBTa1F3SEgzYWgvczdSb3lkcWlobktaNXgxazk0M3gzbTJTTlJQdXQvRk1SYWtOUmdFXHJcbiAgZFhnbTJMK29DNzc1OWxmZFI0YnM4SHNwRE9VOFFqSm5IekUvZ1BvNFpQUndneHJhLzN2cUhCMkpob044WWM0Y0EwaVVnd2FmdjgxVVxyXG4gIHRPQ2dBL2ZUdHJGOUFOekFEWGFQREFZZ1lnWnJkM3V3ZDc4ejRQc3JEZnBzZ2dFZVpRWTYxcTc5aHUzQnBCVUR2NG5mNjkvWHprV0pcclxuICBtd1JvMzZYWmpRbnlCYlFIL3IvMjdnUit1MnJjSC84T29Vd1ZJVU1kd2pGRW5SeUVpbWJOTXBSVXBGQVVvWUhtU1VsSlNKbzVvcFJLXHJcbiAgZzZUaGFUQ2RpbzVLU2Npc0h3MUtHVW9xLy8xZTkvZHpQK3ZaM2RQM2VSNE4vRC8zNjM3dHZkZGU4MTVyWFd0ZDE3V3VsZnFhRy9qTVxyXG4gIHA3NVlyclRzWXFySkN0Umt6ZDRQcXcvbi9BekNmU1pFQjRXdkcyNzN2bmFyaFcxUXY1c0U4WTl2WjFhdUFXaU0zUERzbzNIU1RYY1FcclxuICA2dmZkeGpwcHZ2alRZWEpDSWd3S3h4K2tnVEFjVng5b1ZTTnBXeFg0Mk5tbjB2WExqVENUZkFNYndpcW85dU85OU9yT2luOWQxMy9xXHJcbiAgTC82d0Z1cDhKZDlCL05YdjhWSUo1QUp4c01FRjN0L1ZObG9ycE9SRFdPNnVkZnIybmlnRGdzVEVmTGR6K3o0SWlNSElQKy9yd2NDcVxyXG4gIEpFQmM2cnhDNnNTdVczRjl1eDNFNWE4R1h2M2ZxM09pUFJPV2swdmRkZmM5TFVIWnRyaDM0MVczMTdVRG1iWlo1QUJ0dmxKVzc2eWVcclxuICBxRExuR3lRdnRPYXdkbEkvcVdNYkFEZHRWN2ZzeStYZ01HVlUza0gxbDNyd3JndXJ3UXpncWJla0o1NXV2M3o5Rzk5WDJJZ0lISmlJXHJcbiAgRUNUWGZVUVlaWVM3MjVXTGsvVHFPQURSUmxqSHdlbWdhVE5CeWpvT28veDEzK1U1ZFRBcS9ud2ZmbkFhVEk2WkV3cE04aER5Y2NDK1xyXG4gIHl1N3pmTGVnVGdQN2l1TEwzTUw4OC8xWGMwZmJqcSs2L0pUbXFVOTdVaGxIdEdOanp3MDMvS0g1V0x2S1A2Q3Q5MEc0VDFjZzZTVGRcclxuICArNmo5MVc1cGNJSEttdzU2Y1YzYVB3VXNBNFQ0cy9wSW5FbHpHQkx1Yy85elNyOHpnY0V1dTFzdDZRY2hSaFhGWVErTUt3eHJVSG12XHJcbiAgb2ZqckxGaElaZ1NESUc2Yi9YUktqVDNoYTFBSEpzejB6c0NyM0hXWkU4WTE5d2hPanN3RWVUR2dwZnlJaCtkQXVPNDNxdFB4SHZHd1xyXG4gIFBFN2pGMGM2cVBjUGEyZS8wbkVlQkx4aC9mZVhGZGhYejdpd3VFYzQvNjR0TjJqKzMrOXVLS3VSUVIyY205M3U0ZVVHM1AyeFpyTHlcclxuICBRRHpJcHFScEVIdkswMWNvZnVSZFdRODlaTmN5MlAzOWpzdjdZZksvOC9iTDd2Vjh4MSsrMzF6MG5lT0srWElRandFMEs1dVU3Y2pEXHJcbiAgOWlnQzV3eWtLUWNRdXFzUGZTRHU4b0o0S09mTnQ5eGEra3kraFQwVzB0bCtPK2ZKOStMeUx1V1FmdW9uMXpxOXdJN3lMdkh3dmI1L1xyXG4gIDJZL0tmVTBJZ0ordm5IcGU4LzEyaGVJN2U3YlJyUHN0UWlEOXNUZXBoWGNSUVRtK2Y5MDJ1NWhkNGpFZDFOcUlzUHp5d3cwZlNsKzVcclxuICBjby9ORnczTVlCTGlVU054dXRiUHlSUFdLK1Q5bk9MMmxuaXN0c29ybW9lM0V6eGFuYmdXcDU3VzQyWlFaamp5cUo3cDludGpudnVXXHJcbiAgZ0lBR0hjUjJqZzRUNUwwS3F4dFNPc3QwSUM0RG9VRTg4WEdqSXVjb1RqdG9JUTFnRklTanc1MTQvQTNxWnNOWVd2VmdXeU9Oai84TVxyXG4gIGVPTFEwT3J5ZGVFZHY2NzRuWWhWRjNXKzFVOVlPZDE0dDl4aWc3NjdNSU02SERleWc0VGRZYnZOeWtvdFIzT0NnYUQrUHRKY2NXcEFcclxuICBCSEhrUFhqdk9kb2l3cENKNEsrNzk2Zm9VT2ZOdmNFWXlLanNIekpBY2NjMms0Yjdya2x2Z3pQVVplUFBuMm1HMnYyeGozbFUveDJjXHJcbiAgZCs3UkpjM0x2bmRpczBXYkh3VGJDaVZFSmYrSFBXTEpNb2dPKy9ORGpkWDE2Zit4Y2dtdi9OaE1XRk1oTk9yUlRGLzYzVytGb0dBeFxyXG4gIGVXZWdTQjJxR3pORDdnc3QrTGcraTRpcXRUaVV6K1paU0Y5eHRlb05JUklIdjFoWk5SQUpwMWlHYlZMbnlZVERlL3RCc01mRUFXYkxcclxuICBpSmp5SkQzSWU1Q211clIzd2IyL3NsQ2c2SUpxTkZ0UDJIVWhzaldFaGE2MklhT2lrMEQ0dWczVTZMN0w2aUh1SzB4dHdoeUVES0FKXHJcbiAgSDAxQ29IbytIV1QxMFVWa1ZVRllnSE1EZHA4alI2OTR4WC8xTlZOcGo1RlBXZWxRM3grdXNUclBmY3ZDZ3MzZnNWc1JCRUkrVUFZUFxyXG4gIHFPL3JENHNYWjZDZWpvRkZLeEFhV1k2NnBMMGpQbzFkL0t6dEVvNktzejRzWlJpU0wxZjhZWm9XZWRZcEV1OG84SXZsRW9FK0lEQ1pcclxuICBVZFJJZW9IQjh3WHRESHhVR29renFQMTZweU1UMEVWdUl0K3BYK0RIVW5YN2RwYUh3T2xJOHozNnhjM3RmNTU1VGpvL2wzejN5djVKXHJcbiAgazFZaFZFWmpyTkw3MUVmZ0daSlc4cG44NVRuNVlmcUNZSy9XdTZmQVFBWlNmeTlhWHdTdHZpczI1ZlVHNVphUTArSVREM2V3NXloR1xyXG4gICtKSUg3NFN0TmNjQ2JhVTI1V0FUbWs2VWNneER5cXg5cU9jZ2RRSS92ZmJYemJQYjc4OXY2a2s5OEdOMzk3WWZlR3NSTkg5Z3UvMmJcclxuICBkYWNHYkFQK28rYWZyeDlIMHFGSlJjRWc5VmZEM2h2dERFc3BhV1J2RFhUcnZuN3VwZ1BjVW5lSWg0RUY4YmVhdDFlQTNPT1dtMmJLXHJcbiAgTGJ2eGlILzNQUTlwOXR4OXErSVdyTDN1VnMxMjdmZWhMcHUrZmZZNTM3a1hZY2kzSkRnbUUzTXVodFhwcEJBKytlOGkzd0c3eG9Rd1xyXG4gIEdCVUdDSnByaytlQjlydk5lemVleXZOa2V6OU1FZ2RwWndiSmk4M015cDd4YTA0Ujl0VjU1eHhWMk9EYXZiN25XNURwSEhuMFNZVkZcclxuICBPZ3ozcVJZV0xQQzQzZzV4TUd5Njk5ZmdYTTJ5TWtEa1Bjdy8veVBMSG9BOFR3SmFENGpJYzl1QndzQXRQZzFaV21tc1psZVRJT21lXHJcbiAgZC80bFJWc29lYmFLV3FwZDVZalhTbW9RTVFBZkE1c0wrMFE0b0hHUlkySzdvTW5pVDV2RzZvT1cwTlh0Y3BMMlVoZmlvNVdqUXdrRFxyXG4gIEdSQUMrVFdvM1B5SG5vVmFMQzJudXNYMEM3Zyt0UjM0ZENqYU9JZ0lvZmhtbSs5U05FSGlSK01GYWRBdVlxQ1MrUkx2L05XQU9PcDRcclxuICBhUWVSMVJCU2V2YWRtWWU0YzBvbWtnRktXVGJZWVBYU29SRUViSlhGbjdONjg4SHROMnNlMDg3dUNmVDVzVEppdERFREN5SmhmOHliXHJcbiAgTm5oTmM4UDFmeWltTU1RaFRqTkJlWExQdnpyNjR4Ly9WSWdlUDc2TGt5d1JLTE11TEMxcDVQLzFkaFhFUFJBbVpjMy9wbmFDWTVaK1xyXG4gIHdvbG5GN1lwaFFabmYwdVhCZE5iYisyRlgybkZsNVgycU82ODI3Zk5HNlVGcStGWHZtS3BZdCtNK3hidlhMOFluN1NuZ09CWC9TR21cclxuICBXRXphaERUTlRLMFNIekxWNWxMbmU3VkVkUDAzcmxhMEdwV1ptM0tFQ0hsTys0SzBGV3cvcGt0QUdZTjhHeERQNXUvY3ZkbXlKUjdPXHJcbiAgMS9IdVc5LzVmdlBodmQ1VDRnMmU4ZXpYbE5XVWVLVHovbTMzTHl1aG1NZ0lUTVMwTGVmVkJNOWF2R2RMcklZU3FnUGZEUmpyclBNNFxyXG4gIEN1TUlRZko5ekJlKzJ1OWZXSEVyVDFsZUdJWjZrbEhqN0xhOUtQTTI3OTJrMU5jaytmenNaM3RXdG1QMFVUajVrbmZoRXcrT0NtZ25cclxuICBkWDNQTG5acGlmb3k3V1RRNlkzR0QrTVhOV3Y3aEJ6blFQNXhaN1VYRHB1NXA4NXI3ZldQKzU2QUtIUXFwNzdYS1ZRUTRqSG9QWXhUXHJcbiAgdVIwRThXNzA1alVMNnlRemZ6TzMrdlEvMmtuMWhxRlJpQTBhUzFXYU5sUks1VThuSHlYWU1rZ1FVRkdSQmVYUWVkS1JVOGJBTTNlZFxyXG4gIHl5ckY4MS8vY3Z0UXYzdE5xYWtHZytKZHZDV2FWSGFaZERHUTI0ZGhGbFg3Y1o4NkorUTFTLzlGRzQ4NlNrZndqbG90NGdIY3p6enJcclxuICBXMFhZVEh2TWUzbkI0b2hkTEc3Um1uTHZPeU1lQnFCVFRqdS8yYkFkR09YWGMvejRmNkdkY1JtSUREd0dJR2w1cjE1Q1BFSVlhSkJnXHJcbiAgMXlIcTFKQ3BWZUtwbXlIdnRHTnZJNW15R1lSMmFBa1NGWElETk9LQm9KS3RpTi9mWkVCKzNOZkVBN0JsYXZtSzNlL2lnS2ROVFFpdVxyXG4gICtmRXZXd0szU3VINU01K2VmUC85cnJ0TFhicFhCNFRlc0ZnN0FRaFJzYXJUYmxkZCtSWEZDc0tUMmxteDh0b3RuTExuK3lJZS9DdFBcclxuICBOb0NaNEhRSGZjOFVBbGlaVlpjMmhxbmY5Q2YxWnhWbjg1aThCb1Q5T1R5S3laaVh2ZkxOelFYbkh0MXN0TkZhSlgyNzRiVWhlUXF3XHJcbiAgODZnaGU1L3ZhS1VYVzFxUU51WUt5cnZlNjdkcFBqU0F2U1Z2NHMrM1NSME1Bek1zYVp0Z3NGVW5nMkJjTUpPWHhuYmI5bVJJVUZ1NFxyXG4gIEhnVmxyd2tKYmdjRG9kVFFqUkdUbUZpdmhlZFJrc2g0cUg1U2JyQXhXSHZPK3prQjl0VUZiUjk5M1hxcmxEMGZ2ZS8weXlLamN1NzVcclxuICBjY2QvcmFpTzEvcy9adDc3Q28rNDd3a0kxSVhQdmV3b1FPM1d2WWY0bVJTSk44czk4V0ZSQUZZT1RSNkR1elRZbUlrWjUySHdRWFVNXHJcbiAgTnA1eUxvTEd0OGJxeTVWWmRUcEdGK0szNnZFdTc4VUR3NGlpOS9VL2NOOU5RL3kxSHhnVWIvWmxZR2RsMEtPbTk0TG56eFQwaVF1QlxyXG4gIGNNVTZ0R2ZBN0svK1JqUnY0Z2VjejB4WW53WWZmMmVkODUzK2pKSmJsMER3Zi9BbmR5em1HS1NSK0h3bjd3eUNWaTdPUUVDZ1h2THlcclxuICBEUXRSNGkvL1R4OXlYTmtvdWU2Nks1WnZZUWt1SE9JaHZhYyt0WGV3R05tRXEzY0dpSnh6TDExOGVlbEpsOHdzZFNtUDZ0Rm15NlJuXHJcbiAgTlpqOCt5T3llZWV2ZkdRSEJpNXh5eDhpQU15aDNIalRIOHZrWVpGMndBN1JTTDE0WmpuWGFrQmM3QkVaN0wwTDRaREh4ZHM2amIwcVxyXG4gIDVkbjNJMGVVZXl1aDFkdTJLS3p5OEM5dU82S3BjOU44dzhheUVkVytKQ0I3OEozSmxheW1BOFFqTnBhc09wL3k5QldidSs2NHZNODZcclxuICBzZ3F3MmtLOEF2V2Zla21aNURmRUxIajkrdTh2OGliNTVOZDF3UVVlMDdkU0VTaERsMWlJai85QllMSUVENzkrUDR4NFVLVmZidGtYXHJcbiAgbDN2cERJdHpGTmp5ZXNYTGw1cDZtbFhnbmcyQmswQWRxRHYxbEN1TnJxNVpGQnA2ZVQrbldMVmRwVlA5MmI0bG5MZ05OSy9ZejdNaVxyXG4gIFowR0NxcjMyVzhQMzdBRWhlZlQ5UTBCa1FvWFY5NDk3M0tQNzdKVDZ2VmxsQmpkdVBuVGVUWUp1bURwdXhDUHYvTzl1WjRkNU53d2FcclxuICBMejhabkgxTURVK25FaGNNaTROZmZ1UkJ4eGFIUmtLMTEzTTNuT2Y0YzYweEtJM2FyNnYwNnZKQzRxek5FaUFnWFg5bWNDZTBzeUhtXHJcbiAgM3NFN005MllWUUIrdUtYajhmT0lSejZpTkR4dW51ZHRCMEFEaVh1RDIvT2Z0M2gvWU9IR0h4YWRob3B2VE1HQnUzcEtKM2xTdTJMaVxyXG4gIDc4d3p2MWxXSWIrOTdvYm14VXMvcjdDbXNLcGU5cElYRnVKQlRabU13UXhRMmJIMVBuSFFoMHBZczJmN0xKSXZ4RVJja0FFcUExUFpcclxuICBYWDc3SGVWZVBSb2tUVGFzcUU1clYwdnkxdjFiZ2ZxV3FYdXpmQ3dqNVVJOExtN2J0cnIwem01MzVWZDM2cENidEdMMlpLR0ZGaWp1XHJcbiAgNm9tTUlZVERmZ3pFUVhyU290V21MQWlNZ1ZmWmM1eUI4bnNuRGlxMk1VdUJSUWtoSHVLeW1SVEJXNkJkRVdHZm1PVUtsNVVIVUNDNFxyXG4gIDUrOVhsa2tTaUI4cmptcHh3QTNVZjc3dElPSUI5dDBnV3NwMVhmczlmYXRCeENQdFdGeWUwelk4MStDSHU4SFBPLzdHNFp4MmNzTXZcclxuICBZdjY2S1R0ODA0RTBtZGdCN2F1V24wd0h5U3NaREkwdDdjYWtKeHNUS2Voa2s2MzhtZ0JrVDlYc1FseEh0OTlHKzZJa3NOcHFyeXpmXHJcbiAgd1o0M3lrTFlXSXhLMWdwT1ZydTlKNjNYaFB4aDl3OEJTU053emIyQjR6T0hIVjgyRzlYdlZhYUJ3VDNNRGhzTEQ5b0FiNkF5UTBqY1xyXG4gIG9JSHJvTnpFVzc4YkJEYVZ4R1h6SUtxdEtwT2ZEQjYwaGdhZGcrN2pwM0VuamV3TEdWWW0vblRtaEVzYWcvTHBPZVdJaFU3K0IvbmJcclxuICArcjM3RnA1N25xSDI2K3IwU0ZmeHVlS3JQL0pSTDI1Mm4xSzU1RmF6Q3JBRmRVWXJyV09QUGFPZlozV2tESWdIR0ZRZFZGVTBicWI4XHJcbiAgdUpJWllMRlpKVGxNaXR3SVAxbVovQTFFL0M2LzNJdUw4RklZUk1BN2hJU0o3aEFQcUMycVVrY1VYaG0xaDJlMjhXQTloYTMyekdlL1xyXG4gIHBzUWxuK1FVRzdaMUp5MnJud3lvNGI5TDk1YjIzZ0J1MW00anBQaVZTeGhwTU52UE9qRy80dGNSRHozc2hENWgwS2JmOElaVnl5b1dcclxuICBXL1BtbTI4cit3ZFlQRTJiRXBiTTdVOXRQcVZ4NXRlL1ZkNVpQWVQxWXVBMWVHbkRrYS9sTzZiZFlKVkZreWJmRXZoRnhCWi81cUpGXHJcbiAgRnNnQUpEa1pRcFZCWDc0Zit2QVhOVGYrL2x0bGRocE5NQ2I0NjQyQXFYTXl2VFBPdUxEa00zS1FHc21mMVJCSWw3bjN0MVVUazBEZlxyXG4gIHBPcDlXMHZRYjJ3SllNcmozNFhWdE5VVEFrdFpJUEsyWVpEZmxMRzdHMzVTS0l1VEIxa0o4RzBINVdzNmlMb3Y0aEhJcHpZTmlYOU9cclxuICBpUWNZUngzb3hTb3hHWWN5WEg3Rk5lMktaOWx5dGJLYTVlQ29sbmdnYUQzYmdDWVJDTWhEK2xwbzl6a09icGYxZ2VVU0lCYUJ4Z0lhXHJcbiAgKy82ZFhlWFRoVTJEbHVEWlMwSGJBRFNBZkpTa053N1pxVXZJRkJnSXVjbWJxMzBMdzJBamxFYkJYOEtBKzJHUXg3eFBHaUdFdytBSVxyXG4gIDA3elh5THVnYWRVdE0xUHpOWFF3ZnNUalR4dnAvSE9QTGp6dVFIN3NUZ2FEcVBPanJSclZUd1lWZm1qc2lNdGZlV2dZZ2VmYUg5bUZcclxuICBiMjQyUm1DWVRwNXJJRXpDZVVlZEZKWlk4clhsMlI5dm1aQTV6MmJ0MHNOYTh2emU5Mnhjd3RoWFFUaE50aUZ2QlBjbUd4dHN1RjJ6XHJcbiAgeWFZNzlmTmN0eFhhWU1DcWdYMEQzakh2OG9sUGZiRzhQK25rYy92ZkdhZ2s4Nk5zV2Vtd1E2Vk9zZTlvbVNtL2ZFSENPaEJLZkFaMVxyXG4gIFlIYkZMSnUvS0RNa1ROUTcrWWZrTjd1THhRL2l4YmJDWGpUQUc2UmpUTk9NTlBIeGgzaFllV0Q1L2VJWDE1VjhrV1hrWURoSUdhVVhcclxuICBEYk16enZ4R1VWMnV3Vi95RUZhUFFmN0NEcEVCZnBtbFFhQnArUWxYYjg3cmdtWVNQOW9nK0xheGRqRWRoTVU3RHVwQlBaR1A1WDUyXHJcbiAgRUlzTUdadXdYMEdjVUJ1amhMalBLZmJaKzlBeStHdXpOcUZTOGtBZ1RCQ3NQaUtyRFhyRWd3cTFxUUhHVjIrc3Z0OElTQ3hPZ3NFT1xyXG4gIDB1Q2h2bmQ4YXFDUnBNRk9CeC9kLzNQOXNKbHg2RERjekY1aWRNN3pwRWcrZE9URUxjNVJqY2xHS08vNVR4aW83N3ZnbnZlNUgzYUFcclxuICB2bmNPYVhMRm0zZk4wYk0xdUhkaFJXTEFyU0d2TTZaTXVTUU1JM2MxRWFITnBOeFlFbWJoUzd6ZzJjV1NMMVZXQkJPc3lPcDZZWmZMXHJcbiAgYy9LVnF6UmloVmNiQ1BIVGNlSW5IZGJmZlRxVjU2dXVPTFhjZytVMllnSDhIUHpwWS92aDRzYWlNZTArbS9HaU9tb1FzcFMzeWxsb1xyXG4gIHdjYzJMMzNwQzh0cGZDRXdnLzd5VFdBZUdZSUJsK2xyYkx0QXVsUlFhVnlwcjN6TE9qKzFHei8rNHMva0t2STcvdmpoMTcwLzFwczZcclxuICByODJJMkowTy9BRVRNd3g2RW1xL3BpMnZjTURNUzhvQjNGZGU3UjNOQlZORWdJTElzY2YxVnBVNTNnQVF3TEF4aFUzNFI3Y0RmKzZEXHJcbiAgdzQ3b25lWE52ZDRNTjBoemthQVk2eVpsQTRSNkhNU3RYb1E1NnVpWmhqOXJzQmxYbjU4UkFpc3ZrMnBsQXYvNWRvR1Z6NlF3d2NrUlxyXG4gIEZvVHZRQVc0QnJZdW1GRE5MWHk0VGRmVVk5Tk4xMnYrMUJJT2lnQU9oalBKb1ZHWk0xTnEvS1Zkd2ZhMHNmUXFyRFh2SDNuL3NMQUFcclxuICBMMWFqUk5taUNlVHZ3M2Z2WDdqRWM1cXJwMDYrZzlsaFkvM2pIdWVqUDZVLysvUHhYY1ZwaVc5bEViZGNoeUg1c0JTWGo3QU0vSVV6XHJcbiAgZ0J1c2hzVWhmbDFHT0JDSHN0cHdoaCtkK0FQUDNpZXRoSU9rWFVOSDQyNmxKYjRuUEg3QnZsWlI3VmYrMUVmdGhqREpXKzFtQmVjc1xyXG4gIFpBME0yd2J2Rzh4aW8xbVR1QWpjWTY0RW9jYlNxdVBqTC9mS2hPQndNMUJpNitERmU4L05ZSXNWWkNlMGpzcGQzU1dzUDNkK3VYdDJcclxuICA3NHA5NHQ2ZnNOL3BlWG1mK3BlMjgxcTRFVlpUb1NTSHM0L0Rhc1htS3VXanprazJRQmxBSHJBdWF4bVNlcVptbm56VHJMcXI3V3pxXHJcbiAgQy91RmF1eDg3WHVzTU4vUTdKcy8zME9keVF0M1YvV1ErbUxtaE1iZ0c5KzRXbCtWMXp2c0t1K1ZKMjJCd0pzaFVrUkVPektwUWRBWVxyXG4gIE1PUVhtQmhCT0ZMSE5YYllmdk8rRzZKLzJlVS9LcXE1OGdYcWpFQTNpaVBCeG0vNVlGbkZKS3c4S1VOM1lCV2VuT0ZyWC90R3lVZktcclxuICByQjVxcEV6cW5oLzlrcklBZjEyL29BMmF4ZWZiZ3JUazU2MXY3Y2w1dXFCdFJyR0JmMzVwVWtJZHh5Z0lFeUxsbjdKeTMyRDkxY3QzXHJcbiAgUmdESFFWaDFrUGk2MThDejFXclhmWGF4d2lxYmx6WEVzeFo3YXZPTVp6NnRUSkFRRHJLNlgvN3F1bmJDZVdFNVo2ZUdDVXlQZmVXclxyXG4gIElDRFdIZys5L3dpSUQreUlSS3FsN2xXbWF3WjR5UDNDQ3kvWWw0OEVhYkNUSW50Q1hJVk5BdzZTZnQ2Tml6OGYzeFV2M1lBaWpPZVlcclxuICAzaGdHWmVJM25WOW5kUTY0d2Q1TWZSQlBObkZMTStFQ3ozVitFN2UvSlRiaWdVZ2EyTHQrNVlXbFRVUUNJY2RESmlQNGZUdDdydjA1XHJcbiAgc0dheFo2N1NISFhrWGlVT0ZvT3QzT1FwMzh1MVM1QU1kcHRzdW1PeitETm1OVzNOTEF3dEhyTng5cEhJQnJBeWRUNldrc1ZsK1c0RlxyXG4gIFl1Q1V6cmJiSDFBSWxMcjFESzcrM0pJUDZkaHRyanlFNjltSlR4TnB3NDEyS0lMbURISldHNTg1OUV2RnI4UER4QkhEaFlUZTRzSldcclxuICBJSjlSN3ErZCtjM20vUE12S1huS24vYVo4S2x6QkVnNGYzR0lTN21zUms2Y2tuRjR4Ky8xTjl4Y0JLVEttUUdWdTNwa080dy8ybUxxXHJcbiAgMFR2UHlzdVBkSFBvRm9GMzZyNE12QzN4U1B2bTN6c3J1NngrK0F2cWZxQ2VyTDZjR0VuYnplci9rTTk4cVdnbmRvbUhWV2d0NDVET1xyXG4gIElPSUIzbEhBTUZncHh5RnRuYSs2eXN6K0hNaW5PazFaeVhoRzlVZkV1d2lZcTRsUHdnNURQUkRMRi8vVEdaeUY4ZWMvNGVQdU8vLzNcclxuICBnTDFhWGRTcXU0a2pWNU1BN1R5SXU5V2U4Mi9tRkZhTVQxNTRvV2FOZG5Ma3FHT21rSXdSajNqa3c4c216Z3N2L040c3FydGtZNHl4XHJcbiAgOW9oR1ZpQTlyZGI3allVRnRmVktEUS95TWFDK1gzUDEzaXdCTlBqdStSZVRRQnJDbXMyNStqQlUvdXAzM09vT05RenhpMDNCeEVQa1xyXG4gIEt0dzFMUEZxbE1NZ2JCQ3oyTUk2b3lIV2Z3Y0JpNG0vT28vMWZSQzNYTU96VHozWFlQYjhqSFptU0FoTGs4VGdDM1VlNGE5L3VyUmZcclxuICBKbzFPT2MxVTZuS21FMnFrMGhiSGgvZDhUM211MlY1dmE1ZlAzbU9QeGRTTXNMVjFZWWc3ck5NTzdPNlRYdHlCVzUwUFFsNm9XUUlHXHJcbiAgM1RlK1lkV3k0VEI0OTlaNzl6dXRxL1JvWURFTElqNzVzSUp3WG9tNnd5dm1yLzViS1dCdnBXNlRsNFNISjdRRGZYMW9HbmYrc1FwaVxyXG4gIDVibjJiekNFbE4rS0l1K3RTc0JtVHpBd2V5Y3ZqRHNLNHcvY3NheGduNzIzS1ZmK3BLMU04UWNmMnVtZzRtNG5mMVJmS1JsWXNkVCtcclxuICBJTVJEZnZKblFiditKb0U4MFBTSlA4OEhmSFM3cWJjejRSMzJtMjhYV2FIK01BNVlZQ25USkRCQlF4U2xWMk9TOFBLVU1nNjZ4OGFkXHJcbiAgRGhLdWpzc0VKdGF1YS9mWU9wc1Q3TlBHcDIwdDh0UW5GdXZvSnRSa2ZxOXRKMXFVWnV5aDZob05SY1JuSXV3cnJMNi8zWDhyRUtoblxyXG4gIEZybjM5MkZIM1FOQll1NG54Ykx0RElxUWlKWlU0c1R2RSs4NjY2eFEyR2szMzN4cldRWFVhUTJEOTlnVVpoMjBNRm95WHR5RVBlMzBcclxuICBDOHFIbDg5QlBGNytER2hnMXNXSFoydzl5L2RCNlh1T3VuRENnaDNMaU9JZy96cGczYWlUYnRldjlHblZpRHN3YU5UNVVIZG1Jd1NrXHJcbiAgVlAzRVkrWkxqWlRRV1NjRy9xMHNtVTBub0FQdnpINmY5WjlyektKcTZacHZuODRpVGJOUXF5Y3NDbjd5cDNGRWRkUTk0WE1JV2ZMTlxyXG4gIEhiS0pLOCtKRTh0S25TenpzaVdiTjIrOFF4a0VsUU1MQ3VRRHkwdm5XbjNLNkIrV3BMKzRGaDJ5NFJRTFRGakNidnNDTW9zMktDa2ZcclxuICBEYXBvKzlsQlQ4aE9FSzFPc2J0QUdIR0VBTGpuWC91Z25HQ1Z3bzBHb090cWJmNjhXMkNCeC9URHhjSUN0bzdWenAxLy8zdVp0WHBmXHJcbiAgdHhsNW9ma0lDT2FxcjNsSGMyeTcwckVCTUpCM05ySnFWVjM1VVQ4aEhtQmxaU0x3MFk5OG9Ed0gzbmZibWp6bWUzZEJqUmxCMVE2cFxyXG4gIE9pTmMrdWNndnhRR3RMdk15dm1SSGk1RHZua1hKaFBpeEVKemZrekM4TzlhcTZnUEEzL3F5L2sxQ1J0MzZ0NDVnWEFVUnEwK0F1WnJcclxuICBQR001ZHRXYjV3U3JyTHhaV1VPOGY1dTNsTTJEeHFiZlgzOVRXZTEvOVdzWGx0VkhiV0hhU3Ria0U1ZWd0L3F3V2RwN0pseitjdjhTXHJcbiAga0h4QTEvcitjMjNuandFekhTUVZXOS9YL2lkRlR3WHhzTUliVFZoWDBKbXNhdFpmL3pYRnJUdDREZ00vVEVhdzEyOFpxTUdiNGF3NlxyXG4gIEphQzBJYXplOVY1RDNEcVl6cHpPSFRhVDlBY2grYzBBZzNVU21VTzNzd1k2Wk9KSGdMQmt1bjdkRzhCZEUzZlNxdjFTMDdTMzQ1aDJcclxuICA4S1l4cFU0UlpyTVhzOFlJSnpWT0E3dkJCcFRSVElZS3Jyalk5RWtaazdaOURMR0U2anNqSGlBZi90eHFYWHZwY3hNV2hMUHk4dzJ5XHJcbiAgRVNxREZYLytCbHNEcXhWajlucWtia0IrclNqMjIvZjlmWGNyQjRQK3VOa3dPUWwxVzFvczRyVkNzS0ppNWRUZ2lEM2dmQWZFQ0NFeVxyXG4gIE9PQXJ5NSs2RU1hOXNtWlNBUWdMNHNGWUprMGs3b1V3dFozL2hodHZtVVhPa2JEVWdXMk9aSFVnSUZDbklscTNyWFBiUWZoNVM2eFRcclxuICBDUDFCQjM2d3RDV0NlT1pRV0Fmb0VnOHJ5UzhmZjJBeHc2TitUTHIrdDIzLysrN3p2aWxmUGZCTHd3ZWJrNllWS3hENXp0cENEVzdLXHJcbiAgVHJZa3p2eHBVYVZjWFZEQ0VHYkdqSXVLZVkyd3VqYlk0RFg5VGNNMTVJZUpITENCMDRvUXhBSGU1MzRZck5KcEU5bzBLOC9hRytBWVxyXG4gIFdGSC92ZTJMZzlUM3U1Q1diNUE0Y0JXRUQrcTQ1eWJ4c1BQOHZIYTF6eVRPNzM5M1EvdE5GaXZFZzNxOWcrQk1oSys2dXNjQkNPeWRcclxuICB1dlcydjB3OW1XU3BaZklkTEszN2VRVUNESFhsd3gzM3BUTkxvNk56VEtaZ2FaOEJBT3A3cUFuS3BPakY4WlRTUU1VbERnM2Fmb3pNXHJcbiAgZGpJVHJOTWFCbjRNT0RRN2FFcUkxNEJOSUd3MnhWNlJCak1zTHU3ZUczaisrTWMvbC9LbkE0VWcxZUEvNy8xcHhMZ0czWFR3MGMza1xyXG4gIGFXVHhGelZCSUV5c081dTY1TWVLaGZBYk5IUUR1UTVLamdMU1lOUHNmRHVoVzBMQjdBRTNwa0hVWnoyVGMwKzQ2NUFqcXpWMVMwUEpcclxuICBRSTM5aGYwSDByWTZ5RGZXaVd6R3MxRkwvWUNyMlhmTXlRUk1nMGhuM2ZYZTA2NDYzbExDTWwvRDZLTzRERXdzQWh0b0VCamZHeUZLXHJcbiAgMnlIWGVOU2o1MnNlUG5YY01YZmgxQVcxV1dadXlJUXM5Vm5DeFIvR2MxZVd0QlV6L1ZOT09hOXNrUE1NdEF1bGRYTmJueFFDcUdvaVxyXG4gIEdGaUVJUmhKUzltNlJJTzdldGNHUEZNbXlIdHpRYnZqd3hNWG5rekpUblB0WnA4UGIxT0l0UFNWUTU2WldhbUpCNE9ONUUxV0hmd2hcclxuICBhUENPTGZjbzV0VnJ2L1lGZUsrZW5UWUk0ajNpcUJQTFpzMGF5a0gyRk5ha05pWi8vRXVuaG41TzlxUmMzb013NlpkZEpCNS85U05jXHJcbiAgaE95ZUJ4RVA4RTY3NEE5UjkxeUQrempVKzE1cUltUTFEcE1Rai8zMk83TFplZWVlY1VWbGthNXZiQ0lXeEQxSXZ1Y1VyQnhiUnp5dVxyXG4gIEpmNnJ2V2JaSXRjNjRPUC9VN1F2MmIzU3BudXlqcGtneitzcGpLaHAvY09WNlJZcXZYZmYvd1JFZG5Sd0E1MjlBeEVtTXVMRkpvc1BcclxuICByVUpkNi91RTdUYUVjZWdKMDJldU1OSklhV1c0TjhEODExTFA2NmRUcHpjTS9KaTVpVlBEeGxheDdFc2FNQ3dPN3cyVXozNzJmNVNHXHJcbiAgNUhuaGhSY3FHNytXYXZNeENPTHlUMGVxWVVlL1dXRU5kU3ZlQ05MTlloRTdNN3gweE1DOWdTaTJnTHhIQkEwZ2RTUG1qd0RYYkZ1OVxyXG4gIDhjZWE2TW9yTFZNMG9OcDJOZVd6cDBPT2JYVlRPMXRPdkFqUDJpM3g0TmQzVE56aTFXRWNuMGx6am52cUVLSVV3S3lKbVNBd1I4RXNcclxuICBoYkQ4YWtkMzNQNjMvaUNzQTdobmI4b212RCsyMzBkK2Y5eE9HaHpWUzhzcGdtL3B1UUkvMm9NNk0xakVtS2VadjJ2K2tIUDdiVEMwXHJcbiAgVXNsZ0VqOVdvZUpXOTU3bDB5REpPR1JPdEV4K3RadmtBL0ZncE5GK0VMUHVQLys1ZDg1OXpHUWtIbjVaODMzckp1dVVEWXBZZmR5OFxyXG4gIFc2Q05JMzBwWVNnMjNIUDNQWVdWa3pxMnFwR0g0NzY0Zjk4ditCN3FnRC93am4vN1NENzlxWjJMVzBDQnhLckZlL2tFRXhBYkIvTmNcclxuICBnNVZrOFhyM3RDbGJjV21UZFI0QzcwQWJqV0ZPYVkxaVhVRjJXUE92VHZpZFpHRGV1L1V6S044aEh0UEZKWmRjV2RoejBzNHFveVllXHJcbiAgdFh1Z2ZPUHlPUTVZekRnN2huN3R3eEhLMzI1WGpsVFZzZDVNRGhocnJXRlB6dyt2L2xsN0YrRzV6Wi82cjN1cmtvZmV2MEowOEhGb1xyXG4gIEFZR2xzOWtFck5mT3JnSjgyT0R3cWFOU1FWaVZPMzBZc21ZS3pYeTA5NzZuWjdiQmtodnliaElZbU91OEdPVHliSlkvS3AvZUdSUzhcclxuICA5L2ZzNENTRFZOd0dJZTc4MXpESURRSi9MTVM2SXRqQm9ITFc5bmRBV2dZRjlWUURHMGhqSjFBMXVFVUFibE1mdHpydnRMd01zdllXXHJcbiAgZ0hDbEU3Y3pYZGNjdHd2ZVlTRzVKczI2VTVuWlVyZGw5NmgrNzQrWG0vTVR6QmlWNzcvL3U4Y0djRStiek5WTTNlRHRPRmNFU1R5cFxyXG4gIDc5eXJLM0d5akp0NzEwSC9wRS91Z3AwWjk4U3BYUk9NdWlldkNzaXY1TWVKaDRtL0J2K3BHK1hKZSs0cHUvRDA5S01SaFowSTNNVVpcclxuICBrL2l3eDU2SEZEWVV4WWF0MzcxaDZRbmk0dGQzNEwvRyt6NndYLzlkWUxMRjdTTWR0aFhiWXdUQTRxdkxicE5tdDF6QXYzaXBIU3VMXHJcbiAgRGJueE44aS9WWDdSdW1yZllWL08rdTE3dTdXN2lKOW9uOVdnSW14bE9BcUd5a0V3SVpvdXlENjI3UnlJTlE3eTMvMG1zNE1vNXBqa1xyXG4gIFhkVDJIVUp6WlhqM2xtOHFjaVRtK1d0WVNkTituUW1UVXFzVEJJUVFYYzA4QUZZZ1FDQVd0a2RXRlpsWnVPbzR1Y2VQemd3RmRFd3JcclxuICBodWtnS3IzcnI3OWFtUkZMa3d6RTNnMHlFRVJFcDZzN1F0SWJCRVFDNUl0LzE4eVVzSmlFaDJGeGNJLy9oTVZqSmt4M1B5aGN3dmdqXHJcbiAgTmxDblBTZ01YM2tQS1ZzOU9BUjFudVFGNjJ1RmxnaDBWeUxnMjYzL3BtMzdSRi9ZbU95bzQ3Zi9nWWFQZU0wQzg2M0JBUHJxbHVnWVxyXG4gIHpPdjQzWnQ5a3lFZ2JKNVRuK25FbnBNT0lTbUk5eXRUTnJtc2dMRGxtSXI0NGhlL1dqcGtEaVl5c0NCSW1mMUQ3djNGVytjMzlVZjFcclxuICBtc0NSbGhMRmkxOVB1ZE9Rd3JKeXovNFU3U21zdEovOTdOZDl5N3RXSVY4Ni9zeG1sNTIzTEpNTjZmbUcyRXhKTStuNVJzcVF2Q1UvXHJcbiAgTktzY3R1V2Q4aUJLd29qcktVOTlZaGtjYXhZUTgvZHYzWHlYSXA5anhERGdqMVVJWm1xa1ZjTWtnTW4ybzQvYXUvUUpZY21OcUQ1M1xyXG4gIEJ6WDU2aDRURFZZSncyUVNObm15NXZ2b3RuMWxGWnQ2SHdTelpIV0tOVWlOUEczaFY3LzZYUnVtWi9XNWkvZ1JwM3RnMEJKYjB0aUJcclxuICBEVGdNTms1U0VpRjhaMUluNFEzcW93NlpHb2JVelRDaU1NaGRtS1E3SjJEcXgrcmpWKzJLZTgwMWxpOGNDRzBQbTUyQ2g0MnlOWnhRXHJcbiAgeUFyQWozL3k2L1pKUHlNODF5TEYwdFBvaFB0OUJRSUhmM0tuVWxGUU43NTZ4cEI3NzJ0M3dxZjRueDcrVVFZV0h5MXA0dFVEdGdWMFxyXG4gIFp5eWpJSHppY2MxZi9KQjN3K0I5ZlVXVStNZCtpbm1HTHVJWEM4eXFvbzUvVUZyZE5QaEpCeHZtMzhCT09Fd3JTYjFvNEU1VzdQby9cclxuICArY1JQbEpsdDhLSVhQYWMvY0tRT2dxU3ZmblB2WUtSZGQ5NmlPZkhrYzVyVlZuOW4vd0FvSUF0RDNCT1BQQXpxZ0lTY2tMenhJMzdoXHJcbiAgRFlEWlI1VDNWN1VycGgwK2RHRHhrMDdLNUhuaTVxL2JCck1hSmd0NWZsc3ZoT0ZrZGpZTWVzOFVpSldXZTNzZXdPRmI0clFQQXpFV1xyXG4gIEwrVUgyb0RNd0VpYmpUWHUvdktUdkFNM1pmZFh4OWdLZGlobnhjRmRlbUdUS1dmQ0dpUldYM1BMWnVmZEQyNzJiT09rQ2gwSVkyWktcclxuICBqVHYrUVhxSUJ6YWsxVU4yODc5bm0zMUwydDI2NXorbWRjVGpDbGJTbzNaMnl5dExBTUxFcE1jZzJLV2RPUGtsN0syZkhSbzNEUEVIXHJcbiAgYVQvcUhycmw2RUxlaE1sdWNNY2ZCTjJURWNlaDFyeWFGTkllbDhkSkVOVmRaSUQxZ1FNK3VtMGhHalFxVFhpd1NMdXdGNnhub2tpb1xyXG4gIHJENWNzL3Jva1k0SHhBcUVRRE44U2NoOVBVTWRkZzkxMkVraGZMMngwT3dualQ5WHM2TDZ1VTZ6aTE1ODN5dmFKamtYSkhHSTJ4OUdcclxuICB4Vkg3TTF1bU1mV25QLzIxTDV3ZkZKWWJCWUJIUE9JUlpaWmVMNjBIaFVrK3dZQVRsaDNZNDVEVlZFQnJ5bUJPem9EVkprN0NidHBNXHJcbiAgTnRmVjhWdUpaT2FNci9yMFJSY3BicDg2K05obXc0MjJML3I5Q0NMNFh2NEdLaEJHWFRFclliT2lEWGp4Qy9HdlU4bi92QzF4MHNoMVxyXG4gIHNMeHpFQlFldkZrNFArSTBzNWRYN3hPUFBNc25WdFBGRi8rZ3JGck1OcmtqeGdZem5jcHpQVE9teFJPekZ6b1h3azdtUWFBcXIvRkxcclxuICAxc0svZTRNMDRrSW1jK09OdHhRQk9tR2xmRkJEUlZ5MEwvNlRONUQvMUtXNFQvN0tqREtZV3pHRTVla2RPUTVOSGVHc0VCTWVkdHJsXHJcbiAga3kzaFBhNlViN09wZlRmeWhPZnVkRURmUnA1cnFGLzFGNDZBdExBRjdSRkJVR2lSMVVoYkVtLzZDWmgwRExOT0d6L3hMK3gzdjNmbFxyXG4gIHZmSVNJRTVXa0FaK01xRW9oSXhhZVloWFhmaG5mT0RtT3AzeFFoamYyVmtoV0pEUGUrNHptalhYZkZXZnFFMG5IdVVOVVVDTXlEcURcclxuICBRY1JpT3ZHUEF0VmRlTUVTeis2ZkpJcGRTQlpEY1lsTTBNby9NQ202N2JhL1ZMdlJqV2MwUGEwK1RLQ01NVnJmL1hDZzFERElUaHAvXHJcbiAgN3YxVjRxQjduVHpXWGV1dzA0RkJZNU5OMW1sT09YVkcyUWt1ZmhDWEJ1cWF4a2JZVkJ1UUd3UmhzQ2RjcjdqaW1sazZWRHB2NGgwRVxyXG4gIDdrbmJ3RWVUaXpvc3JaZFJZYmxiaWthRHE4YWdNSjZwY3hJdXN4aWJOTVV4S0g3RUkvSU5RR2dJRWJFVzhiR3o5d0RTUVExQzJGamlcclxuICBOWUN4TlVVVHF0c3BERlRjcnI3bTU4M0Q1MzFZR1VROEd5UjBLdXhOUkM3bnRBanJiekJCeUVKUS9HbkR0UlhYTExua2MwdTZ0TVJjXHJcbiAga3lhL1NkdlZRT3BxcGFRTkdleVZueXhPL3QyN2VrZG1ZdU5kWnRUTVBuaVBlQVRrR2RIa1NseVBiR2Q1dDdmRVEyZU1hWHg3QmJ5VFxyXG4gIHRtc2dueUVhdmovK3ZQY0lQZUxoM21CS0FRSGI5dFRUemkvRVE5dXE0MUZPR21tNzdyUkZxVGZ2MGhibHkwcUlhWmM2RENEbTNGSkhcclxuICBpZGRCVm9QOGcvckZlc09xd2c0dTM2ck43NmkrSWg3aHZuanNHY1VJb2pJUG0ybGJJVGxVekRlUm4weGEvQmRkOU1tbG5nYkIrM3p2XHJcbiAgakE5bTNOVFEweDZHb1JhYzgrZVVRbnVPR0dnMHdSQ3YvSTRUM0FlRDluMGdSblhZYnA2U3hweUM2dTZNZHNKQ2tVS2ZMWnNVRHp1aFxyXG4gIHlPbys5dkhQRi9ZclN4bzFXR3FZS1JPeDZyRGFvTHFMaUZpQmVPNU5WQjh3Qk1RSFZvbHBIUGlUQmlEODJSaTUwL2lqZmJMVjFoL3VcclxuICB6NUw0cDRYREpQRjBZSGF0RVREWElBNk5PaDNOOVpaYmJ1MFRGb1FoK1JzRzczeDRNMTdoRWFaRkYzMUsyVjJMZnhzTm1sSHhlQWZLXHJcbiAgS1Q5bXJhNHdMR3p5SG4vQXIyY0MvdTZxQXN4a2Fid2xYUHo3RDhwYjBvQnM5cElYRzQyWWx5WUlEWFFFblJhN3hiMjRJV1d6SW5FQVxyXG4gIFZNRFBLaXUvdkordWF6cVFPdHZtQXg5dDlwdzZjVEdkTElvQW5tbnUwSHhEZkc1dFZ3VGNwTFhlYTFjcWNXVkZBbFJwRFVqaXFtZWlcclxuICAvTGwzN2Q3N1kxblU3SmhyZi9hYllvV2dOcTJOZUJqUWxEZmhFWTJYdnVTRnBXMG1ya0NlNUlHMmkvWkxwVjFlaFUwYzZ0dzVEZGlIXHJcbiAgL0FwallySEdHc3MxSzY2NHpDenhxVE1XaEExNE8zN3c3Vk91dmJiZzNZenpMeWxFZDlDcXc5OEtJL0VKay93TkdzaklYN0pxVTJaN1xyXG4gIENsTEhWczZqRUgrSWg3MVhyTzRPQW4vNm5VT1U1TU0zazY5VFR6dXZYZUhlM0taejczWUt5cUx1aEhmTmQwYmdiWEMxeTM0WTRRSGpcclxuICBqTGQxM1JMYUI5NVIvWjUwWjdoODVCdW95MXlEN2pNazczT0tsYWMyRGo3bk9ZdVZQby90ZXZFbFZ4UjE4clBPK25aWlFkY3dPVkcrXHJcbiAgbi8yOHg4Wi8yRU1mMDA0UTdFeTMra0JBWWcrcnQySjV3QkFReUljR203M1kza0U4VkthUGFWRE5mV2F1K2NpT1I2MC8rS1NRcG8yRlxyXG4gIFpqcFlBT0lFY2VXQXF3eXF3d2JYR3ZMUG4zalpZTEpVOVJ6aVlRYUYxVFFzbnFURFA0R2xNR1lKWnR6Y2RjN3N4NmlSY0FGMVhvb0JcclxuICBDQmQzLzI2YWRSaFhhUTN6Qzl6OHY5NDJQSU9VVG1oejJ0bG45dzdtcWNHZmI0VDE0Y3lCZkN0L0c5eDIzUGtUN1RKNjV1NzFRR2ZLXHJcbiAgZWViQ01ER0MxNi9KN3RFU0VmVnE1Vm1iMDY4M0ZCb2NWMTcxN2Mxbmo5cTdDSDFENkVBbi9VMDdRelpJbi9iVkM4djVJZDZKbTdrU1xyXG4gIDdDbnhlNWJQR3NsNy92YWlJQXhkZHl2R0dyNmRkaVRlcEpVMEVGZ21VS2lYeXBQNi84VEhQMVRpWVNhZXdvSk5oMWgxSVN6SzUyb3dcclxuICBDTjZ4eGU3TmtVZWRWR2JwNUluWVBGa0JnVDAzaE02MHB1SUcyQllydG5YTjdlTUg3bERhaXhWRUJqdnVYV0lEM2ozKzhZOHI3VnM3XHJcbiAgdzY1TU94SjJGUEl0K0RPcmYrRVNQWHRqZzhDZGhwQzQ1U1B0VWo2SHNhNUFHdXJJSC9JOWY5dE9OTHA3TGdaQnVIeXZ4S0hNdVJlWFxyXG4gIGJ6OEpKdGwxM24yVzFpQ2lQVjFrNCtDVDJnbmtiUzJoZUdMYjNrMUk5UXVUTHNvSXhwa2FsQ20rY3NwNUxkR1lwM244UW85dC92SlhcclxuICBLdzJUUThTRDM1bXJENWpuSDMrL2NpYno2MzZHaWpSYnhyN0ljeHB6S25UWVBjVC9kR0VWZ3FJS216Z08rTmpueWd3ano3bnEyTFFUXHJcbiAgSm9Fd0JQVVJwcVlSaWdkYmdIcm9NQWdiTUo5T3JoSTN3c21hZjFyRElJaG9KYzgxdUExQ2hLVGtKd2JBY1lOQjRzVk9vZEpKVThWR1xyXG4gIFFTWWlJdGl0b2R6Z1d6SFJiY1ladDFQYTJlVGwvM2R5dWEvaFBZSmhRMXNndklGUit0TEdtMWJldWcwRXdwdDhmUG1rczV1UGYyeUhcclxuICBXZklnUEpNalpETGNmUlB4Z3MyQ1pxbUFEZlBYdjk3UlA2c2huWng4cEZiRmhieERpTENWRXA5QmZjWjVGNWVaSHpmKzBnYWtuZng0XHJcbiAgVjk4SDhkc0Zmd2NkOVBubTFwYkFXamtFU1FPd0lheUFFUEF1cE0xdkhUWklYcm93K2JINnJKRzhNYjFocFRBSzhnekMxUGVEMEswVFxyXG4gIElGOUVVRWVGOFU0ZnBjcmNMVWZlRDhOcGJWdGNkOTJWU2pteDVMUnBremh4cUMvR0g2bXJ6dzRjbDIzaWxHOGVkSjloa052c1lMNTVcclxuICBYMWlHZld6VytSODlmOXVPNzJtZThJUUZtazAyV3JzNW9wMXc1Qnlmd0ViVDdUNndhZk8rYlQvYVBqMmtlY0xqRjI1dStvUDlIb2dHXHJcbiAgcFFISGJzeEtRQjVRS3hDVWZic2RQdFpYclRNTDBCbnFHV0gzdnA0dE13bGdzSjB1bkdER0JBZGhzWlBvTkRUbUlTRHgwMWF3azVwT1xyXG4gIGZ0SWJCWU95UVE3UDFSa0IxRDB6aS9KbkdrTTZ3K0xpenA4R2YzR2JkdjNzdE1Ia3F3dGFQa3hvZUcvMnpqK1ZVNFJzV0JoRWcrMG9cclxuICA1clp0MEJPRzMySCt1WlZ2OCtxWGxtV3c3NkR4K1ZiQzVMc0Y3djN4Mk5kYmIrVmlhWlRnMzBCcnY0Y09veTY2WVF4dTNCRVN6KzdGXHJcbiAgcjNOaGIySU4wbVI2NWZLYjlNTUU3bWxmSVNJTTU1a3hocFhsT3lBQzJGM0tiT09mTXZsYldYaXZURFNxSHZPWStZc3FxN0Q1cTljdVxyXG4gIDhrNmVzUFhjeTRQNG43andnaVZ1ejZuUDFLMnJnYzU1Tk01OXgyYmhUeDVxLzRHOVBMVFVqdi95V2NYVXZUb1NuaityTFVRdjJuRGVcclxuICBtV3pVVVA0WExyVmVzZGNWRnJEdlRiUHAzQmtYbFh3UEdyeUVzM0x1SXF1cDJsSjJEZUhrelJXa1ZkOTM0WjA0aFZFSDJvWXJ0V2R0XHJcbiAgZTFBWXNKdmQ0TTcvS3UxQUw3ejY4NXd4dzM4VW1CMGlRTVkyQXh3UXJFc1RDbkY5OW5OZmFmTTNtZHlqQzNKQUt4L2xFeDc3ajlhblxyXG4gIDhZU00wY1poYkdEbWdISTIwWndnc28rRm4vajRzdDlwd1lXb1lQK3RyTjdaYlR2OTlBdUs3S29HT2VVQkIzNjJiUXUzdGF2ekJac2JcclxuICBialJac1BwQVBPNjkrb0RSYTduN0FmWFJsdmxRR3MwdXUzMnFmNjlSNUY3bkNUWjcyK3Y2alhNNmNNaVRoaEc3TStHUFNrY2FWaU1iXHJcbiAgdm1tTkVyZm5TZEtvOXlqZ3p3c1hUQnFIcFdhZFpoMXVWQnhZSm5hWnh3K1YweUNyalM0TUdnVFdCT0pKQzl3UFNvZi9vei83bFhJZlxyXG4gIHYrQiswQUFFVmllMGtLeSsyQlFLOHAyZFUyN0pYME5jT1cwUUlRRUhaQUcvVnF4V0tVNnRsRTk3U2RJK2dxM2V2V0UvWC83ZTQvV2FcclxuICBGT1FVUHl1OHRLV1VWNWhGbjk2elJDcWNmR1lHNnR0UVZZNWNKS1pSVmw3cDVVVW9uekxWb0UxbGdJYWs1Y3F2d1VNK3BWUFhKOGdQXHJcbiAgNHV0ZlpHSS9QN2M1L1pTRG0vUGIrcXpyZSs5OURpdnhxZWU0QlluRCt6Tk9PMlNXOTlyS0dXZjJqUGQxdzRINjZoNU01U3F1ZDIyNVxyXG4gIHdiM3lDOUpMUGRiMVdkOTNrWGZ5b0o0OXUzZGwwbVpRbUtETGlra2JzTm9WcnRzbUJrRmEyR3ExM3loRm1EUU1xcHRoK0hKTGpHcG9cclxuICBFMWF0NGhBL0ZXRlFMczg1UDZTV0RjNEo5cDdxSy9mY2RWZFpmVkRuUnFTc29waTQ2V0xGZGpLSXBabVRDQi82VUZ3V2hNT2tZVmFpXHJcbiAgRVZoVlA2QllXSUVHazhheTg2NmZMR2FvYTdkaDk0Q04wdDFKUFFrU2o0K1pqNXpHYXljem9SUGhaZElpMUp4RVdGam5FenpYOTFZOVxyXG4gIDI3Ykx4bUdJWCtDZk9pTXpGVUhpNzJKUWVqVEpvZ00vTEJ6dHRwZ2Q1MGM5NEttVE13d0xZMkF5YUdsOE5tZ1JqRDdrSWZNVTh4ZkRcclxuICBPdDFMbG5sVDg3MkxqKy9YTTFDTlpBa1VtOHU1NjRQQzhvK1EvUGFYTThycURoQk1iTUtVazgyZi9mWjVYM05tMnhaMERBUGpzTHdIXHJcbiAgWnBkV0xBczg3akhOVlQvOGFYUEcxNzdabHZrNVpSVnBuOGVrWU1UUmdWczBYcXhzUWZvaEZCQ1c1REE0NXVCM3Y3K3hzQWNoNFVCT1xyXG4gIDBtRzUvKzczTnhVNTE2Z3krajd5WStjNThKZTZraS90d2tBMkNMNGxXMG1KMjlHN2lLYzZINVplM1dZRGZyVmI3WGRRT0xOL01xbmtcclxuICByYjRhL0dMaWFCQ1NYdjArWWV2Mk5RemRQUnJ5WWlVdTNDVGhCeUZ4RGdyZmRadmROSWJCNm1QWHRvL00xeEtsUjgzM2lHYkI5bnVwXHJcbiAgZCtac3NIeXBqM2NIL1ZOTytrUXA5L0ZmUHFkZDNTL1MvT0tYRWE0akhyUzA3cjM2K1BvWmh6NndXRmpCb1llZlVMUnlnQUc4TEQ4MVxyXG4gIGl0empLVVpGa1NBd1pwVFpSNHEvNmFBWC82WHRjcmxucWRleU9RMlRuU29kemV6U3FYVjAzTEdseHFYUmk3UEhkdEdZOCt5ZW0zOVlcclxuICBac1BpaWxBei91M0V6VE80RGdyTExXSE1qaDF5NDhDcU9xNUI0U3h4N1MySWVYSURVL2plWGRaVUVGYkk1WmYzekkycnE1MTNlbWRaXHJcbiAgT2h1VXU2cSs4TTYzdjZGMEhNU0FUUzBzSnBwM1ZuK0lrVG9oVERkZzFtbTZ4NXE1K0pJZjlNOWR4eGZuVDltb0dCOTZ5SzdOM1hmZFxyXG4gIFhYWUwwMnpDWGxuMG1hczBLN1R2bFdIQkJSNTdMODAwZzdyNEVDWDNab0xTd2lwTFhRYS9hUWZSSzYvOGFUa0ZVSG9MUDNHaGtqNFlcclxuICBxTFVQa3d2aC9WT1BydjcxL2haSUc5bHhwNE9LYlRIeUdSYU8rYVhSbHpyUUpwWFJzNVdNc3EyOTVxdUtPNzlkSUJ6S3E3NGk5QlZlXHJcbiAgZWllY2VGWmhXeG00c0ZDNlNKNndkSVF4ZWFLdCtQT2YvN2JmSmdmQmtibjFCRVFjcmdnUi92dWdjTktpSHV1ZCsrNzErQlBPS3YxeVxyXG4gIEdKSUc5dDcxTFVITk02aXJRWFhUaFVFMVIvV1NHeVdjZXRmR1dHSWd2SjhFZ3dUbmJPTlpyWHIydllJUUQ1TXRmVzV1d0w2UE10VGZcclxuICA4NC9tcnZhUERXZVNzTzdhS3hTWllGZU90ZjRiVml1VEhoWjVXZDU5NHNKUGJ2NXdzeU4wcmI1b1hjMDA3eDdZcWI3SDdsczlNRmNnXHJcbiAgWnJJWjdDQ05pZTBqQTFQdDFyMkh3dzQ3b2RteVhWcFBGNDV5WEdmdFdXMzVkSyswT05LQnV1a09RdnpnMVVjbVVidVQyOVNueHcwQ1xyXG4gIEhqMlpBVC9DZ1hzbU9GalBOTE1ZaDZUbmFyOElmamIrNjdCMCtZdWd1UTZibWZTZ2NPa00vQUgrTzRHK01LTm1XQWlNalUzeEl4N3dcclxuICA3RDdDOUdGeDhIUGM4V2MyUDc3NmpGbkNCbGhtT29nOFk1TTU1L3YxYjN4ZjJVdXg0NGZlM2ovTFpGaGR6RTJrYmhpMk05QlJockRDXHJcbiAgSTI5UlR3Wjd4QzNub0NSUHFYdXdlckVKY2hENGl3emt3QU8yTDIydS9tYjYxVnJyYnRVYyt1bGRCNVpYbTdCS1RaaUFYMmZlWUZzTVxyXG4gIENwZHlEWUs0bUtMUGlyRkdONXk0V1hWRzlLMEtGMy9tb3EzYjRKM213dkpQVXd0N3hya2t6aGpuYmlLQ0pUTW9yeldZZUZtKzlkTnRcclxuICBOOXFrQ2FPQkhjRjNETVR1dXcxV04rN0NnQjM3WG1uRGRYdXNuNWxKc2RPOTYyZDJZZld4eXhUN3lwcmhrZTBxaE1hY2lRMXRQeHlHXHJcbiAgN29EL3pmUC9wem45akF1YWozMzhDKzJxKzFuTkZUL0k1bUpraUx3UE9aMDExR1hmTzdGb3hUNGdDUWpVRlJyTkhVaWo2ZDVUVlNRRVxyXG4gIEN1cDMwMEU2VHNLN1F1NEhYY2VCUDVWTi9iWWJIMmlnR3Vxb3VQQjRDUXJyY0ZBL2o4c0xmL0hQV214VVhJZUZNNURFa0I4a2JGaGhcclxuICBnOEo1LzRZTlB0Q2M4L1VqeWt5K1RyTytEb0p2RHZudTliTjdlMEdHc2JZQ3d0Yk4zN0ZiODUxdmZxSElTc2l1bE5NOUEzSEpRdzBzXHJcbiAgTC9GYTdlNjczNUZsdHk0ZXZMMGJDRDhRckQ2K01rSnBOcWtlZkRmL0dqKzQ4aWRGN3ZYcjMveXU3T2pGTnFERVFLUG4raHYrVURaelxyXG4gIC9lSVgxelZidmV0TnhiODhwYjJMeTRiTERONGhHbEFUbEM2VUNlRXdhODRoWGpYaGdNY3R0RXlSbll5S1l4QlNaK1BDTGJua2Y1WmRcclxuICA2L0ViOTJIaHNPcGlFc1JFQ092WmlnazNvUmZXbnByQnhDUDFsV3NnbkozK3U3WGZNL2tZaHJ6M2ZhTFZtUGk4STdmb0h1TTdEdFMyXHJcbiAgczBmSjk0NjVwRHFQNDU3bkJJOW9KMGpXQzloWGozemt3OXRWMHpQYXllZXZ5bVN1c0JEYi9OVjRVN3ZTM3VZOUd6ZWJ2V1BYNXFjL1xyXG4gIC9XM2JaNWRvdm5mcGo5bzNWc25SdkpxVmdMeTU3VlBIZm9HbTFnTk1DNnVHTE1jMGVUbnp1UDJnT2tmTlJ0RlFsbHF5dDdGd3dYYXBcclxuICBYeTlWYVM3bG1ObnBJT1lSekE3RmwrVndHbHYzcXBQVzZRNkM5MVFERTVkcmZhL3pNT3FYTWc2Q3dZcGZtaFRZVVdaWU5HNWlmVGQ1XHJcbiAgR2hhK20yK05DUzhiSVltV1Z4ZjJHbkQzVDczTHc3TEw5ZzZGR2dUdU8yeTNXZCtjZWNKWlZmN2twNzhzZHFMc1czanYxajNyeHpYNFxyXG4gIHN4cDc3Z3ZXTGl3b25ZcWJEcGIzNVJ5T1gxNVh5ckhJa3g1ZlpsWTFhTXBacFVxZkgrd1Vrd3MyZ0VEK0RRb1JGb0tKaC9iR0JNbkdcclxuICBVOExObGR2djRieHloSUNaZEFKUXBsTCs5T2UvTkpkZGZrM2J5YTRxQmcyeDNXd3FZMzdlaW8zY0E5dU82cS85RWUvYVl2MHltRDM5XHJcbiAgYVQwdE5VZTVPb0Rwa0lOMzZRMldiMzF0YVVQWnRmKy9GMTFSMkZpNnE3Wk5CWk1mWVFmVk9kTXRXNzVyejNMdlBTdXJRVmhiNzkvMlxyXG4gIG80VUZkY2JwUFFMVGhYb3FoZ1ZmdTFMSkE2UnRLdE93eVFJSUc5VDdRZXA0QmtFNGlpWVVFWVJiZWVXWEZ6Zm5pTGpLSjRJMENONHJcclxuICBXL3o1MS9kMU94K0dzODc2VmtuVHBzUVhMLzJDMHNiVXNUK0l4N245MDlHNndycXk4Umh3RnB3ckQ4SW4vdVM5QnJkSjB4aUZhRjRCXHJcbiAgbFYwRStleHovcmQ1NmxPZVdEZ0I5bjEwVnd2SEgzdEFjK3JwNXpjbm4zSis4NXJWWHRIMkw1YWNvM2tWdGQxWlE1Mzg1WVBLMkFFUFxyXG4gIDJCVUltRkZaMGtOTnBldkdVZDlUQWY3WS9qUFBXaDdYaUliaGEyZCtxMWx6amQ0TzlHNWpIT1UyQ3Qxd1R0NHpXNEhhZlZ4YzNnZnhcclxuICBUejFRWnh3WDNqdnNLNXBZdGQvRU9TcGMzc1V2WkhZOGJQYmttMkUvUll1cS9vYmp3Qy9EaW05OC9hcjlNRlpoZU9YSkR6K1RyRXBBXHJcbiAgR0taSXJyNzY1NFZGc3RjZVc1ZE9YbmZjdWk2QU9yVEJyVjZ0MVREYnhrK3VlY3BXSm5udTFxMTdIWTlBTTFDSE5ncFNGWTBsNHRUMVxyXG4gIE1JaW5WdFVkNW4rK1I3KzQyV1duTGZwczN5NlNONG9MYkl0MTg2dCt0OTdxemYzQm9nWi9CZzc1eGhhck1VbitJZW01UnZrbHorUEFcclxuICBIMExPSkVjZFpqcmhvZmFydkJSbTFsempWVk11L0RrVWE3aXh4aHFmL3ZTeHpkYnR4Q2p0WEwxRTloZTNZSysyM1pwWUlHQ2pMQUpQXHJcbiAgQnc5cFZ4K0dlM3BUVnRzbW1GU2ZUV1pZVHVoaTlkV1diZmJaKzczTlc5NjJVOXZPYjJrSjZSSXR3Ym0wL2E2bVUySzU5NzZQalRaY1xyXG4gIHMvbmlNZnROUFQyQVZ5Q2dHR1lDRU9ydHVWNkYxUGZNTk1jL25IZitKZmM2dlc0U1NQZEhQL3BGMjZGNzU2NmI3Uk5tcG5IbXFsRklcclxuICAyK3BnbE8wZkVFOGQzczVnYm1acS90eVpQckhpcXN2UWhaa3p6YUNFQTg4R09pYkRFLytnT0xqbGxMaHVXY1JsRmpySU5MNXdMTjFpXHJcbiAgRDVrOUpiOWwxdDYrTy9hNHJ6WC9hQWxZTjAxMWt3a0FtTVZUUXVCdTVueDhHMSsrWFJmYzMvMnVOeFhqZFRUVjVEUGZOOStjTE1yeVxyXG4gIG0wRForMEZDOTBBNFFsQUVsTkRmM3BmVWsxWE5wdTBxQlF1THNOU2VIWEVTN3V1QUNMMHk0MnZiWUVZVENSQ0s3STFRSCtMeURRRDdcclxuICBvN2JxTEsyVDI3TC84WTkvS25INzgrL3ZGRVhoNWR2eklBaHZKYVhzd0o5eWlGdVp1ZWU2eW1ydmFGN1ZsdlBJSS9ZczVucTZFQmVOXHJcbiAgR3djNFFXUnczRjNGOGFqNTV5dDdvWEpXZkEzKzJMdXlxejhxNmlsTDJ1V29jbGk1c2NGMjlkWFg5dFBOQ3NUektQQ1RkTmdIdzM2aVxyXG4gIDJzek5Pd29qczU1amNXK1FlNlNjd3FTOXVGbzFwRjlqc1MyMzNPRGpxQWZocFMvdEhTVmd0bTgvRUpNOWRkd21idHBkVFV3bUZjeVBcclxuICBnemkxNDZ3RzJFR3pNaWF6VXQvZFZjSjg3VVRuMHdmdlhNYWNDNy94L2JZdHJkMTg0ZGdaemZ6elBhNmRVQ0FjOXlZZTJwZFZMTTVRXHJcbiAgOElCZWdRQnoyL3Z2dDIyNXJ5dStibXoxL1dadjM3V1lzUWpxZDlOQlpoNUpNL0dNdTQ0RGY4Q3ZrK2dNUmdsZlkxUmNkWnBCL1d6SFxyXG4gIDdpQ0JaVkNIZDFWR0drc0lpSVkrS20xK0RhSUU5L1gzR0FmYU9WdThlNjlaaE9IU3p5b0c3SmhtaFhnVUNNRXZuUEhaY2krZjlqQ2tcclxuICByQWFWZ3o1NVROR3lpdUI5WEhrR0lmbEs1d2ZQVmpCWVFXUlpqRkdhbVJ0OGJVbzBpQzI1NUhPYVJ6OXEvbkpJRldJblBOYVd6a3E5XHJcbiAgdWF1Sk5nclVTRTBLc3RKSVhnYVZSMzd0S3JheUdWZmVsTTJzRjdIOFRqdElVdE8xbXNweHgrUENCN1cvdXM0bUNhOE9yU2pOanZudlxyXG4gIHVRK1hlUUEvQ0FUcjFFbURiTXV4eUlUb0JzeXV0ZUJoRUZmaVNEdXUyL04wVmg2MTFoVmxGNnZWN29xcWpwdlFINEdaVHY4WkJZU3dcclxuICBUSURhZTlNWnEzVDdTbnhQRTFKSE1YUkIva2I3aWxiV2pQTXVhVmNmU3pYSEhYOXU4N1NuUG1IS0N1KzlDWWlWZmowaGhBYzhBYWsvXHJcbiAgZEMxSXJpdC8xZzgvMHo4d1VqZE1ZMlVjRWxkOWhhNWIwcXZ2UjZHT3g2emMrZVB1eno3bk8wV21VWnRRR1lZNkRzQ095WUUrd2FSNVxyXG4gIEllQjMybHNnM0xqMElmV2VOTzJCNkoyZlBKcXQ1ZlRIQmFjMk4zb0cvdDBiK0k4NGRQZm1IVzkvUTNFZkJQN0lVcHlod1NTMW1XSUdcclxuICB4T1Q5NWx0dWJmNzd4VXNVVFI3NC9CZE9MOGU5ZXAvQitJRUVlZFlSVXg5cnJmbXEvc1pXeUxjdzRiRGlOWkRhSTdYdmZrYzFyMjVYXHJcbiAgb0lOTXlOU3dRUTVMcGY1ZU5iQ0QvcXR0QjZPK3VieWw3bXAvaVc5VVdINnN5aHl3eFY4ZHBuYy9ubmlBeVpHVkp3VU5jc1drNmYyb1xyXG4gIDlLSHJSM213d0dyYmNpbmp1TGhxSkY1aHUrMCtib1BTSHRaSHBndXNLMjJINUFJQldYWFZWNWJqaHArNDhFSkZLYU5yYmRkK205LzlcclxuICA5c0xtTFp2dVdMWUYzSDRIaFlZZnRVUm4zdWEyUC9FN2VOZDVXTkUxK0hwQVE2WGpGd0xLbWhscjNSSHFlLzQzZnN2TVEvNFJEeDlyXHJcbiAgOW1EUk5pdkVUNTA0RGNhVnFReklEdlpKSUp3OHM1VkVrT2llMlEybjFxV3hwVXlENEQzRWo1bHd3cW1qY2VFRC90S0JzSGRTdnpBcVxyXG4gIHZIZjFRQ3llMlBZYTFURzhDL0VBei83NVJob3BvanJxbS9FLzQ1eWp5dldlZTNyekh5d3h5RGRaNzdVcmwxbS9QUEwzdVhaVjZ0NTdcclxuICAvNGMrL0VWbG40VDdFMCtjZGRmd1B4dnFEanRRK3E5WWJ1TnlCYTFISHMzeWFudGF5aFBRMk1OK1lzNWsxWlZmVWVwckdQR1Fqcjh5XHJcbiAgT3NwWDNGMTVCY0xoK3h0STYzUnFKQjcxMk4wQXlSMkdoWVg0Q2ZISVprTC9tZUhIRXcvKzdma2gxTStreXp0Lzk2TVF0cFc2QUdHVVxyXG4gIHgza3BpUis0L2Z3WG80KzVyVkdubmY2UU5PcmQ2M1hhVUJPdE9RSEJ1WGFUSFNUenRwTUxySHRtVW94SFhlSUJSeDJ4WjFHYnR6cWhcclxuICB3UFB0Yi8rb2VjSVRIdE1TajF2YXQ3TVNqY0NrYmhBZThDc1F3RGRuaGhwc2ZuSTJSVDVJUGxEMHRzRkh4Uk9OWmRSSkd0Z3dmUHlnXHJcbiAgWTVvUHZQOHQvVGlTWnA2SFhjZWg5dTlEazJPNGgrbkd4N1EybGxJZHZuWWJGejUrNm1WM01DcXNEaEpUSVBrTzZvZDVDM3NHc3JMSlxyXG4gIHUwSEF3cWd0eTZhVE1kQm9KelpCNDZUQWdtUFBDZnNJc0RPb0w5YjE0dDRNM3NtQ3pEcDRyb21tZStlTGt3RmtRQUJzTzZ5b3dONE5cclxuICBIZEFNcnhhS3c1K25qUGxoWDVrbDEwaWNydEtxMjFMZHR1cDMyRmkvYW1mZHRNUkdDYzFyQ0FjcE16VlY4b0xFS3kyckdOOXFGUGlyXHJcbiAgNjZHR3VMd2JsaC9wV2lIK3YvOTNZMS9tVklNRzNVMDNJU2FURVk5Ujk4UHlFRVJsbUwrY3N5S2N3VThaRXNja2NRVTE2K3ByWjM2alxyXG4gIENOKzc4ZVNiQXVPTU8yeS9XWkdkMVVjRHpBa2UyYTQrNkV0WkNUeGszb2NWTmluaSt0Q0hQcVM1OCsvMzNnRG8yT21QN2I5dDJUaDVcclxuICAydWtYdE8zaXljMXZmbk45YzhsM0wyL2JLLzlPSHB4MTliRkdPeVo4N2F1REozUVBDZ0lDZHJMR3lGajlVZW9QWHJ2WDk5QjluZzdDXHJcbiAgRDYwYkI5UU5wYzVIZlQ4SzNYaVk0MkJoTmhzTzVYbFVCdzFzaEp1Vmx6dzhiNFBnZlFhVzJteEV6UlliRmI1R1hjOGFxVUY2SEFqSlxyXG4gIHpTcHJjeHJpcVNITzdvYkRVUkNlMnExQi9DTWYzcWE0RVlJYlJMb3NPL1YrMVZYWHR1Ny9XUWFhSUhWbjEzczBxMjVzSnpDMHBiQUhcclxuICBBck00aHhVRnd3YmN3Q3hlUFl1ZmJJaGRNT2tFZWYvVnIzMmpDS25mMHE0ZUpxbC9tdytwL2ZLYnRzUFVDVGRIRTlQR3FyLzFNT1I3XHJcbiAgSjAvMndOQWFqQVpmTUNwUGRYa2dmb1ZmZXVubnRRVFcvcHJSRy8wU1I1MlhRZmVqNGdCV2k5OC90U0cyVzNadFBkK2kzZzh5RG5XNlxyXG4gIGFmUGozQ0R1Y3dNZmJ1UGFiWW83WXhWaTc0ZkpENVZ3aDRZTndxMS91S2kwcjRXZnZIeXp4dXJMTm4vKzh6ek50VC83ZWZPREszL2NcclxuICB2djFIODVCNTdpNm0zR3NDOHUwTGp4bTZIK1lCcllWVjQvZlgzOVM4NFBrOUFXdG1ER1lSdFFrQ3hlYVcrMW9icFBzOEhYeDU2bXlTXHJcbiAgYjMvbiswVjdSRHdhQldPQ3JNdW1rYVRUVHBvT1Avd21QdnNEb25Odm9ITmdVTjZQaXMvdStEb2VWek5qOVdJbDhJWTNUR2I1bDNWYVxyXG4gIE1neHg4RSt3RHRmKzdOZEYrMnRVUHBSZEdMenBtT1AvNHJGZkxXN3FoSlZSczlGQllCbVdPUTB6dE85ZmRuWHpzcGUrcUlUeDF4bnNcclxuICBEWUFZZXF5Lzh6QUlhMFBhNXB1OXJzeDBzWXo4RVNHRGFiVHpFSk5MLysvcTVwV3ZhTDh2UW56UFBYM2JWeXdBMEtmZmFLTzFTbnhjXHJcbiAgWDlDdWFMVERWN1QrV2RybGJoZTVnNlhreVQ5N0cvSXRuR1pJRjMrWlpaWnM2K1NNNWsxdldxTzQrOXM1SFJaV3V4UnR6ajczTytXQVxyXG4gIEtXRVIzM1hYV1dGc1dkVUpRYXFWVUwwL0FoQTZyQ09xd3R5OWwrZGg4QjJGRlIrLzd0bTlBcklIaWdUYXhlS0xMMXJjQmtFNlhhUzhcclxuICBpSzhWaWZLTktsZmlTRnNjZHU4NkNsYmltMnk4VHI5Y2RmMXd5N2Y0L0RHbk4ydXNNZG9jZlkxajJ2cEpIc1FKNml4MTZ4cU54NHdMXHJcbiAgRUxjNUJWTks2MiswUTJGZEdlb1JCUnFCODdRL0UxRDEzRjBaT0JPZmZJUVpxTnR1KzJ2enBnM1dhdHZqNmMyUGY1S2phKytjQ2pNelxyXG4gIDVPdGV1MUk1em5jWUhqUXJFUEFoUXIzcis3b2hVVXZELzRiYUQzU2ZwNFB1S2dUcnBqYnprYmdaQk54bDV5MW15ZE1veEorVkJ4dEtcclxuICAyREFHTUc3ZVFlN0h4ZGYxYjhadDBKYTNhRGlOaWlmaHIvcmh0Y1VlRUgvQ2F2elBmdlppNWRDaTZkU2ZHVjNPSmdGeGtXUDVqem9MXHJcbiAgWlJDU2Iyd3RBeVdpeWN5NkhiUlhYM2x2NjZMaklMN2Z0NE04bFUrclcwdCs4b1Z0MjI4YTJGOWoxcDE2NmE1Y3VrZzU0Ny9lYzZQc1xyXG4gIEFVV0JUeDMwb2FJZXJHNFRianBnSVFDdjI4b1RCc1dUZk1DNE5QZzFPOGZDdlB5S2E0ckpmZXcvM3dyTDJDWTBHQlZQblI3d0c3ZVpcclxuICA5NU1KeTZOdEZTUzh3VXBaMmIxYWQ1MlpteVlISVdaS2hFdDRLOUthdGN1VUNPVUJMT1RaUWZwOWtPZEJacGRvWGRZSG9jMEpJamdQXHJcbiAgQWNFU1U3WkhQMnErNXM5VDM2cUdNZVh1TzM5UTJ0d1RGM2wxYzhHTW81b2Rkem04N2FPM050ZGUrOHQyMWZIWElrYzFnUW9JMnkvK1xyXG4gIHpuRjlVY0FnUEtnSVNENUVrT2Y2SXc3ekUzU2ZwNE54ckN5c0VMTTFzM0F6Z2tuVHF1T3JyNkJzWmVZMFpkNWhYSHo4UU9JWmRqOHFcclxuICBucnhuNWJWZWtXVDVQeTc4cHc3K1ltRzlCTXpRNUJTNDY5dVY1Sk9lOUlUK2dEb0pRVEpEend5dW0zN3k1VDB6SkdkLy9ZaXgrUnVGXHJcbiAgbEZtY1FkbXowWFlpeGhPUFBQcmtjclpEVG1TMGdaUHBFclBZTys2NHMrdzhSNmdwVnNnVGxVNHJGSmpkUEFVcGF5Qis4cHlZUHZmT1xyXG4gIDNobUQvaWhydVYzNEZxbGY4VEhkdnRTU1BldkxDSlJKMGJqdkpQMUJxUE5nVmR3MUpGbWovbTd1N1VTbk5zMHQ4YnVmenVZN00zN0VcclxuICBnZUtCVmFlSlVEQnpZMnF2WDArQ1d1NlI4TjN4QjdlQ3hoa2svZHJQbklMZ25MVmRLMks5YXA1NUgxYmtpTDZkQTlCc0RPMkNFb25UXHJcbiAgQnMvOCtyZWFrMDZlVVNaZm4vN01LYzNUbjc1d2M5bmxyRmtnT21Mc2tRTUU1NUNEZHk2blRvN0NnNHFBUUdiNGtGVUFIUHpwWTR2Z1xyXG4gIEZlcVAxZjF3dFYydDZXTFB2UTV0NDNwWFlZVjB6d2VwcnhuUUlHN2pVTWNCM1hqalpzQWFkeVJuTjQ3Nlh1T2liSkM0UnlGK3NOVnFcclxuICB3NHY1QnBOMGlrSHBDQWZDMXZlandKL09HdFAzNG1WbW85WjA0UWJxUDNHN1RsTFdCeUxrWHp2Q3owYWdJTzFLR1pYSmpKS05Mc1FNXHJcbiAgMnlKdGI1THlKbjUrVTNlQm1iSVpNNW5Qb0JNTmEyQzMxcklqU1ByaXhVSWN0NzhuM3lqNXFNTUhlWjkzazZKdUIxQ0hQKzVMWnpadlxyXG4gIDNuQ05xYWZScU5OT25EWHlQdS9ZTlB2UTFObjBzNVB2WVhoRXUvcEFJZ3ozMWd2UnBwbzUvTThLdHRHWTY2R01kTWwzZjlBc3R1aWlcclxuICB6ZGZQdXFTNTltZS9LUGF2SHZLUXY3WGpncGhtcmo2WTN2bjFMMlpNUFEzSGcwWUdFdWdrNFoyYWVabU4yTTE1eCsxLzY3dnJGRDZZXHJcbiAgWi9jMkkrYkV0TnF1MW5TUmVOZGE2OVhObDA4OGE2RFdoU3QvT3JJMGRQeEowdUpIV0RNMGJDZThlaklRYm9HNG1BbG40QysycGdZaFxyXG4gIDZmckwwM1hYM2REOCtDZS9LUEdSSXlDMjYwOXdjRTNpc1BmQXFrcmVkQTdmUUJrMTJIRmxHL1ErWmNvMWczM3FiaEM0azVWQThiZnlcclxuICBaczNaWng3ZS95YnlDY3ByQlJGNWdIZ2YxczdRcURVdSs2cE4rb2VPSWNTMU92SDlpZVEvZjhmcWZ1RUxweGNGQnJOWE1oVnlCMlgxXHJcbiAgSHVGMCtKUnlXbWtzOHBRbkZoYWNzdk16N3B1b0U5OU8vWWd2N1FYRVlVTWUweVl3NnBqYTVGdWJjaFUyMTd3SEV4N3E2c1BBbnpEeFxyXG4gIFg0ZXY0OHp6S1BDalBQVTE3WUJ0TXdjNTVWM3ZlTnpKV1ZlRDVCN2lUUnRNM2p4VE9pRGZBdXlzVFRaWnA5elBLVlpmYzh2bUoxTm1cclxuICBTUXozVmdxMHJYcWFoKzJLdU8yYk5XZ1R6amo3eU5KMzJWaXpDcno5OW51YUpWLzB6T1liMzd5NEhFY3d6enozc1B6ZVltYllpNzUxXHJcbiAgN0VRS0JRODZBdUxENTZNQnRnSXp4ZHh0R2pQUWdUTXRualVsNkhPcW1LVmRLa1NEOUJkbXV1ZzF5a3RiNHJGOHY5RU11c3Fma3d5WlxyXG4gIGcvQThTVnI4bVBVUlZvWjRpRTllSVhHSFpURXFUdThNa3M1U2VOM3JWaTQyaXhLR2tOcjl1RHJ3enA4L2duR3JrTHZ1dnJ2c0dRRHVcclxuICBoT3N4ejVCdk1nallXZ1NhL09RdkQ1QnJDQW1EaUlOTWFBVHlSSjFWK282Y2ZlWnpWaTh6TE83Q3M5L2tIYUdtT0crWk1rV3lVanNnXHJcbiAgdXlMdVRtbmsvNE03ZnJ3b0x5US8zbU1IMU9ZYTVnWlM5MGtqK1RPUTN6bWxNQkhCdGZZc1AvSkpzY0drQWEvK2IxT2FZSFk3TzJ0RlxyXG4gIGUrRFBha0hjb3lEZHBOY2xIUDRCc3pUMm9JaDdXSnlJTTlZV0pRUG94dU9adGx6c3M0MGpIcEN3YWVQNjcwb3JMVk9FeGM3SnlMNlBcclxuICBVUkF1NGJ2WHB6Mzl5V1V2alBhUndUOVdjeWVCT0JLdUt5eTNXWmt3dnU0RGh4MStRcmtYYm00Umo3M2IrSTlxeDdqd0g3UlRkVVBSXHJcbiAgdzloZnl5K0NmZmZlcGxsaGhaY1dNKzRYWGZ5RDVrTTd2TDJkSUZ6WVBsL1FUbFIrMTh3LzN6ek4zKzYwbnBsSlBIYmRlWXRtL1RkT1xyXG4gIGRqTGlnNDZGQlQ2S3ltT1BCNmd2c292RHZWNHUxMHRJSDdkZWNzN3V5WVhRbFlYMDNHYk9udUkreUcwU2pJdUxZRHI3R3lhSnMvYkhcclxuICB4SFMwYXJoMVQ1d2JoVG9lOTVFTmNKczBMNzREMU44aWJtQzJ6ZUFoemFIYXp5U2dnRUF0OWt2SEh0Qm5WU1pmcmxEZkIzR3pOOFJxXHJcbiAgQzMvWXJKb1NnQTJLWVEvVnlFQUJNU01DM0prSFdXeXhSY281OFRWTEtXMndUcDg3TnB4VlpmSVJ2MGtqN3ROaFQ0RXdQMnpiQ3JsSVxyXG4gIG5pSHh4ZkJqMHB1a3ZydHg1QnA0VnA1eHR1R2czdE9WdUdKazFEMXdueTRMekpWNnJzbGs4bGEvbTQ3TW80dWNWZktaUTQrZnBWN0ZcclxuICAyOTNmVVF2UzV3YXk1NFBnbk9wRXlJWFY0aUM1eDB2Kyt3WE5keTg2dnR3di9wdzEydnZqbXEzZmUwQ3o2S0lzRFovYTNIYmJUWVV0XHJcbiAgWEp0NHB6empwTkJKOTZrODZGWWdZSWJEMUhJNm1NNXJsbU1tZHVoaHgvZmR6Wkl5aStJV3RoSTR1YkR1cE5NQmMrL25YL0Rkd2xiUVxyXG4gIGVESURxeHNwb2QyYWE3NnFQMXZoeDB6RkdSUGprUGdTSjdDOVpMYi8zZTlkMmJ4NlNyMld2NlEvQ3ZFblB1d3NjWDYvN1dDMFhOWjdcclxuICA3VXA5UzdQZWo0b3I3OVViNHNIY2VQSkhhWUFhN3JqNjlONWZIQmtRODBlTVhyN01Vc1VBb09kamp6dWpzSjdrclo3MURRT1YzL0RyXHJcbiAgemRJWGYrYlRtbmR0dFhjeE9waTZGQmVDb0J3TUc4S1Bydmw1SWNpRW9nd29BblZ0Y2ZBblgrWGEvaDBSNEJSSmxucHZ1TUhPM2Fhb1xyXG4gIDJ5cS9uZS9nRkwrMTExNWhsdnAwTDA3dHdyNk13SHNUSGJOYmVZT0VVejlZalZaSThsN3FhQ3ErY2REMm5YM05ScFI0aFJVdjVQcktcclxuICBWeTdkcjlkeGRadjJ3YzRYbzVQeTRUbHh5Wjk3TzZ6SDdiSk9YQWgwdmdsd1k1QlEzTngrKzl2ckN3dVBpdlFvOEp0NFhDSG0vQUh4XHJcbiAgWVgvS095dTVEVGFZL056eGVvd3c4VnArdWQ3RU1UYTNhQ1pTNSthUGJMSDJmMEhIMnZPYzRDMmI3dGhjMWhKWFFEZ3luWG40dklPSlxyXG4gIEI2THlqZlAvcDZ6UXRldS8vT1d2emZYWDM5WmNkdmxQMi9wOGREdGgrVW5yZmx2ejE5dG5ubVZEbHZibEx4MDRVdXVxaTlIUzJBY3dcclxuICB0dHQyMDM0RDBUQStzdCtSNWI2ZTRYSDNRWU80QjNQeWNWZHNsNFgyb05RTnQ3NDZFdFV5dHM0UHN5cmRQSXlDemhQL1ZITGg2VTk3XHJcbiAgOGl4bFNucVRnRitERXY5MjludU9Ga25lajRyTGUxQnZ5cFZuWWNoVlFQd2d6anFmWFFpUERWWDc2dzZPNFZlTDA0bDI4VGRKZWRuU1xyXG4gIFlpQ3dOdk9SY090dnVOMHNuY1JLRklzRWxDa2FkSU9BbllSMVl6QWhQTWFtY1Y0K3RtSzlveDUvSFZKSFlNTmEySCtRK3NaS1NUa0JcclxuICBxOVU3ZFVSQVdzY3hLZVJGK0xSeGUxekVuN2lTRmovaklHOEpGMldLdW41b052V2U1eWs3OUVlaGpnc1NUKzFtc0lkd0dFWWg4WFhqXHJcbiAgWlFFZ3F4WVRCcUFFNC9TL1NYSHd3Vi9zMTQrMlI4dXlpOWhzNDA4ZTR0OG0zRW5xZGhKZ1hkay9sTUVhOFlpTWF0QnVjL2owcDNZcVxyXG4gIGJkVmhVbHU5WjUvbWJXOTlYVHVoc2tmcFA1b0RQMzVjdTFxNnRlMzcyTFF6VjlZT09odFV4bEY0VUxLd2dwcEZCV2xFUG5iOThlS09cclxuICBEZUhNRUVkOUJsMi8wd0dCMU1VWE0rZzJxMnJ2Sk5kSjBQVnJENEt6bGVuSUUrTFgrVGFnamZ2NDVCRHZmYy9HL1hnSDFSTk1rajg4XHJcbiAgYnVxSzRzQjJZZ1N5VzQvVHFWdCtvZllmTjRoN3pGQmt2ODkwNnJNTGNkVXJHeXE2TnZFaElDSDJPY0lZcER0dWRwWTZqUFhkUEJ1d1xyXG4gIHBaT0JPMm5PYnQ2REUwODZ1NTI1LzY2c09GNzR3bWVYd1ZmYzNYZ1pJV1dTZjlMdkFiUU5xU0FucnBURmQvZjl1YWYrY3gyRmhBLzRcclxuICBqMlhhK3QyNGVBTHNSb2QzSmUyb2lJdlR1UjcxMFFWL3YrdnVkb1d3ekZUSThVaGZFNzV1eDdsM1RMSzlUSFc1ODY1Mm14dDR4SlRXXHJcbiAgVlpkMU5RdzJ1MTUxeGFubGZ0WFhiTkdjZnVxbjJuWjNXVXVFem1wTy8rcjV6ZTIzLzZWNXlsTVdLaXM4UW5jbWVzajhHRmljTGg3VVxyXG4gIEJBVHFqMXZ6SE04Ny8rSnl5aC9VZnVxTmVrSDlmcnF3bVd1bEZXYzE5K0VlNm1mM1NjZmdQNm1RQ2h2aUxaVVFMbkhYUklRSzViQmRcclxuICAzbDNvZEFUMXlSdWVNL1UrOFNTZlNjT3NtbTc1T0xDQ2E3WS9DTW9NMDYxZmVURFlkZzgwaW5zZFgrcTFWdVdlRzZEbFpGOEloQUJNXHJcbiAgRjJiUjljcGtic0lzbTJJQ0pHK0l1ZU55eVc1cVFwSnZtdWRSNERlMnN5QnRvbzdMN05adWV5eXljWEVtYmFqamludlhiVng4WVBWblxyXG4gIFZkNE41NnJkenJwU0dyMTVjUkRTcGhCZUxDQnhYWG9wd3JSRWZ4OUtQVzRrL2RwdGJ1QlovN2w2OC9PZjk4NlZtV1NncGx6eHd4K2NcclxuICBXaVl2Q09waGg1L1VMTDMwYzV2dlhXcXYwbStiRTc1OFh0dFg1eTNmTmhwYlZqTm5uWGxZMGZxYkxoNlVNcEFhdFNvcDNya1BxT000XHJcbiAgN0FaUDFUdlBQckI3ZkhLelR1cThXZHJXY1V3WE5HWjZRcm1lN1NnZFM3cWVJL1B3YlBXejFscXZLanVUby80N1NabzJVNlZNSUF4WlxyXG4gIGlFYnQvckxMZjlRM0N1Z1pRY0NmSHdhemEvNzRaOTVpbVpjdDJZOWJ2ZlJxcE5lcEp4MzRtRVpJSElINHhSZVlGVExuTVl6UWRDR1BcclxuICA0dnpvQVVmM1RhcW9CKzdSaHBHR3V2Vk03ZGxzMmZOUHIvMVYwVHFyNjIxMmdMMG52ZVFsOTlQNWo5dXpNd2tRZUpNRkxERGFjS2xiXHJcbiAgQjBKSkk0ZFQrV1pZWG1RMzNQelR0dk1mQlNzeUcvY1F5OWo2c3FvbGd3SGhwUzJkeXkvL2NabTBqSXN6L24wWDZGNjlBMlZ6a0ZlZVxyXG4gIFI4RU9jd1BrTGJmY1dsVDRrNFlyNFgwbVNKN25oSGdBR1Vma1U4elhBTUtwM0xRN3JUUnpnSlJCMlFGazQrcGtVdGd3ZVBKcDUvYzJcclxuICBDN2IvU1FqSTV6KzNUMkY5V3ozdHZjL2h6UWUzMzd3bHRBOHY4czdqdm5ST3M5QkNEMjkrODlzYjJyaDZzVDJwbllodTlPWTF5MFJ0XHJcbiAgZHZDZ0p5QStWajFRcUdoc0J3UDVSUmRmVVZSQ1FZUDE1NS9mcmQrN1QxSEZCVzdIZmVscnhXamM3SUJRSFJFeDBGRWx4bHB4L2tLOVxyXG4gIHhQMmZ6NTlhN0MzSkEyS3kxRkxQSzZhMUo5bUxJTDlrUE94RkFUYUtQTE45YzlmZjd5cHhwc01RUXVwZ1Rnb2NCZUhWRWQ2NGsvUGtcclxuICBsK1ZiN3Y0Z3ZoTlBPcWVrRWJkQnFBZHBxc3N6Wmx6VUxMRGdZOHNNUGlBbk1EalZmaWRCcmFqZytzWTNydGFmZVVJR0hQblgwZFVGXHJcbiAgd3ZmRHE2OHRwOHQ1TnRnaTlOZ1NhUU1QUkNoVDhxZE5aL0NudjIrd2p0WWdOL1hvV3QrRE9MSmFVaDl4SHdWbjRodDBtUWRaaFVKQVxyXG4gIE93aXJWL1htcE1DNmZRR1cyYmhCbVY5cEMrc1A0a2hjZFp6TythZWNNRWxlK1UrNEx2R0EySkxyUFUrZmVBaVhDVW9JaVEzTE5nN0hcclxuICB6WHZYcUFWSG9QNnhBei9YRHp1bjhDMjIzR3J2UWp4cW9ma29PS0oydjQrOHY5eS9ZNHU5aWpydUgvNXdXN3Y2dUxvNStKRGoydjU0XHJcbiAgWS9QaWRqWHlpMS84cHF3K0ZtcjdLQTdEK2VmMkRtaWJIVHpvQ1FoWWdoa0VOVUIvNTRmb1FJaUhENXdPcHRHbWtkcG44T3ZxR2ZHSVxyXG4gIDM5bEJqNGg4cjgrWFgyZWRGY28xalptZWVKN0pJcVNEZUhCTEhrWUI4YUNhYXVVVUVMNm1YT21rT24wYStDUmxVVy95OUx6blBxT2RcclxuICBQZlhPR3hlSHNGZjg0TWRsNDEzeU4wbGVFVWxoTDd6d3U4VUltekFnSG5VaVg5eG9mTkNrbTBSUW1qVEZTKzNZVlI0Wk9UVERGNmVPXHJcbiAgTGw2RHAvTC9ic3BnbjNyeGpIaXdGWlJkK01KbmdQWmN0NDEvSnFSbGdvTS9uelRsWDE0Q00xd0dMRE1ZVVVjOTRZU3ZGei9DSk8vdVxyXG4gIGFSczVQNFV3MzZyMCtjOS9WcW1mU2NyaU5EOXB6VGp2NGhKdTRTY3VXRFRyN0h5M1VwZFhjVW1ITFN4N3FkU3B0ajRLd3ZFWFFpYThcclxuICBaKzdnT1ZkY0FQS0tjVkRHeXdhb09xdWp4Q3VlRzIvODQ5U1pKN05IUE1TYisvU2pXSW1PVy9kYXY1dGJXR0tKZFFyaHdBTkFQTVlSXHJcbiAgRUN2Rzg4NDVxb3hyVlBVZHliM0lJazlvZm5UTnI1cnJydnRkYys2TS8yc0o3bFBMcE5xK0k5QjNUam5wRTlQU3V1cmlYNEtBNkpBblxyXG4gIG5YeHVYdzZnMGZxZ09sRUdDWERGSjdlUkxxd3Nmb04weWtrNjN5QUllL1BOdHpVdmYvbVNKZjI2c2RkWERZM3drMVZYYVNXdjQ0QjRcclxuICBhTkIxbmtGWVpSR3Y1VFNMcWM5YXZMYzdlRng1dkxNaVlsSTlzcUhFZjMyN2d2RGVNdjZNTXk0czkvUE8rN0RDQmhzSHU1bVZ5OEF1XHJcbiAgdnM4ZmMyb1pMR2hXWVRVU1FoTDg4dU92N3J2Zll4RHkzaFV4aWFhYVoyVk54MTU2NmVjWG9tR1ZKdC9laFhnQWY2bWZnRC92dWNtTFxyXG4gIDg2U2Q2K0haTzhqN1lYOG52TkhBY2srMS9LS0xyaWlFMHJkRE5KeGJIYmFXV1dBRzZ1UUhxTmVtTGZyVCt2SSs1UWg3eXQ5R01teE9cclxuICByQ3ZzazNHbzh4KzdWT0xGbnNIdnA3bGtSV0x5cFU3NWQ2YjIybXUvdWw4SHc4QnY4dWlmOE5vVU9WMDJGbnBYWDhkQkhQYUdVTk0vXHJcbiAgNHNpVENpdFUySHhyRUErNWh6UnNxQXZiY3pwSStjZ09YdkNDWjVlNHBRSFNaK3dVNGs4ZTNLZU1jd3R2ZjhkdXpmZmJ0cXNOWkFVeVxyXG4gIERvY2Z1bHM1czRaczZQVnYvRUJ6eEdHN0Y0MjR1Kys2cTlsMWp5UGF0b3pkL1pOeVZnMVFGcUhlemxyMW5HRE9HYlFQRUZEck5iaDJcclxuICA0Y1BXN3RsWEFBWTNXbGtCdjJaTnN3dmhjekllcEdFTnVscjJKaC9jQnVWOUVPVFpTZ1FNU0NDZXpNQnRiaUxhTWNncnl5UnhHOWlGXHJcbiAgTnhpTGszOXhYZkxkS3d0Qm9xcG9NQkRYcUxQV2E0alBYMXordEwvdzB3a2drLytBYXF2VlRzb3dLV0lUVFRqQS94YmUwYnJ1czBudVxyXG4gIEU1LzhRci9lWGNFOWVjSU5OOTVjamtuTiswQ1pXVWlPanIxMzQrclJXZEkycUVZNGlUMkFTQnJnb3hHRWtLaG5DSHN1QXkzd1l6OU5cclxuICA4ZHYrd1hla3h3OVlQZnluZnVOblV0VHg1cHVtelNzdnhNNWJaSHVUcUw3eXp5OUZsc1FmZUdkeVo3V3BITFh3ZXh4eWtpQmdzOWtjXHJcbiAgRjlSMWx2aVVaYnJDNE1RRDdtbHlSZk1PRUthb1dnZmFndlJ5blZ2WXA0M3Y2SGJDa1lGNXNKTHVyTmhodTdlVmlSbHMvZDc5bWpOT1xyXG4gIFA2UzU0b3FmdHYzMzZtYmJIVDdSVGxqdUtmbVBPTzY1YmJzbjMvdklQdS9yT2N3Qkh2UmFXRFY4WU5wSm1TbjR1QmxjbkVlQnlBQitcclxuICBPZjRsRU82YXNkY0hIOVhoWmdmRGRxcDN0VVBxSzlTSFpvMUROM3l1ZU1BR3J1d0dqc1pJbmM0b0RDdTdqbW5BY1JWWGtFRm9ITWlZXHJcbiAgekx4WkRBRHAxT2ltbWZ6TzdyZW84eWpQNG9oYjZtdlVQWXg2TndxMVg1dnFvZzdLcmI0Uy9Gc04xN3ZRclFxb2g4c3o3VHNLRTFhSVxyXG4gIDNrOFg0aE9QNzY4ZCtGWldHSFovQjFoZzFIVlR4NzE4ejlNODk3bi9VUWJTU2RBTDA0T1ZFQlpLVkx1aExuT09MWmdFQm5IY0JlZktcclxuICBiTHpSMnYwNHVsZHQ2ODBiTWhuVTYzZlRRZUlZZHAvcjJlZDhweHc1WGIrYjAzR2lDL0d1dFBKbWhWMWxyS2V5TzI1d1hubkZaWnB6XHJcbiAgeis3dGdjT09QdVlMWDIyMmJ3bktOZGY4c2wyTjNObnN0Lzl4elErdXZLSll4emJPZ1VuMDE4ODRkS1NKbVVueEwwVkFvUHRSdXcwaFxyXG4gIHFKKzMzZjZBV2ZhR3dKdzJqc1NmVS8zaUJuaTE1QTFKdyt3MHM5S1RUajVuclBYVElQRmxnRXhIQzZoWXpqLy9UTGJHTmRmOHZBZ2VcclxuICBKNEc0eFJ1aVllYkx0bGkwd21hM2JvU0ZoUGZNb25KdCtpSitvRTZuL21hekErR1p4V0JDSTJWTDJ3QUV6aGtlVVhVMlU4WVNzSEl5XHJcbiAgTU1iZk9HUWxCNG1mWU44TVBHVklYTzZWVjE2Q09TMWpYYmE0MVNaTklQbklQZHp5eHorMXhHYjBHUnRCd21EaDBONkM3dDZYYnZ3d1xyXG4gIGFkbVN2NVFsejdsYTJhblRtZTV6ajNpa2ZYZXZVT2NERW1adTRHSHp2ckFRamV6M0dBY1dBWDd6eXhuTms1LzhoTkpPZDl2ak0rMnFcclxuICBZcHNpQzZQNnUrWTYyelE3NzdocE1jLy91Yy8zOW9VQTRmcGVlMnc5OVRSbitKY2pJRkIvY0ZwUkJMaEFRd2gxaHRvT2p4a2V3WHQzXHJcbiAgc0lJNWFTRGRsWWdyZGtuUEN1aXNqVFYrb0o3dFRBSXNHb2ZpR09TeG5QQ0JtWGVtdFpQNFk4T25QczlnSE96T3JzOVBtSnVRcnhyZFxyXG4gIHVqZHd4QTFSOWEwTUpQamc5ZWF4dVFGeFFiNFJTQjlZbzBXSUllbVJFVmdsZEZHSEI4OHBaNzR4eEYvaW0xT0lheERSaUJ2VTc3MnpcclxuICBNcUxwOCtwWHZYU3FyaWMvZXo1dHlwNHFiRGhxeGl3YmlKZEpHRzFRT2pZYlB2LzV6eXdya1VuTEtnNUlQdXRya0dmdFBQS2s2YUtPXHJcbiAgMDE0YWgweEJ5cFpydlorTWNCNkJCQ3I2TnB2T0xUanpobndNRUpCSldGYy8vdUZYaXhraTJHVzNnNXNQNy9XZW9oVGhMSkwzYlBQeFxyXG4gIFp1R0Y1eXQxZE5UUkp6ZDN0TzNWR0lHRmV0Q0JIeXhoNWdiK0pRbUl4bEVmNnBMR01PcmVJSUhBVUdXZGFmcGc1dnZaUmM0UW9TTnVcclxuICBjMVlhYnIyTHZqNFhPNDE2T3BzTklXRlozV1JHMmlIL2oyNVhPVFUwb2xoeG5VN1pFRFNESm5ZQ2N3Y09Td0t6OHRWZnMyd1pRQUp4XHJcbiAgT3VwM3VzSTVtK0lJQVVIZWFCNnRzL1lLNVZuWlFMN2RHL0FNN0hUdm9hNjNmemJZWGJ2cXFwOU9QYzBLMzljQWVsK0J2R0hadHAyblxyXG4gIDdQWi9tQXd0c01Cait1eW4xQjFaRDdsYldKeXpVMmNKUTQ1QnVTRGZBK3A3cTBrczFHRFNkQkovNGduaWhsaEVFRC9UNzV5dFBHaWlcclxuICBwWjJsVDNSUEc0WDZmbTZNQ3pYczk5aWxuY0FpaFFialNZVG1uMmlKUUdSVGUrNTFXTHZxWGJvUWM5K1hSZVhUVHY5V082RmNyUG5ZXHJcbiAgZ1o5di9uYm5uVVVnajhpZjlPV0RTcGk1aFg4Skxhd3VMS3NKYWpQN2N0VUF1RWU3eFQxM2pjRVZ1d0lSb2Y3cFhjTGwvZXlpbC9hbFxyXG4gIFpXQkpJOFJxZXZlN05pd2I4Slo5NWRMbDdQSzhTejd4cWgzY0ZOYldPQWhqVmt3ZFdSejArYm41RytBSlJxLzc3ZlVsRFFNd0RZeEpcclxuICBnWFdsM2w3NzJwVUtTMHlaUEJQYzJiVFlLMk92MDd2YUZPYnFQMm5kMlJRSHdqQkUySnNkOThMU2lFcFpZTUVGSGx1MGhud2IrVkNtXHJcbiAgM1BNenA5OXNGS2hKSmkvZGY0NEwrR2VBck82b28wL3ExN1U2MmZZRGJ5M3FyZTZWWFR2Q29pTWdqUi81S3VFdnZhcjR1ZTIydnhSQ1xyXG4gIGs4RndFcEJGMEdnRGZTZG5tdWM1N2RiVk0xbWZnNXJJR1pQK09DUjhIVSt1L29COW1vMlUzcGw0NWN5TlNaR3d1YzlLWDEvY2VhY3RcclxuICB5c1R0N1p1L29id0QrYmRDb2NFSHhoV1R6TGtGZHE2Y0xtalZNUW5oZ05lMGVUNzRVenROUGZYS29YL2ZkTk1maTFXSXovN1AxNXVYXHJcbiAgdnVRNXpRVVhmTGVvZzhPYTdZU0xzc3FrMzJOUy9FdXVRQUlEU1dZS2RjT3AzYUYrcHBYMXNmMjNLL2RCMS85MDBXdU1QYjMwNUNOeFxyXG4gIDF2bksvYWk4am9QQkljdGFxT09DTHU4WVM4dTE5ak1KdXZFR01URWgzN0daQk5NcFF6ZnUrcGsxMVJ5M0dtVUlGbTZkM3d3OWRrenZcclxuICBiUHJsT250TXBsdkcrd3NwcjJ0QS9aSUZBeXNNSzJRV0Rjekc0ZUoyOWZiQkhUWXYvbXRXMWR4QThsRG5KL2YxMVhkbWdyOTJtd1NEXHJcbiAgNHJSNkhuWllXdzlJb1REVFczbFlQY1lzVHVLRW5MQkpxYUZXOWZhKzduOTFtTGtCOFVWb0hybkhPQ0x5bUhaeWNOMnZ6Ky9MRE5kZVxyXG4gIDl6M05WMDg3dU56Ym1iL2REcDlxMWw3ckZlMHE1TXptcEsrY1U5emZ2dG5yeXRFQzArbURrK0pmbW9ENFFHYk1ZWFhFbUNEVXNwRzZcclxuICB3Wmc5Zi93VHh4UkxzVUgzaklMWlFTK05IaEZoeFRmbVI4U1pLMFNJWHJ1UnoweG4xdE1sVHE0RzlkOWZmMU5aeG1LZk1iSHl6YWxCXHJcbiAgcVBZN0NjUmZZMVRESkdDbFZvdEZCZE50eERWeHFPdktyTmdwaStRNjNHamZQZk9aVHl0YVRKN0hJWEhsL3Y1QXloSkNtUHhRdWRUZVxyXG4gIGdrRjVyY3M0aUdoNFA3dkVwSTY3bXphNW1GVlA3UjRRNWxvaFRJckk0N3J4Sk83QjErbXpyQ0RodS9mcEt6a2Z5RHZ3L3A5SlBDQkNcclxuICBjNnlyU1ZZZlRMZGYvbjhuVjFxbVBmYTRQdXhRS1hLUFJaNzgyR2FaWlY3WXZIdnJEeGRUUmR1Ky82MWw5VGpqbktOS21MbU5mMGtXXHJcbiAgVm1DNVJuaTgxRkxQTGM5NDdCcUZUb1hISHR0Vi9GbnVjemNBMFRYLzhMNkg5emNqWWROWVJzL0o4ay9ZWGh4UEtZSmdLcnNaTkhvZFxyXG4gIG84ZTZ3dXFTUnh1WU5BeXp6ZnI5SkZBT1drQTJtam5SRG1nWHNZZURQLzZkLzcyc3QwR3FuYzI2NHB2SzB5bW56SmhJeFZMOFpXQmFcclxuICAvci83WjVPQWZNdW40elVSYUg3WXZxSTR3QjFZQ3Axa3cxdmdnQnZsOWpkNEFQVkRnK3dYMjRGWEdzeXRyTHZ1aXUwcytQdkZYODMrXHJcbiAgeUxXRzlvQmxrZm8wZ0tzTC92TFBPL24yVE4xVi9MV2ZZZjl1Mk5xOWRnTXNCbWV5cEg3azF6RUFxNisrWEdGakpsejhKeXgvY2Y5VlxyXG4gIFMweWQ2ODBzVGRoWjNxdWI1R1VTK0g0MlQxSXdTYjNWYWNtanVqZVQ5MHplNW13VWFXcEgyR2VUUUR5c1FMeWxEV05qcnpOUGtrN1NcclxuICBoTGp4NytxUXFHVW1PRStuaTRUdjNvZEEyTlQ2cGcxNmUxL0ErN3lET3N6Y3dpTWZ0WFJ6Vnp2bysxYVRzcThPKzh4dWZaWWJ1Y2VyXHJcbiAgVzBKS0xnbG5uL1B0NXRwcmY5dCt2OFdhM2ZZNHBOaURzekdZNFB6NDQyYnVkWnZibUQwVmhnY1I4UHBwVEFRNlZScktRNmVFY3FDeFxyXG4gIGFEUkF4WlorOWE2Nzk1YUdrRVkxSnpCek91cm9yNVI3K3ozRUo5NDBVQm9ma0x3UUd0YU4ya3BvVXBDZHZQVXQ2NWI3T2cwRGVqcEdcclxuICAzQWxWcFJjVjMwTVBPNkZjeHlIS0JvRjQvYTJ3UUp5cE0rN0s3Q1MzdUUwWDZrK2U1WmVnVTV6eUh5MnB3TXdMRU5CQm9JRWtMRTAxXHJcbiAgY0hKaGtES0pOM1VQMmJVOUNlcXdOT01DMmttZ0RFRllKclVidFdFcnFzQWVEdTk5VTRUVFBWWld3bG1kV21HNlY2NDZybkVRQjhJRFxyXG4gIHdtWXpvWjNqNHZGUGVkeGJaUVNPdnFVYUx0eWtNRmlMQjl0RG5Ld25KKzVjSWRmNlhZNnJuZzdDb29YRUZRc0k4cTB0eG1ZZGVNOHRcclxuICBaY3FaUDNNVHE2eXllWm0wYVdrRzRFazByZzdZYjl0eUpnNzBKbEs5dlVIYUs2N0pCUmRlMmJ6dHJXczJWLy9vWitXYmdQNC9PeFoyXHJcbiAgcDROL2VRSUNTM2VPdHJTMHovMlpYLzlXdVljMEtOQlpGMXUwWjk4cThGNEhtQk84ZmZQWE5YdnQzZHVKbmZUa3d3NTI2b0pKdjM2WFxyXG4gIFBCQ1FteDFPQjhKVFAzU2xIdzVNazRoVC9MVXRLcXNQN3UvYWNvUFM4V1lYOHU0ZmhCMWprQXZxSGZ2VVFWUHVTVUZMQnBSTFdqclZcclxuICBjNS83ak1LSHp5N2k3RS9neDFudXJwRDZuSCsrZTUrN25rMTc4UnZVN1dBU1JLQk9ZeXZ4eFR6NklJaWZIOWVhbFFLVUJzQ3FVaHVnXHJcbiAgTGZqTmIvN2Z2Zkk0WFVpRFRNREVKZWtscjRzdnpzcjBUTUtSdk9VNTErbnNLN0tyM0dCdDVTOXMzT3Y0dXRmYXozUWdqSDlVMXV0NFxyXG4gIEVVejMybHl2N2N3c2U5eUFMS2JlWUR3M1FPTnFoaU1sMm50RWRKTDlIcnUzRTRSc2dvWUwyN1lldFd2dGZhMTEzOWRzKy80Tm10LzlcclxuICAvcVp5VkszamFGKy8zc3J0K0xWSVlWbi9NL0V2TFFPcFVUY01xSi9aS25yYnB1dVZlOVRjVWxsak1sanYvN0hQbGswMzlSbkJhWXh6XHJcbiAgZ3ZBdmUvZTl2SFN2a0xRR3VVMEh6R084ckRwd3FnNmZjdzRDYVJVVzFSeVdNUkFmSlAvQXpVQnB0ZzNUbGZPTVErb0liL3Y1ejF1OFxyXG4gIEVCUFA5V0JoSnByWmQvME9VdmJhZi8xK0ZBYkZOU2llM0x0Q0JORXpNVSs3RWxtb0VMVWJiOFJXbWo3dnY0YTBzR05ySzdaeEI4LzFcclxuICB0ODgrb0dINW5SUUl4L0pUWWFHT1I5a1FScXdZaEw5K056dHBRWjBPcE84TVN0ODFLdi9ZbXBRUm9ONGJNcmRBNDJxM2pzYlZ1TUdYXHJcbiAga2ROdlh2RDVQbnZRRWMySEhySnJ1UWRDODFWV2ZuR3o2Tk1YYVZaZC9aMUZDOHNFMEhITlJ4ejJ6NWRPL0V2TFFHcm9GT2tjM2VmL1xyXG4gIFd1cDUvWHVzQ3J4WFBHLzJwRjY0UkR2ak8vQnovYzFFZ1A5Ynh6VTc2S1hmc3hyc1QzaHVwM0FhdTFrNVEzdlNNdmpsQUJ1ejBWcVdcclxuICBNeWwwRW5HRnJ4emcveHZJcFo4OUREcFZqTWlCdEw0MTFlRm1CeW1qRlJEMlU5enV1T1BPd3BJSklvZUNPYTFmWlFWbjM1UDdlSTVRXHJcbiAgdWNkbi8xMFpzSDc5bTkrWDA5aFNOMEhDdTg0MzN5T0tvY0dBbWlxWmtYZjFQeXVmeEtPK3VJUEpDSlAybnZNKzkvSkNOdVlnS0dGNlxyXG4gIDV0SjdWbThYWG5qQnNwb1pad0YzR0h6THlFV0FrY3ZjUzd1Ym43eHovK2xEaml1bjFUSHVHTC8ra3dMaHdFWlVGdDlUbTlLL2F0TXRcclxuICBTZC94QnIyNjZPV0ZIYk42VWpNcFFoakU2MTU4MGszNmNhL3pGRll4Njg2SkkycTdjd3NoSGxZZVlmdU1JeDVXRU4vK3hqRjlkcWJ4XHJcbiAgNG9EOXR5MzNzTWRlUjdhcitvZTJxNlJsbW4zM083SW94UmduYkZTZTIvczlodUhmaG9DQXdhTWVtSFNXZEl6NjNuK2ZmUTh2L3NxaFxyXG4gIFFvczl0Wmc3cWMwOHNDaUxELytLZGpDWlhZaC8zNDhjMVN5MzNOTDlmU0lhdEN2aHRLczhFZnFhblc2eXlUcmxoRHlEd1BiYmJWYmVcclxuICAxNFB1SkVnSGNsVVgwVXJEWHVHRzVXSURZKzBISnQyOVBncUlCOXRPQm14QVBNU3Y3ak9nNEt0bm94dlpoaGx3L2MzbUJNcVRxd0haXHJcbiAgZGNrWC9XZGJ4dzRmdTY0SWlGbnh6WUNPTGFhRE9sYzZNQUF5ZjMzZGRkYzNEa0J5NW9ueXlEUDNESURRRTd4ZlZyU1dFUDFlT3YrdlxyXG4gIEtHNDRBNFBKRkN6RUVJZnVkWGFSZHFGZXNhalV1Ykl4TldKWHVITFhneXpVeFBXeXk2OHB3bXJoWTgzWWYxS0lrNURjcW9Ndzk3ZHRcclxuICArc0tMbTB6SVJDS3lGbTd5WXJjMGRrdWVKeFhJMThCMjFYL0Fhc0xlb3JTcnVMTkZ0K3l5TDU3RnpUMS8zZnU1QmNjdmI3WDFoMHQ5XHJcbiAgSWg3WVZwT3dmUzc3M29uRjZnSkVhSjd2d0RMRGozNzBxMmJ6emRZcEdsY21nRXdrdmJJZGp6NTUwSWVtSmJPYkUvemJzTEFDRFFUU1xyXG4gIFNKZ3gzL1lEUGY2aWdhcG1zOWcwRkFHclFZRHNvSDdmald0MmNkcnBGelFycnZEU290dWRCbHpIblh6VnU5UHJ2TTV1bzA4Y3RMUE1cclxuICBjbUtVanJ0TlI0VE5BWm1GWGVoekErSUhhYnZIUHNoUnhEWVFycnZPaXNYZHpGRDlPMHdMb1U2OTFOZi9Iek9STmdQZit2YjNpNVVBXHJcbiAgbXd0cjhFUFdWUXZwdTFEM2lNbDA2OWVLdzJDUzcrUDcwZjZydnhuVTMyOVd0OWxUMFlYRTE3M1BtZXRRcHpuSWIzMC90eURPVlZiZVxyXG4gIHJIK20rU1FDYzdqbXF0UDdLdEZXSGtoTytqdTIzeTY3SGRIc3V2T216ZisyQkhHTnRkNVZKaXZPZkNlM2paWHErd0wvVmlzUVFNSHJcclxuICBXYnVCeVVmbXppMzNRRTAxendaMzZvdWZPdmpZWm9WWDl6U0J1RnVpbXpVbHpPeUFlV1dtUXNLNkFQSDU2OHdhRHBiV1dtdStxanc3XHJcbiAgUElaWkNzdDhnKy9zcHAwNmlHSEhuQ2ZPdlpiNWVPZE1pdmdIR3hheE9HcTNTWUdGUVF0RldIK3J1Y0FaSk43Wllheis0ZFpiLzF4VVxyXG4gIGc1VXozeTUxN3Z1UUU1QVIxQVlaLzlXaDNIVTc5bXdWb1U0TVBHdXNzWHpmMm1yOG1nR0QyU3IyaVBNaWZGdnU2bE43TXZNWDUzVGJcclxuICBsTmsvdFZ6aHhHbDJqL1dhRllVOHVMTFY5TE9mOVd6Qk1ZbmpoRWtycE1pb3BndnhKZzFnRnk0V243MWpzUUNTSit3ZHEweEluaUR2XHJcbiAgNXliSVVwZGZidVBHOFUxV0hwT282c0lKeHgzUXR2MWV2bWpETVl4WUU0OFBiUGVKWnYvOXRpNXlqalhXZmxmaFhsRHZmVUs3MnB5YlxyXG4gIGNzUkpFSGJjdnhWOERBMHQwSWgwc053Zjg0WFR5ejE0MXJpQXZyNXp0NTNnRnVoczBlcWFFL1FhOGo4S29RQ05HK1RWZmZha2VNWUNcclxuICBrQ2VEZlB4QjhqbGQ5RTV3bXhYaThqZURnK1FEZFBhWUFJKy82WUFHbGJETWZnZmljTWlXZWtDc0Fta2luSU1RZ2JNODFvTmxmZjFYXHJcbiAgZ2pxeVdneDZiYVozakdzTnFyYkt6MyszSG9SUjk5aG9FTmtlOTBrMXFtcllpOE55TVJhbjlBeWErb1Iwazcva0Fjc09LdzliamR0V1xyXG4gIDc5Nnd2VjVhVmlueE94MGtEWCtUTytsYk9YUFB1OXluL2RxVFZJZWxXaTJjOTNNYkwzbnArbVhGTWFuTUEvYmVZK3RaYk9DZE8rUGlcclxuICBObTh6aWNLT094L1M3TGJMWm9WMSt0YTM3VnhZN0h2ditaN21ubnRtcmxEdVMveGJFaERRMEF4WUFaMXBEUW1jdzVCN3lGa0VsdVE3XHJcbiAgYkw5Wk9hT2E2bU02c3c5WCs1OWRhTkFJaFNWckduL2NBMjQwbDlJaHZKTzJlMjUwd0tlYkZ4WkdoVFhiZ1lUblp2bWY4a1UxMVN3elxyXG4gIGJwRDc2YWJMR0dPQXJWTHZrMGhjVHBlcmtiVDRpYkhNSVBXVks3alBzejBvRDNRa3J5bC90MHhZVHdacHlJckMxaFgxb1c1cWMrcUJcclxuICBkd2IxMUZkdFNaZ014dnZwQXJ0S09odHZ2SFloRE82bFQzc3A4WEZ6YjRMbEdpdkt2YjB4dmR6UExaWVYyVjNhaGhtNWQvWXp1WkloXHJcbiAgWXNHNko3dEsreEdPN0UrNHVZM3NNb2RKVng4N2ZlanRzN0NmVmxocHN6WnZNL2NvN2JuWFVjMDczLzdhd3YzNDlHZU9LeFllRGpsNFxyXG4gIGwyYVB0anhkODB2M0ZmNXRDUWhnQTZXalFtWk9RQzVDNWdBMGJzQTdzMzdtQVQ3N3VWUGFqbk45Y1ljMDNya0JNdzVFU2lPdjQweW5cclxuICBpWnQ3bGxHbEhYZXp5Tm50RURrU1dMMTA0L0FjTGEyQW0zL3lrL3M2ejVQQ3JLdWJKdGdJSlQ3bGMyQk9qYmdIeVI5QzM0VzZxMWxjXHJcbiAgbnZPdFhSR3ZQUDh6Z1ZWWnAxdmZCMWhKWUZZOUNObE1DT3FnRnZKbmY0MzNyRDA3NlRGeHMvWGtmazRFclB0OTVNZ1NCd0U1dUpkV1xyXG4gIFZ1SE9EOC9BRGQ3N3Jza0R3bUVRbnhQQ2tUVHo3TjQvYVpub3VLZk82c3FVQi9tZGV5eXN0Tk5ZZVpqYkNQRkFJaWVWZXlBZUg5N3JcclxuICB2Vk5QVGJQaFJqczBGNXozMmFrbjMvbm9sdGd2V2N6MW5QeVZHVVY3Y3U4OXR5NXl5d3ZQKzl5VXIvc2UvOVlFQkdxaWtjWmtYNFNsXHJcbiAgNFpQYTJWNzlqdEU2c0pucmtJTjNiZzQvOHNTaWR4MW9tSWNmUHRrdTduSEFMcU9wa3M2bjg4dURoczhOMjhaOTVCZkF2VWJjcHdzRFxyXG4gIHNiRGQ4UEl4S0U3cCt0ZjVHQlIrT3VpV0Jhakp5c09nZDJDRm9ZN3FqV29CRnRjZ1ZsMlFzeGhxU012ZmpEMzMrVE5tYUorRUFhbjdcclxuICB6aC9xZDRITmpqWCtOTFc1czBia1R6SDhCOHFUZXUxdVNMUzNBN0QwcUlLbjdJaVZrK2dnNGJ2MU1na29rSkJ4YU9zZm1qb3hVNW5FXHJcbiAgWlJic1h0dzJPQUp6S0hsUDVUbjNaQjRJeDZUSEluZVJlRktHUEErN3IvMHpIWlI3eHhQSTc2U1dycWVEbW5nWVhDY2hIbHUxMzJ5ZlxyXG4gIHZiZnBXMEdnOGZtbFkvY3Y5M0Q0RWF4WDNOTXN2OXhTaFZBZmVORG5tejEzMzZxMHZ4Mm5qb1M0ZjlBMC94K1lSOFEzWXc5NEtBQUFcclxuICBBQUJKUlU1RXJrSmdnZz09XHJcbiAgXCJcclxuICAgICAgICBpZD1cImltYWdlMzE3OVwiXHJcbiAgICAgIC8+XHJcbiAgICA8L3N2Zz5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXZhdGFyO1xyXG4iLCIvKipcclxuICogQ29udGFpbmVyXHJcbiAqIEBkZXNjcmlwdGlvbiBNYWluIENvbnRhaW5lciBmb3IgdGhlIEFwcFxyXG4gKiBAYXV0aG9yIGR0cm8tZGV2dWsgQGdpdGh1YjpkdHJvLWRldnVrLmlvXHJcbiAqL1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuaW1wb3J0IEhlYWQgZnJvbSAnQC9jb21wb25lbnRzL0hlYWQnO1xyXG5pbXBvcnQgSGVhZGVyIGZyb20gJ0AvY29tcG9uZW50cy9IZWFkZXInO1xyXG5pbXBvcnQgRm9vdGVyIGZyb20gJ0AvY29tcG9uZW50cy9Gb290ZXInO1xyXG5cclxuLy8gY29uc3QgdmVyc2lvbiA9IHJlcXVpcmUoJ0AvcGFja2FnZS5qc29uJyk7XHJcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xyXG5pbXBvcnQgeyByZXBvc2l0b3J5IH0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcclxuXHJcbmV4cG9ydCBjb25zdCBzaXRlVGl0bGUgPSAnTmV4dGpzIDEwLCBUYWlsd2luZCBDU1MgMi4wKyBhbmQgR29vZ2xlIEZvbnRzIFNlbGYtSG9zdGluZyBEZW1vJztcclxuZXhwb3J0IGNvbnN0IGRlc2NyaXB0aW9uID1cclxuICAnQSBzaW1wbGUgZGVtbyB0byBzaG93IGhvdyB0byB1c2Ugc2VsZi1ob3N0ZWQgR29vZ2xlIGZvbnRzLiBcImZvbnQtZGlzcGF5OnN3YXBcIiBpcyB1c2VkIHRvIHN0b3AgRk9VVCBhbmQgRk9JVC4gVHJ5IHJlZnJlc2hpbmcgdGhlIHBhZ2UsIHRoZXJlIGlzIG5vIHNpZ25zIG9mIGVpdGhlciBvZiB0aGVzZS4nO1xyXG5leHBvcnQgY29uc3QgcHJvZmlsZU5hbWUgPSAnZHRyby1kZXZ1ayc7XHJcbmV4cG9ydCBjb25zdCBsaWNlbnNlSW5mbyA9XHJcbiAgJ0l0IGlzIGltcG9ydGFudCB0byBhbHdheXMgcmVhZCB0aGUgbGljZW5zZSBmb3IgZXZlcnkgZm9udCB0aGF0IHlvdSB1c2UuIEFsbCBvZiB0aGUgR29vZ2xlIGZvbnRzIHVzZWQgaGVyZSB1c2UgdGhlIFNJTCBPcGVuIEZvbnQgTGljZW5zZSwgdjEuMS4gU29tZSBmb250cyB1c2UgdGhlIEFwYWNoZSAyIGxpY2Vuc2UuIFRoZSBVYnVudHUgZm9udHMgdXNlIHRoZSBVYnVudHUgRm9udCBMaWNlbnNlIHYxLjAuJztcclxuZXhwb3J0IGNvbnN0IGNvZGVMaW5rVXJsID1cclxuICAnaHR0cHM6Ly9naXRodWIuY29tL2R0cm8tZGV2dWsvbmV4dGpzLXRhaWx3aW5kLWdvb2dsZWZvbnRzLXNlbGZob3N0LXN0YXJ0ZXInO1xyXG5cclxuY29uc3QgQ29udGFpbmVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gIGNvbnN0IHZlcnNpb25JbmZvID0gdmVyc2lvbjtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgaWQ9XCJjb250YWluZXJcIiBjbGFzc05hbWU9XCJiZy1ncmF5LTMwMFwiPlxyXG4gICAgICA8SGVhZCB0aXRsZT17c2l0ZVRpdGxlfSBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IC8+XHJcbiAgICAgIDxIZWFkZXJcclxuICAgICAgICBjYXB0aW9uPXtzaXRlVGl0bGV9XHJcbiAgICAgICAgYXV0aG9yPXtwcm9maWxlTmFtZX1cclxuICAgICAgICBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259XHJcbiAgICAgICAgbGljZW5zZUluZm89e2xpY2Vuc2VJbmZvfVxyXG4gICAgICAgIGNvZGVMaW5rVXJsPXtjb2RlTGlua1VybH1cclxuICAgICAgLz5cclxuICAgICAgPG1haW5cclxuICAgICAgICBpZD1cIm1haW4tY29udGVudFwiXHJcbiAgICAgICAgcm9sZT1cIm1haW5cIlxyXG4gICAgICAgIGFyaWEtbGFiZWw9XCJtYWluIGNvbnRlbnQgYXJlYSBmb3IgdGhlIHBhZ2VcIlxyXG4gICAgICAgIGNsYXNzTmFtZT1cImZsZXgtMSBwLTMgb3ZlcmZsb3cteS1oaWRkZW4ganVzdGlmeS1jZW50ZXJcclxuICAgICAgICBteC0yIHNtOm15LTEyIHNtOnRleHQtc21cclxuICAgICAgICBtZDpteC04IFxyXG4gICAgICAgIGxlYWRpbmctcmVsYXhlZFxyXG4gICAgICAgICBiZy13aGl0ZVwiXHJcbiAgICAgID5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgIDwvbWFpbj5cclxuICAgICAgPEZvb3RlclxyXG4gICAgICAgIGNhcHRpb249e3NpdGVUaXRsZX1cclxuICAgICAgICBhdXRob3I9e3Byb2ZpbGVOYW1lfVxyXG4gICAgICAgIHZlcnNpb25JbmZvPXt2ZXJzaW9uSW5mb31cclxuICAgICAgICBsaWNlbnNlSW5mbz17bGljZW5zZUluZm99XHJcbiAgICAgIC8+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyO1xyXG5cclxuQ29udGFpbmVyLnByb3BUeXBlcyA9IHtcclxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcclxufTtcclxuIiwiLyoqXHJcbiAqIFNpdGUgRm9vdGVyIENvbXBvbmVudFxyXG4gKiBAZGVzY3JpcHRpb24gZm9vdGVyIGVsZW1lbnRzIHRvIGJlIGluY2x1ZGVkIGhlcmVcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuXHJcbmNvbnN0IEZvb3RlciA9ICh7IGNhcHRpb24sIHZlcnNpb25JbmZvLCBhdXRob3IsIGxpY2Vuc2VJbmZvIH0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGZvb3RlclxyXG4gICAgICBpZD1cIm1haW4tZm9vdGVyXCJcclxuICAgICAgcm9sZT1cImNvbnRlbnRpbmZvXCJcclxuICAgICAgYXJpYS1sYWJlbD1cIm1haW4gZm9vdGVyIGNvbnRlbnQgaW5mb1wiXHJcbiAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBwLTNcclxuICAgICAgICAgICAgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgdGV4dC1jZW50ZXIgXHJcbiAgICAgICAgICAgIGJnLWdyYXktODAwIFwiXHJcbiAgICA+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC13aGl0ZSBmb250LXNhbnNcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktMzAwIHctZnVsbCBmb250LXNhbnMgZm9udC1ub3JtYWwgdGV4dC1jZW50ZXIgcC0yXCI+XHJcbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCIgdGV4dC1ncmF5LTgwMFwiPntsaWNlbnNlSW5mb308L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC13aGl0ZSB0ZXh0LXNtIG1kOnRleHQtMXhsIGxnOnRleHQtMnhsIHAtM1wiPlxyXG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiIHRleHQtbWQgbWQ6dGV4dC0yeGwgbGc6dGV4dC0zeGwgcC0zXCI+e2NhcHRpb259PC9wPlxyXG4gICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgIENvcHlyaWdodCA8c3BhbiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6ICcmY29weTsnIH19Pjwvc3Bhbj57JyAnfVxyXG4gICAgICAgICAgICA8YVxyXG4gICAgICAgICAgICAgIGhyZWY9XCJodHRwczovL3d3dy5naXRodWIuY29tL2R0cm8tZGV2dWtcIlxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcclxuICAgICAgICAgICAgICAgIHRleHQteWVsbG93LTYwMFxyXG4gICAgICAgICAgICAgICAgaG92ZXI6dGV4dC15ZWxsb3ctMjAwXCJcclxuICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxyXG4gICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAge2F1dGhvcn1cclxuICAgICAgICAgICAgPC9hPnsnICd9XHJcbiAgICAgICAgICAgIDIwMjFcclxuICAgICAgICAgIDwvcD5cclxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInAtMiB0ZXh0LXllbGxvdy02MDBcIj5WZXJzaW9uOiB7dmVyc2lvbkluZm99PC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZm9vdGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGb290ZXI7XHJcblxyXG5Gb290ZXIucHJvcFR5cGVzID0ge1xyXG4gIGNhcHRpb246IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxuICB2ZXJzaW9uSW5mbzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG4gIGxpY2Vuc2VJbmZvOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBMaW5rIHRvIGFzc29jaWF0ZWQgR2l0aHViIGNvZGVcclxuICogQGRlc2NyaXB0aW9uIGZvb3RlciBlbGVtZW50cyB0byBiZSBpbmNsdWRlZCBoZXJlXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcblxyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnO1xyXG5cclxuY29uc3QgR2l0SHViQ29kZUxpbmsgPSAoeyBjb2RlTGlua1VybCwgaW5OZXdUYWIsIGNhcHRpb24gfSkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8TGluayBocmVmPXtjb2RlTGlua1VybH0+XHJcbiAgICAgIDxhXHJcbiAgICAgICAgY2xhc3NOYW1lPXtgbGc6aW5saW5lLWZsZXggbGc6dy1hdXRvIHctZnVsbCBweC0zIHB5LTIgcm91bmRlZCB0ZXh0LXNtIG1kOnRleHQtbGdcclxuICAgICAgICAgICAgICAgICAgICAgdGV4dC15ZWxsb3ctNTAwIGhvdmVyOnRleHQtd2hpdGUgYWN0aXZlOnRleHQteWVsbG93LTYwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAkeydob3ZlcjpzY2FsZS14LTkwIHRyYW5zaXRpb24gZWFzZS1pbi1vdXQgZHVyYXRpb24tNTAwJ31gfVxyXG4gICAgICAgIHRhcmdldD17aW5OZXdUYWIgPyAnX2JsYW5rJyA6ICdfc2VsZid9XHJcbiAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXHJcbiAgICAgID5cclxuICAgICAgICB7Y2FwdGlvbiB8fCAnW3NlZSBjb2RlLi4uXSd9XHJcbiAgICAgIDwvYT5cclxuICAgIDwvTGluaz5cclxuICApO1xyXG59O1xyXG5cclxuR2l0SHViQ29kZUxpbmsucHJvcFR5cGVzID0ge1xyXG4gIGNvZGVMaW5rVXJsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgaW5OZXdUYWI6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXHJcbiAgY2FwdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdpdEh1YkNvZGVMaW5rO1xyXG4iLCIvKipcclxuICogSGVhZFxyXG4gKiBAZGVzY3JpcHRpb24gU2l0ZSBIZWFkIG1vZGlmaWNhdGlvbnNcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IE5leHRIZWFkIGZyb20gJ25leHQvaGVhZCc7XHJcblxyXG5jb25zdCBIZWFkID0gKHsgdGl0bGUsIGRlc2NyaXB0aW9uIH0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPE5leHRIZWFkPlxyXG4gICAgICA8bWV0YSBjaGFyU2V0PVwiVVRGLThcIiAvPlxyXG4gICAgICA8dGl0bGU+e3RpdGxlfTwvdGl0bGU+XHJcbiAgICAgIDxtZXRhIG5hbWU9XCJkZXNjcmlwdGlvblwiIGNvbnRlbnQ9e2Rlc2NyaXB0aW9ufSAvPlxyXG4gICAgICA8bWV0YVxyXG4gICAgICAgIG5hbWU9XCJ2aWV3cG9ydFwiXHJcbiAgICAgICAgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xIHNocmluay10by1maXQ9bm8sIHVzZXItc2NhbGFibGU9MFwiXHJcbiAgICAgIC8+XHJcbiAgICA8L05leHRIZWFkPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZWFkO1xyXG5cclxuSGVhZC5wcm9wVHlwZXMgPSB7XHJcbiAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxuICBkZXNjcmlwdGlvbjogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxyXG59O1xyXG4iLCIvKipcclxuICogSGVhZGVyIENvbXBvbmVudFxyXG4gKiBAZGVzY3JpcHRpb24gU2l0ZSBIZWFkZXIgaW5jbHVkaW5nIHRoZSBOYXZpZ2F0aW9uIG1lbnVcclxuICogQGF1dGhvciBkdHJvLWRldnVrIEBnaXRodWI6ZHRyby1kZXZ1ay5pb1xyXG4gKi9cclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuaW1wb3J0IEF2YXRhciBmcm9tICdAL2NvbXBvbmVudHMvQXZhdGFyJztcclxuaW1wb3J0IEdpdEh1YkNvZGVMaW5rIGZyb20gJ0AvY29tcG9uZW50cy9HaXRIdWJDb2RlTGluayc7XHJcblxyXG5jb25zdCBIZWFkZXIgPSAoeyBjYXB0aW9uLCBhdXRob3IsIGRlc2NyaXB0aW9uLCBjb2RlTGlua1VybCB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxoZWFkZXJcclxuICAgICAgaWQ9XCJoZWFkZXJcIlxyXG4gICAgICByb2xlPVwiYmFubmVyXCJcclxuICAgICAgY2xhc3NOYW1lPVwic3RpY2t5LWhlYWRlclxyXG4gICAgICAgICAgICAgICAgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgdGV4dC1jZW50ZXJcclxuICAgICAgICAgICAgICAgIGJnLWdyYXktODAwXCJcclxuICAgID5cclxuICAgICAgPGRpdlxyXG4gICAgICAgIGNsYXNzTmFtZT1cInAtMyBmb250LWJsYWNrIGZvbnQtT3N3YWxkLVZhcmlhYmxlRm9udFxyXG4gICAgICAgICAgICAgICAgIHRleHQtbGcgbWQ6dGV4dC0zeGwgbGc6dGV4dC00eGxcclxuICAgICAgICAgICAgICAgICB0ZXh0LXdoaXRlXCJcclxuICAgICAgPlxyXG4gICAgICAgIHtjYXB0aW9ufVxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZDpwLTJcIj5cclxuICAgICAgICA8TGluayBocmVmPVwiL1wiPlxyXG4gICAgICAgICAgPGEgY2xhc3NOYW1lPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIHctYXV0byBjdXJzb3ItcG9pbnRlciBmb2N1czpvdXRsaW5lLW5vbmVcIj5cclxuICAgICAgICAgICAgPEF2YXRhclxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImgtMTIgdy0xMiByb3VuZGVkLWZ1bGwgbWQ6bXItMiBtZDpoLTIwIG1kOnctMjBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci00IGJvcmRlci13aGl0ZS0yMDAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gaG92ZXI6c2NhbGUtMTI1IGhvdmVyOmJnLW9wYWNpdHktNTAgdHJhbnNpdGlvbiBlYXNlLW91dCBkdXJhdGlvbi01MDBcIlxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC9hPlxyXG4gICAgICAgIDwvTGluaz5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgPExpbmsgaHJlZj1cIi9cIj5cclxuICAgICAgICAgIDxhIGNsYXNzTmFtZT1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciB3LWF1dG8gY3Vyc29yLXBvaW50ZXIgZm9jdXM6b3V0bGluZS1ub25lXCI+XHJcbiAgICAgICAgICAgIDxzcGFuXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0zIGZvbnQtYm9sZCBpdGFsaWNcclxuICAgICAgICAgICAgICAgICAgICAgIGZvbnQtR3JhbmRzdGFuZGVyLVZhcmlhYmxlRm9udFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dC14bCBtZDp0ZXh0LTN4bCBsZzp0ZXh0LTR4bFxyXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtIGhvdmVyOnNjYWxlLXgtOTAgdHJhbnNpdGlvbiBlYXNlLWluLW91dCBkdXJhdGlvbi01MDBcclxuICAgICAgICAgICAgICAgICAgICAgIHRleHQtYmx1ZS00MDBcIlxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAge2F1dGhvciB8fCAnJ31cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgPC9hPlxyXG4gICAgICAgIDwvTGluaz5cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgICA8R2l0SHViQ29kZUxpbmtcclxuICAgICAgICBjYXB0aW9uPXsnc2VlIHRoZSBjb2RlIG9uIEdpdEh1Yid9XHJcbiAgICAgICAgY29kZUxpbmtVcmw9e2NvZGVMaW5rVXJsfVxyXG4gICAgICAgIGluTmV3VGFiPXt0cnVlfVxyXG4gICAgICAvPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhpZGRlbiBiZy1ncmF5LTUwMCB3LWZ1bGxcIj5cclxuICAgICAgICA8c2VjdGlvbiBhcmlhLWxhYmVsPVwiRGVtbyBkZXNjcmlwdGlvblwiPlxyXG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInAtMyBmb250LW5vcm1hbCB0ZXh0LXdoaXRlIGl0YWxpYyBmb250LXNlcmlmIHRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbiB8fCAnJ31cclxuICAgICAgICAgIDwvaDI+XHJcbiAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvaGVhZGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZWFkZXI7XHJcblxyXG5IZWFkZXIucHJvcFR5cGVzID0ge1xyXG4gIGNhcHRpb246IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxuICBhdXRob3I6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgZGVzY3JpcHRpb246IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgY29kZUxpbmtVcmw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxufTtcclxuIiwiLyoqXHJcbiAqSG9tZSBCdXR0b25cclxuICogQGRlc2NyaXB0aW9uIFJldHVybiB0byB0aGUgSG9tZSBQYWdlXHJcbiAqIEBhdXRob3IgZHRyby1kZXZ1ayBAZ2l0aHViOmR0cm8tZGV2dWsuaW9cclxuICovXHJcblxyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuY29uc3QgTGljZW5zZUJhbm5lciA9ICh7IGxpY2Vuc2VJbmZvIH0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdlxyXG4gICAgICBpZD1cImxpY2Vuc2luZy1pbmZvXCJcclxuICAgICAgYXJpYS1sYWJlbD1cImdvb2dsZSBGb250cyBsaWNlbnNpbmcgaW5mb1wiXHJcbiAgICAgIGNsYXNzTmFtZT1cImJnLWdyYXktNTAwIHctZnVsbCBwLTNcIlxyXG4gICAgPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInNtOnRleHQtc21cIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktMzAwIGZvbnQtc2FucyBmb250LW5vcm1hbCB0ZXh0LWNlbnRlciBwLTNcIj5cclxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJmb250LWJvbGQgdGV4dC1ncmF5LTcwMCB0ZXh0LWNlbnRlciB1cHBlcmNhc2UgbGVhZGluZy1sb29zZSBwLTNcIj5cclxuICAgICAgICAgICAgR29vZ2xlIEZvbnQgTGljZW5zaW5nXHJcbiAgICAgICAgICA8L2gyPlxyXG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTgwMCBmb250LXNlcmlmIGZvbnQtYm9sZCBwLTNcIj57bGljZW5zZUluZm99PC9wPlxyXG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTgwMCBmb250LXNlcmlmIHRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgIEFuIGBPRkwudHh0YCBmaWxlIGRldGFpbGluZyB0aGUgbGljZW5zZSBzaG91bGQgYmUgc3RvcmVkIGFsb25nc2lkZSB0aGUgZm9udHMsIHdoZW5cclxuICAgICAgICAgICAgc2VsZi1ob3N0ZWQgYW5kIGluIHlvdXIgR2l0SHViIFJlcG9cclxuICAgICAgICAgIDwvcD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuTGljZW5zZUJhbm5lci5wcm9wVHlwZXMgPSB7XHJcbiAgbGljZW5zZUluZm86IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpY2Vuc2VCYW5uZXI7XHJcbiIsIi8qKlxyXG4gKiBBIHNpbXBsZSBob29rIHRvIExvYWQgc2VsZi1ob3N0ZWQgR29vZ2xlIEZvbnRzIGZhbWFsaWVzXHJcbiAqXHJcbiAqIFdlIGFyZSB1c2UgRm9udCBGYWNlIE9ic2VydmVyIG5wbSBwYWNrYWdlIHRvIGxvYWQgdGhlXHJcbiAqXHJcbiAqIEBzZWUgOiBodHRwczovL2dpdGh1Yi5jb20vYnJhbXN0ZWluL2ZvbnRmYWNlb2JzZXJ2ZXJcclxuICpcclxuICovXHJcbmNvbnN0IEZvbnRGYWNlT2JzZXJ2ZXIgPSByZXF1aXJlKCdmb250ZmFjZW9ic2VydmVyJyk7XHJcblxyXG5leHBvcnQgY29uc3QgdXNlR29vZ2xlRm9udExvYWRlciA9ICgpID0+IHtcclxuICBjb25zdCBkZWJ1ZyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XHJcblxyXG4gIGNvbnN0IGJhc2VGb250T25lID0gIWRlYnVnXHJcbiAgICA/ICcvbmV4dGpzLXRhaWx3aW5kLWdvb2dsZWZvbnRzLXNlbGZob3N0LXN0YXJ0ZXIvc3RhdGljL2ZvbnRzL2dvb2dsZS9ncmFuZHN0YW5kZXIvR3JhbmRzdGFuZGVyLVZhcmlhYmxlRm9udF93Z2h0LnR0ZidcclxuICAgIDogJy9zdGF0aWMvZm9udHMvZ29vZ2xlL2dyYW5kc3RhbmRlci9HcmFuZHN0YW5kZXItVmFyaWFibGVGb250X3dnaHQudHRmJztcclxuXHJcbiAgY29uc3QgYmFzZUZvbnRUd28gPSAhZGVidWdcclxuICAgID8gJy9uZXh0anMtdGFpbHdpbmQtZ29vZ2xlZm9udHMtc2VsZmhvc3Qtc3RhcnRlci9zdGF0aWMvZm9udHMvZ29vZ2xlL29zd2FsZC9Pc3dhbGQtVmFyaWFibGVGb250X3dnaHQudHRmJ1xyXG4gICAgOiAnL3N0YXRpYy9mb250cy9nb29nbGUvb3N3YWxkL09zd2FsZC1WYXJpYWJsZUZvbnRfd2dodC50dGYnO1xyXG5cclxuICBjb25zdCBsaW5rT25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xyXG4gIGxpbmtPbmUuaHJlZiA9IGJhc2VGb250T25lO1xyXG4gIGxpbmtPbmUucmVsID0gJ3ByZWxvYWQnO1xyXG4gIGxpbmtPbmUuYXMgPSAnZm9udCc7XHJcbiAgbGlua09uZS50eXBlID0gJ2ZvbnQvdHRmJztcclxuICBsaW5rT25lLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcblxyXG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGlua09uZSk7XHJcblxyXG4gIGNvbnN0IGxpbmtUd28gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XHJcbiAgbGlua1R3by5ocmVmID0gYmFzZUZvbnRUd287XHJcbiAgbGlua1R3by5yZWwgPSAncHJlbG9hZCc7XHJcbiAgbGlua1R3by5hcyA9ICdmb250JztcclxuICBsaW5rVHdvLnR5cGUgPSAnZm9udC90dGYnO1xyXG4gIGxpbmtUd28uY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuXHJcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rVHdvKTtcclxuXHJcbiAgTG9hZFRoZUZvbnRzKCk7XHJcblxyXG4gIC8vIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2VPYnNlcnZlcignR3JhbmRzdGFuZGVyIFZhcmlhYmxlJyk7XHJcblxyXG4gIC8vIGZvbnRcclxuICAvLyAgIC5sb2FkKClcclxuICAvLyAgIC50aGVuKCgpID0+IHtcclxuICAvLyAgICAgY29uc29sZS5sb2coJ0ZvbnQgaGFzIGxvYWRlZC4nKTtcclxuICAvLyAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ0dyYW5kc3RhbmRlciBWYXJpYWJsZScpO1xyXG4gIC8vICAgfSlcclxuICAvLyAgIC5jYXRjaCgoKSA9PiB7XHJcbiAgLy8gICAgIGNvbnNvbGUubG9nKCdGb250IFNhbnMgZmFpbGVkIHRvIGxvYWQuJyk7XHJcbiAgLy8gICB9KTtcclxuXHJcbiAgLy8gY29uc3QgZm9udERhdGEgPSB7XHJcbiAgLy8gICAnR3JhbmRzdGFuZGVyIFZhcmlhYmxlJzoge30sXHJcbiAgLy8gICAnT3N3YWxkIFZhcmlhYmxlJzoge30sXHJcbiAgLy8gICAnTWVycml3ZWF0aGVyIFNhbnMnOiB7fSxcclxuICAvLyAgIC8vIEV0Yy5cclxuICAvLyB9O1xyXG5cclxuICAvLyBjb25zdCBmb250R3JhbmRzdGFuZGVyViA9IGdldEdyYW5kc3RhbmRlclBhdGgoZGVidWcpO1xyXG4gIC8vIGNvbnN0IGZvbnRPc3dhbGRWID0gZ2V0T3N3YWxkUGF0aChkZWJ1Zyk7XHJcblxyXG4gIC8vIGFkZEZvbnRQcmVsb2FkTGluayhmb250R3JhbmRzdGFuZGVyVik7XHJcbiAgLy8gYWRkRm9udFByZWxvYWRMaW5rKGZvbnRPc3dhbGRWKTtcclxuXHJcbiAgLy8gZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcclxuXHJcbiAgLy8gbG9hZEFsbEZvbnRzKGZvbnREYXRhKTtcclxuXHJcbiAgLy8gY29uc3QgZ3JhbmRzdGFuZGVyViA9ICdHcmFuZHN0YW5kZXItVmFyaWFibGVGb250X3dnaHQudHRmJztcclxuICAvLyBjb25zdCBvc3dhbGRWID0gJ09zd2FsZC1WYXJpYWJsZUZvbnRfd2dodC50dGYnO1xyXG5cclxuICAvLyBjb25zb2xlLmxvZyhkZWJ1Zyk7XHJcbiAgLy8gY29uc29sZS5sb2coYWxsZm9udHNDc3MpO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0R3JhbmRzdGFuZGVyUGF0aCA9IChkZWJ1ZykgPT4ge1xyXG4gIGNvbnN0IGZvbnRWID0gJ0dyYW5kc3RhbmRlci1WYXJpYWJsZUZvbnRfd2dodC50dGYnO1xyXG4gIGNvbnN0IHBhdGhUbyA9ICFkZWJ1Z1xyXG4gICAgPyAnL25leHRqcy10YWlsd2luZC1nb29nbGVmb250cy1zZWxmaG9zdC1zdGFydGVyL3N0YXRpYy9mb250cy9nb29nbGUvZ3JhbmRzdGFuZGVyLycgKyBmb250VlxyXG4gICAgOiAnL3N0YXRpYy9mb250cy9nb29nbGUvZ3JhbmRzdGFuZGVyLycgKyBmb250VjtcclxuICByZXR1cm4gcGF0aFRvO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0T3N3YWxkUGF0aCA9IChkZWJ1ZykgPT4ge1xyXG4gIGNvbnN0IGZvbnRWID0gJ09zd2FsZC1WYXJpYWJsZUZvbnRfd2dodC50dGYnO1xyXG4gIGNvbnN0IHBhdGhUbyA9ICFkZWJ1Z1xyXG4gICAgPyAnL25leHRqcy10YWlsd2luZC1nb29nbGVmb250cy1zZWxmaG9zdC1zdGFydGVyL3N0YXRpYy9mb250cy9nb29nbGUvb3N3YWxkLycgKyBmb250VlxyXG4gICAgOiAnL3N0YXRpYy9mb250cy9nb29nbGUvb3N3YWxkLycgKyBmb250VjtcclxuICByZXR1cm4gcGF0aFRvO1xyXG59O1xyXG5cclxuY29uc3QgTG9hZFRoZUZvbnRzID0gKCkgPT4ge1xyXG4gIHZhciBvbmUgPSBuZXcgRm9udEZhY2VPYnNlcnZlcignR3JhbmRzdGFuZGVyIFZhcmlhYmxlJyk7XHJcbiAgdmFyIHR3byA9IG5ldyBGb250RmFjZU9ic2VydmVyKCdPc3dhbGQgVmFyaWFibGUnKTtcclxuICB2YXIgdGhyZWUgPSBuZXcgRm9udEZhY2VPYnNlcnZlcignTWVycml3ZWF0aGVyIFNhbnMnKTtcclxuXHJcbiAgUHJvbWlzZS5hbGwoW29uZS5sb2FkKCksIHR3by5sb2FkKCksIHRocmVlLmxvYWQoKV0pXHJcbiAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUaGUgY3JpdGljYWwgZm9udHMgYXJlIGhhdmUgbG9hZGVkJyk7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgY29uc29sZS53YXJuKCdTb21lIGNyaXRpY2FsIGZvbnQgYXJlIG5vdCBhdmFpbGFibGU6JywgZXJyKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLy8gY29uc3QgbG9hZEFsbEZvbnRzID0gKGZvbnREYXRhKSA9PiB7XHJcbi8vICAgbGV0IG9ic2VydmVycyA9IFtdO1xyXG5cclxuLy8gICBPYmplY3Qua2V5cyhmb250RGF0YSkuZm9yRWFjaCgoZmFtaWx5KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gZm9udERhdGFbZmFtaWx5XTtcclxuLy8gICAgIGNvbnN0IG9icyA9IG5ldyBGb250RmFjZU9ic2VydmVyKGZhbWlseSwgZGF0YSk7XHJcbi8vICAgICBvYnNlcnZlcnMucHVzaChvYnMubG9hZCgpKTtcclxuLy8gICB9KTtcclxuXHJcbi8vICAgUHJvbWlzZS5hbGwob2JzZXJ2ZXJzKVxyXG4vLyAgICAgLnRoZW4oKGZvbnRzKSA9PiB7XHJcbi8vICAgICAgICg8Zm9udHMgY2xhc3NOYW1lPVwiZm9yZWFjaFwiPjwvZm9udHM+KSgoZm9udCkgPT4ge1xyXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKGZvbnQuZmFtaWx5ICsgJyBsb2FkZWQnKTtcclxuLy8gICAgICAgICAvLyBNYXAgdGhlIHJlc3VsdCBvZiB0aGUgUHJvbWlzZSBiYWNrIHRvIG91ciBleGlzdGluZyBkYXRhLFxyXG4vLyAgICAgICAgIC8vIHRvIGdldCB0aGUgb3RoZXIgcHJvcGVydGllcyB3ZSBuZWVkLlxyXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKGZvbnREYXRhW2ZvbnQuZmFtaWx5XSk7XHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSlcclxuLy8gICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbi8vICAgICAgIGNvbnNvbGUud2FybignU29tZSBjcml0aWNhbCBmb250IGFyZSBub3QgYXZhaWxhYmxlOicsIGVycik7XHJcbi8vICAgICB9KTtcclxuLy8gfTtcclxuXHJcbmNvbnN0IGFkZEZvbnRQcmVsb2FkTGluayA9IChmb250TGluaykgPT4ge1xyXG4gIGxldCBmbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcclxuICBmbGluay5ocmVmID0gZm9udExpbms7XHJcbiAgZmxpbmsucmVsID0gJ3ByZWxvYWQnO1xyXG4gIGZsaW5rLmFzID0gJ2ZvbnQnO1xyXG4gIGZsaW5rLnR5cGUgPSAnZm9udC90dGYnO1xyXG4gIGZsaW5rLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcblxyXG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZmxpbmspO1xyXG5cclxuICBjb25zb2xlLmxvZyhgRm9udCBwcmVsb2FkZWQ6ICR7Zm9udExpbmt9YCk7XHJcbn07XHJcbiIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3RcIik7XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIi8qIEZvbnQgRmFjZSBPYnNlcnZlciB2Mi4xLjAgLSDCqSBCcmFtIFN0ZWluLiBMaWNlbnNlOiBCU0QtMy1DbGF1c2UgKi8oZnVuY3Rpb24oKXtmdW5jdGlvbiBsKGEsYil7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixiLCExKTphLmF0dGFjaEV2ZW50KFwic2Nyb2xsXCIsYil9ZnVuY3Rpb24gbShhKXtkb2N1bWVudC5ib2R5P2EoKTpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyP2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsZnVuY3Rpb24gYygpe2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsYyk7YSgpfSk6ZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbiBrKCl7aWYoXCJpbnRlcmFjdGl2ZVwiPT1kb2N1bWVudC5yZWFkeVN0YXRlfHxcImNvbXBsZXRlXCI9PWRvY3VtZW50LnJlYWR5U3RhdGUpZG9jdW1lbnQuZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixrKSxhKCl9KX07ZnVuY3Rpb24gdChhKXt0aGlzLmE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0aGlzLmEuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIik7dGhpcy5hLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpKTt0aGlzLmI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7dGhpcy5jPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3RoaXMuaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTt0aGlzLmY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7dGhpcy5nPS0xO3RoaXMuYi5zdHlsZS5jc3NUZXh0PVwibWF4LXdpZHRoOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvdmVyZmxvdzpzY3JvbGw7Zm9udC1zaXplOjE2cHg7XCI7dGhpcy5jLnN0eWxlLmNzc1RleHQ9XCJtYXgtd2lkdGg6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO292ZXJmbG93OnNjcm9sbDtmb250LXNpemU6MTZweDtcIjtcbnRoaXMuZi5zdHlsZS5jc3NUZXh0PVwibWF4LXdpZHRoOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvdmVyZmxvdzpzY3JvbGw7Zm9udC1zaXplOjE2cHg7XCI7dGhpcy5oLnN0eWxlLmNzc1RleHQ9XCJkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoyMDAlO2hlaWdodDoyMDAlO2ZvbnQtc2l6ZToxNnB4O21heC13aWR0aDpub25lO1wiO3RoaXMuYi5hcHBlbmRDaGlsZCh0aGlzLmgpO3RoaXMuYy5hcHBlbmRDaGlsZCh0aGlzLmYpO3RoaXMuYS5hcHBlbmRDaGlsZCh0aGlzLmIpO3RoaXMuYS5hcHBlbmRDaGlsZCh0aGlzLmMpfVxuZnVuY3Rpb24gdShhLGIpe2EuYS5zdHlsZS5jc3NUZXh0PVwibWF4LXdpZHRoOm5vbmU7bWluLXdpZHRoOjIwcHg7bWluLWhlaWdodDoyMHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDphdXRvO21hcmdpbjowO3BhZGRpbmc6MDt0b3A6LTk5OXB4O3doaXRlLXNwYWNlOm5vd3JhcDtmb250LXN5bnRoZXNpczpub25lO2ZvbnQ6XCIrYitcIjtcIn1mdW5jdGlvbiB6KGEpe3ZhciBiPWEuYS5vZmZzZXRXaWR0aCxjPWIrMTAwO2EuZi5zdHlsZS53aWR0aD1jK1wicHhcIjthLmMuc2Nyb2xsTGVmdD1jO2EuYi5zY3JvbGxMZWZ0PWEuYi5zY3JvbGxXaWR0aCsxMDA7cmV0dXJuIGEuZyE9PWI/KGEuZz1iLCEwKTohMX1mdW5jdGlvbiBBKGEsYil7ZnVuY3Rpb24gYygpe3ZhciBhPWs7eihhKSYmYS5hLnBhcmVudE5vZGUmJmIoYS5nKX12YXIgaz1hO2woYS5iLGMpO2woYS5jLGMpO3ooYSl9O2Z1bmN0aW9uIEIoYSxiKXt2YXIgYz1ifHx7fTt0aGlzLmZhbWlseT1hO3RoaXMuc3R5bGU9Yy5zdHlsZXx8XCJub3JtYWxcIjt0aGlzLndlaWdodD1jLndlaWdodHx8XCJub3JtYWxcIjt0aGlzLnN0cmV0Y2g9Yy5zdHJldGNofHxcIm5vcm1hbFwifXZhciBDPW51bGwsRD1udWxsLEU9bnVsbCxGPW51bGw7ZnVuY3Rpb24gRygpe2lmKG51bGw9PT1EKWlmKEooKSYmL0FwcGxlLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudmVuZG9yKSl7dmFyIGE9L0FwcGxlV2ViS2l0XFwvKFswLTldKykoPzpcXC4oWzAtOV0rKSkoPzpcXC4oWzAtOV0rKSkvLmV4ZWMod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO0Q9ISFhJiY2MDM+cGFyc2VJbnQoYVsxXSwxMCl9ZWxzZSBEPSExO3JldHVybiBEfWZ1bmN0aW9uIEooKXtudWxsPT09RiYmKEY9ISFkb2N1bWVudC5mb250cyk7cmV0dXJuIEZ9XG5mdW5jdGlvbiBLKCl7aWYobnVsbD09PUUpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dHJ5e2Euc3R5bGUuZm9udD1cImNvbmRlbnNlZCAxMDBweCBzYW5zLXNlcmlmXCJ9Y2F0Y2goYil7fUU9XCJcIiE9PWEuc3R5bGUuZm9udH1yZXR1cm4gRX1mdW5jdGlvbiBMKGEsYil7cmV0dXJuW2Euc3R5bGUsYS53ZWlnaHQsSygpP2Euc3RyZXRjaDpcIlwiLFwiMTAwcHhcIixiXS5qb2luKFwiIFwiKX1cbkIucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGs9YXx8XCJCRVNic3d5XCIscj0wLG49Ynx8M0UzLEg9KG5ldyBEYXRlKS5nZXRUaW1lKCk7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGEsYil7aWYoSigpJiYhRygpKXt2YXIgTT1uZXcgUHJvbWlzZShmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGUoKXsobmV3IERhdGUpLmdldFRpbWUoKS1IPj1uP2IoRXJyb3IoXCJcIituK1wibXMgdGltZW91dCBleGNlZWRlZFwiKSk6ZG9jdW1lbnQuZm9udHMubG9hZChMKGMsJ1wiJytjLmZhbWlseSsnXCInKSxrKS50aGVuKGZ1bmN0aW9uKGMpezE8PWMubGVuZ3RoP2EoKTpzZXRUaW1lb3V0KGUsMjUpfSxiKX1lKCl9KSxOPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEsYyl7cj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YyhFcnJvcihcIlwiK24rXCJtcyB0aW1lb3V0IGV4Y2VlZGVkXCIpKX0sbil9KTtQcm9taXNlLnJhY2UoW04sTV0pLnRoZW4oZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQocik7YShjKX0sXG5iKX1lbHNlIG0oZnVuY3Rpb24oKXtmdW5jdGlvbiB2KCl7dmFyIGI7aWYoYj0tMSE9ZiYmLTEhPWd8fC0xIT1mJiYtMSE9aHx8LTEhPWcmJi0xIT1oKShiPWYhPWcmJmYhPWgmJmchPWgpfHwobnVsbD09PUMmJihiPS9BcHBsZVdlYktpdFxcLyhbMC05XSspKD86XFwuKFswLTldKykpLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSxDPSEhYiYmKDUzNj5wYXJzZUludChiWzFdLDEwKXx8NTM2PT09cGFyc2VJbnQoYlsxXSwxMCkmJjExPj1wYXJzZUludChiWzJdLDEwKSkpLGI9QyYmKGY9PXcmJmc9PXcmJmg9PXd8fGY9PXgmJmc9PXgmJmg9PXh8fGY9PXkmJmc9PXkmJmg9PXkpKSxiPSFiO2ImJihkLnBhcmVudE5vZGUmJmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSxjbGVhclRpbWVvdXQociksYShjKSl9ZnVuY3Rpb24gSSgpe2lmKChuZXcgRGF0ZSkuZ2V0VGltZSgpLUg+PW4pZC5wYXJlbnROb2RlJiZkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksYihFcnJvcihcIlwiK1xubitcIm1zIHRpbWVvdXQgZXhjZWVkZWRcIikpO2Vsc2V7dmFyIGE9ZG9jdW1lbnQuaGlkZGVuO2lmKCEwPT09YXx8dm9pZCAwPT09YSlmPWUuYS5vZmZzZXRXaWR0aCxnPXAuYS5vZmZzZXRXaWR0aCxoPXEuYS5vZmZzZXRXaWR0aCx2KCk7cj1zZXRUaW1lb3V0KEksNTApfX12YXIgZT1uZXcgdChrKSxwPW5ldyB0KGspLHE9bmV3IHQoayksZj0tMSxnPS0xLGg9LTEsdz0tMSx4PS0xLHk9LTEsZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2QuZGlyPVwibHRyXCI7dShlLEwoYyxcInNhbnMtc2VyaWZcIikpO3UocCxMKGMsXCJzZXJpZlwiKSk7dShxLEwoYyxcIm1vbm9zcGFjZVwiKSk7ZC5hcHBlbmRDaGlsZChlLmEpO2QuYXBwZW5kQ2hpbGQocC5hKTtkLmFwcGVuZENoaWxkKHEuYSk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkKTt3PWUuYS5vZmZzZXRXaWR0aDt4PXAuYS5vZmZzZXRXaWR0aDt5PXEuYS5vZmZzZXRXaWR0aDtJKCk7QShlLGZ1bmN0aW9uKGEpe2Y9YTt2KCl9KTt1KGUsXG5MKGMsJ1wiJytjLmZhbWlseSsnXCIsc2Fucy1zZXJpZicpKTtBKHAsZnVuY3Rpb24oYSl7Zz1hO3YoKX0pO3UocCxMKGMsJ1wiJytjLmZhbWlseSsnXCIsc2VyaWYnKSk7QShxLGZ1bmN0aW9uKGEpe2g9YTt2KCl9KTt1KHEsTChjLCdcIicrYy5mYW1pbHkrJ1wiLG1vbm9zcGFjZScpKX0pfSl9O1wib2JqZWN0XCI9PT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPUI6KHdpbmRvdy5Gb250RmFjZU9ic2VydmVyPUIsd2luZG93LkZvbnRGYWNlT2JzZXJ2ZXIucHJvdG90eXBlLmxvYWQ9Qi5wcm90b3R5cGUubG9hZCk7fSgpKTtcbiIsIlwidXNlIHN0cmljdFwiO3ZhciBhc3NpZ249T2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7bW9kdWxlLmV4cG9ydHM9YXNzaWduO21vZHVsZS5leHBvcnRzLmRlZmF1bHQ9bW9kdWxlLmV4cG9ydHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QtYXNzaWduLmpzLm1hcCIsIlxuICAgICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICAgIFwiL1wiLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJEOlxcXFxXb3JrQXJlYVxcXFxHaXRIdWJcXFxcbmV4dGpzLXRhaWx3aW5kLWdvb2dsZWZvbnRzLXNlbGZob3N0LXN0YXJ0ZXJcXFxccGFnZXNcXFxcaW5kZXguanNcIik7XG4gICAgICAgIH1cbiAgICAgIF0pO1xuICAgICIsImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBhZGRCYXNlUGF0aCxcbiAgYWRkTG9jYWxlLFxuICBnZXREb21haW5Mb2NhbGUsXG4gIGlzTG9jYWxVUkwsXG4gIE5leHRSb3V0ZXIsXG4gIFByZWZldGNoT3B0aW9ucyxcbiAgcmVzb2x2ZUhyZWYsXG59IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5pbXBvcnQgeyB1c2VJbnRlcnNlY3Rpb24gfSBmcm9tICcuL3VzZS1pbnRlcnNlY3Rpb24nXG5cbnR5cGUgVXJsID0gc3RyaW5nIHwgVXJsT2JqZWN0XG50eXBlIFJlcXVpcmVkS2V5czxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzoge30gZXh0ZW5kcyBQaWNrPFQsIEs+ID8gbmV2ZXIgOiBLXG59W2tleW9mIFRdXG50eXBlIE9wdGlvbmFsS2V5czxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzoge30gZXh0ZW5kcyBQaWNrPFQsIEs+ID8gSyA6IG5ldmVyXG59W2tleW9mIFRdXG5cbmV4cG9ydCB0eXBlIExpbmtQcm9wcyA9IHtcbiAgaHJlZjogVXJsXG4gIGFzPzogVXJsXG4gIHJlcGxhY2U/OiBib29sZWFuXG4gIHNjcm9sbD86IGJvb2xlYW5cbiAgc2hhbGxvdz86IGJvb2xlYW5cbiAgcGFzc0hyZWY/OiBib29sZWFuXG4gIHByZWZldGNoPzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxufVxudHlwZSBMaW5rUHJvcHNSZXF1aXJlZCA9IFJlcXVpcmVkS2V5czxMaW5rUHJvcHM+XG50eXBlIExpbmtQcm9wc09wdGlvbmFsID0gT3B0aW9uYWxLZXlzPExpbmtQcm9wcz5cblxuY29uc3QgcHJlZmV0Y2hlZDogeyBbY2FjaGVLZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9XG5cbmZ1bmN0aW9uIHByZWZldGNoKFxuICByb3V0ZXI6IE5leHRSb3V0ZXIsXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgb3B0aW9ucz86IFByZWZldGNoT3B0aW9uc1xuKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhcm91dGVyKSByZXR1cm5cbiAgaWYgKCFpc0xvY2FsVVJMKGhyZWYpKSByZXR1cm5cbiAgLy8gUHJlZmV0Y2ggdGhlIEpTT04gcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAvLyB3YW50IHRvIGZvcmNlIG5hdmlnYXRpb24gc2luY2UgdGhpcyBpcyBvbmx5IGEgcHJlZmV0Y2hcbiAgcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSlcbiAgY29uc3QgY3VyTG9jYWxlID1cbiAgICBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gb3B0aW9ucy5sb2NhbGVcbiAgICAgIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGVcblxuICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhcyArIChjdXJMb2NhbGUgPyAnJScgKyBjdXJMb2NhbGUgOiAnJyldID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpOiBib29sZWFuIHtcbiAgY29uc3QgeyB0YXJnZXQgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnRcbiAgcmV0dXJuIChcbiAgICAodGFyZ2V0ICYmIHRhcmdldCAhPT0gJ19zZWxmJykgfHxcbiAgICBldmVudC5tZXRhS2V5IHx8XG4gICAgZXZlbnQuY3RybEtleSB8fFxuICAgIGV2ZW50LnNoaWZ0S2V5IHx8XG4gICAgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgKGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyKVxuICApXG59XG5cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKFxuICBlOiBSZWFjdC5Nb3VzZUV2ZW50LFxuICByb3V0ZXI6IE5leHRSb3V0ZXIsXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgcmVwbGFjZT86IGJvb2xlYW4sXG4gIHNoYWxsb3c/OiBib29sZWFuLFxuICBzY3JvbGw/OiBib29sZWFuLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuKTogdm9pZCB7XG4gIGNvbnN0IHsgbm9kZU5hbWUgfSA9IGUuY3VycmVudFRhcmdldFxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0EnICYmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgIWlzTG9jYWxVUkwoaHJlZikpKSB7XG4gICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgcmV0dXJuXG4gIH1cblxuICBlLnByZXZlbnREZWZhdWx0KClcblxuICAvLyAgYXZvaWQgc2Nyb2xsIGZvciB1cmxzIHdpdGggYW5jaG9yIHJlZnNcbiAgaWYgKHNjcm9sbCA9PSBudWxsKSB7XG4gICAgc2Nyb2xsID0gYXMuaW5kZXhPZignIycpIDwgMFxuICB9XG5cbiAgLy8gcmVwbGFjZSBzdGF0ZSBpbnN0ZWFkIG9mIHB1c2ggaWYgcHJvcCBpcyBwcmVzZW50XG4gIHJvdXRlcltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnXShocmVmLCBhcywge1xuICAgIHNoYWxsb3csXG4gICAgbG9jYWxlLFxuICAgIHNjcm9sbCxcbiAgfSkudGhlbigoc3VjY2VzczogYm9vbGVhbikgPT4ge1xuICAgIGlmICghc3VjY2VzcykgcmV0dXJuXG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgLy8gRklYTUU6IHByb3BlciByb3V0ZSBhbm5vdW5jaW5nIGF0IFJvdXRlciBsZXZlbCwgbm90IExpbms6XG4gICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKClcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIExpbmsocHJvcHM6IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPExpbmtQcm9wcz4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV1cblxuICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xvY2FsZScpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAncHJlZmV0Y2gnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBoYXNXYXJuZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpXG4gICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCdcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgY29uc3QgcCA9IHByb3BzLnByZWZldGNoICE9PSBmYWxzZVxuXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gIGNvbnN0IHBhdGhuYW1lID0gKHJvdXRlciAmJiByb3V0ZXIucGF0aG5hbWUpIHx8ICcvJ1xuXG4gIGNvbnN0IHsgaHJlZiwgYXMgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocGF0aG5hbWUsIHByb3BzLmhyZWYsIHRydWUpXG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgIGFzOiBwcm9wcy5hc1xuICAgICAgICA/IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5hcylcbiAgICAgICAgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZixcbiAgICB9XG4gIH0sIFtwYXRobmFtZSwgcHJvcHMuaHJlZiwgcHJvcHMuYXNdKVxuXG4gIGxldCB7IGNoaWxkcmVuLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSB9ID0gcHJvcHNcblxuICAvLyBEZXByZWNhdGVkLiBXYXJuaW5nIHNob3duIGJ5IHByb3BUeXBlIGNoZWNrLiBJZiB0aGUgY2hpbGRyZW4gcHJvdmlkZWQgaXMgYSBzdHJpbmcgKDxMaW5rPmV4YW1wbGU8L0xpbms+KSB3ZSB3cmFwIGl0IGluIGFuIDxhPiB0YWdcbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgY29uc3QgY2hpbGQ6IGFueSA9IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gIGNvbnN0IGNoaWxkUmVmOiBhbnkgPSBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZlxuXG4gIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZV0gPSB1c2VJbnRlcnNlY3Rpb24oe1xuICAgIHJvb3RNYXJnaW46ICcyMDBweCcsXG4gIH0pXG4gIGNvbnN0IHNldFJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlbDogRWxlbWVudCkgPT4ge1xuICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKVxuICAgICAgaWYgKGNoaWxkUmVmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdmdW5jdGlvbicpIGNoaWxkUmVmKGVsKVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY2hpbGRSZWYuY3VycmVudCA9IGVsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtjaGlsZFJlZiwgc2V0SW50ZXJzZWN0aW9uUmVmXVxuICApXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkUHJlZmV0Y2ggPSBpc1Zpc2libGUgJiYgcCAmJiBpc0xvY2FsVVJMKGhyZWYpXG4gICAgY29uc3QgY3VyTG9jYWxlID1cbiAgICAgIHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGVcbiAgICBjb25zdCBpc1ByZWZldGNoZWQgPVxuICAgICAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXVxuICAgIGlmIChzaG91bGRQcmVmZXRjaCAmJiAhaXNQcmVmZXRjaGVkKSB7XG4gICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgIGxvY2FsZTogY3VyTG9jYWxlLFxuICAgICAgfSlcbiAgICB9XG4gIH0sIFthcywgaHJlZiwgaXNWaXNpYmxlLCBsb2NhbGUsIHAsIHJvdXRlcl0pXG5cbiAgY29uc3QgY2hpbGRQcm9wczoge1xuICAgIG9uTW91c2VFbnRlcj86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgb25DbGljazogUmVhY3QuTW91c2VFdmVudEhhbmRsZXJcbiAgICBocmVmPzogc3RyaW5nXG4gICAgcmVmPzogYW55XG4gIH0gPSB7XG4gICAgcmVmOiBzZXRSZWYsXG4gICAgb25DbGljazogKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICB9XG4gICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSlcbiAgICAgIH1cbiAgICB9LFxuICB9XG5cbiAgY2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKVxuICAgIH1cbiAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7IHByaW9yaXR5OiB0cnVlIH0pXG4gIH1cblxuICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyXG4gIGlmIChwcm9wcy5wYXNzSHJlZiB8fCAoY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkpIHtcbiAgICBjb25zdCBjdXJMb2NhbGUgPVxuICAgICAgdHlwZW9mIGxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbGUgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZVxuXG4gICAgY29uc3QgbG9jYWxlRG9tYWluID0gZ2V0RG9tYWluTG9jYWxlKFxuICAgICAgYXMsXG4gICAgICBjdXJMb2NhbGUsXG4gICAgICByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZXMsXG4gICAgICByb3V0ZXIgJiYgcm91dGVyLmRvbWFpbkxvY2FsZXNcbiAgICApXG5cbiAgICBjaGlsZFByb3BzLmhyZWYgPVxuICAgICAgbG9jYWxlRG9tYWluIHx8XG4gICAgICBhZGRCYXNlUGF0aChhZGRMb2NhbGUoYXMsIGN1ckxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5kZWZhdWx0TG9jYWxlKSlcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtcbiIsIi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGlmIHRoZXJlIGlzIG9uZS4gUHJlc2VydmVzIHRoZSByb290IHBhdGggYC9gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguZW5kc1dpdGgoJy8nKSAmJiBwYXRoICE9PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGhcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBgdHJhaWxpbmdTbGFzaGAgb3B0aW9uXG4gKiBpbiBgbmV4dC5jb25maWcuanNgLlxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSBwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0hcbiAgPyAocGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGlmICgvXFwuW14vXStcXC8/JC8udGVzdChwYXRoKSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aClcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBwYXRoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvJ1xuICAgICAgfVxuICAgIH1cbiAgOiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaFxuIiwidHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlID0gYW55XG50eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zID0ge1xuICB0aW1lb3V0OiBudW1iZXJcbn1cbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lID0ge1xuICByZWFkb25seSBkaWRUaW1lb3V0OiBib29sZWFuXG4gIHRpbWVSZW1haW5pbmc6ICgpID0+IG51bWJlclxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s6IChcbiAgICAgIGNhbGxiYWNrOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZCxcbiAgICAgIG9wdHM/OiBSZXF1ZXN0SWRsZUNhbGxiYWNrT3B0aW9uc1xuICAgICkgPT4gUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZVxuICB9XG59XG5cbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjaykgfHxcbiAgZnVuY3Rpb24gKFxuICAgIGNiOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZFxuICApOiBOb2RlSlMuVGltZW91dCB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKHtcbiAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSlcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSwgMSlcbiAgfVxuXG5leHBvcnQgZGVmYXVsdCByZXF1ZXN0SWRsZUNhbGxiYWNrXG4iLCJpbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDbGllbnRCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vYnVpbGQvd2VicGFjay9wbHVnaW5zL2J1aWxkLW1hbmlmZXN0LXBsdWdpbidcbmltcG9ydCBnZXRBc3NldFBhdGhGcm9tUm91dGUgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlJ1xuaW1wb3J0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgZnJvbSAnLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2snXG5cbi8vIDMuOHMgd2FzIGFyYml0cmFyaWx5IGNob3NlbiBhcyBpdCdzIHdoYXQgaHR0cHM6Ly93ZWIuZGV2L2ludGVyYWN0aXZlXG4vLyBjb25zaWRlcnMgYXMgXCJHb29kXCIgdGltZS10by1pbnRlcmFjdGl2ZS4gV2UgbXVzdCBhc3N1bWUgc29tZXRoaW5nIHdlbnRcbi8vIHdyb25nIGJleW9uZCB0aGlzIHBvaW50LCBhbmQgdGhlbiBmYWxsLWJhY2sgdG8gYSBmdWxsIHBhZ2UgdHJhbnNpdGlvbiB0b1xuLy8gc2hvdyB0aGUgdXNlciBzb21ldGhpbmcgb2YgdmFsdWUuXG5jb25zdCBNU19NQVhfSURMRV9ERUxBWSA9IDM4MDBcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX0JVSUxEX01BTklGRVNUPzogQ2xpZW50QnVpbGRNYW5pZmVzdFxuICAgIF9fQlVJTERfTUFOSUZFU1RfQ0I/OiBGdW5jdGlvblxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3Mge1xuICBjb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgZXhwb3J0czogYW55XG59XG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZEVudHJ5cG9pbnRGYWlsdXJlIHtcbiAgZXJyb3I6IHVua25vd25cbn1cbmV4cG9ydCB0eXBlIFJvdXRlRW50cnlwb2ludCA9IExvYWRlZEVudHJ5cG9pbnRTdWNjZXNzIHwgTG9hZGVkRW50cnlwb2ludEZhaWx1cmVcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVN0eWxlU2hlZXQge1xuICBocmVmOiBzdHJpbmdcbiAgY29udGVudDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkUm91dGVTdWNjZXNzIGV4dGVuZHMgTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3Mge1xuICBzdHlsZXM6IFJvdXRlU3R5bGVTaGVldFtdXG59XG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZFJvdXRlRmFpbHVyZSB7XG4gIGVycm9yOiB1bmtub3duXG59XG5leHBvcnQgdHlwZSBSb3V0ZUxvYWRlckVudHJ5ID0gTG9hZGVkUm91dGVTdWNjZXNzIHwgTG9hZGVkUm91dGVGYWlsdXJlXG5cbmV4cG9ydCB0eXBlIEZ1dHVyZTxWPiA9IHtcbiAgcmVzb2x2ZTogKGVudHJ5cG9pbnQ6IFYpID0+IHZvaWRcbiAgZnV0dXJlOiBQcm9taXNlPFY+XG59XG5mdW5jdGlvbiB3aXRoRnV0dXJlPFQ+KFxuICBrZXk6IHN0cmluZyxcbiAgbWFwOiBNYXA8c3RyaW5nLCBGdXR1cmU8VD4gfCBUPixcbiAgZ2VuZXJhdG9yPzogKCkgPT4gUHJvbWlzZTxUPlxuKTogUHJvbWlzZTxUPiB7XG4gIGxldCBlbnRyeTogRnV0dXJlPFQ+IHwgVCB8IHVuZGVmaW5lZCA9IG1hcC5nZXQoa2V5KVxuICBpZiAoZW50cnkpIHtcbiAgICBpZiAoJ2Z1dHVyZScgaW4gZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS5mdXR1cmVcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlbnRyeSlcbiAgfVxuICBsZXQgcmVzb2x2ZXI6IChlbnRyeXBvaW50OiBUKSA9PiB2b2lkXG4gIGNvbnN0IHByb206IFByb21pc2U8VD4gPSBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSkgPT4ge1xuICAgIHJlc29sdmVyID0gcmVzb2x2ZVxuICB9KVxuICBtYXAuc2V0KGtleSwgKGVudHJ5ID0geyByZXNvbHZlOiByZXNvbHZlciEsIGZ1dHVyZTogcHJvbSB9KSlcbiAgcmV0dXJuIGdlbmVyYXRvclxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgZ2VuZXJhdG9yKCkudGhlbigodmFsdWUpID0+IChyZXNvbHZlcih2YWx1ZSksIHZhbHVlKSlcbiAgICA6IHByb21cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZUxvYWRlciB7XG4gIHdoZW5FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlRW50cnlwb2ludD5cbiAgb25FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcsIGV4ZWN1dGU6ICgpID0+IHVua25vd24pOiB2b2lkXG4gIGxvYWRSb3V0ZShyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZUxvYWRlckVudHJ5PlxuICBwcmVmZXRjaChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPlxufVxuXG5mdW5jdGlvbiBoYXNQcmVmZXRjaChsaW5rPzogSFRNTExpbmtFbGVtZW50KTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgIHJldHVybiAoXG4gICAgICAvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgIC8vIHdpdGggcmVsTGlzdC5zdXBwb3J0XG4gICAgICAoISF3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgISEoZG9jdW1lbnQgYXMgYW55KS5kb2N1bWVudE1vZGUpIHx8XG4gICAgICBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJylcbiAgICApXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmNvbnN0IGNhblByZWZldGNoOiBib29sZWFuID0gaGFzUHJlZmV0Y2goKVxuXG5mdW5jdGlvbiBwcmVmZXRjaFZpYURvbShcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICBsaW5rPzogSFRNTExpbmtFbGVtZW50XG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGxpbmtbcmVsPVwicHJlZmV0Y2hcIl1baHJlZl49XCIke2hyZWZ9XCJdYCkpIHtcbiAgICAgIHJldHVybiByZXMoKVxuICAgIH1cblxuICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcblxuICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWw6XG4gICAgaWYgKGFzKSBsaW5rIS5hcyA9IGFzXG4gICAgbGluayEucmVsID0gYHByZWZldGNoYFxuICAgIGxpbmshLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTiFcbiAgICBsaW5rIS5vbmxvYWQgPSByZXNcbiAgICBsaW5rIS5vbmVycm9yID0gcmVqXG5cbiAgICAvLyBgaHJlZmAgc2hvdWxkIGFsd2F5cyBiZSBsYXN0OlxuICAgIGxpbmshLmhyZWYgPSBocmVmXG5cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspXG4gIH0pXG59XG5cbmNvbnN0IEFTU0VUX0xPQURfRVJST1IgPSBTeW1ib2woJ0FTU0VUX0xPQURfRVJST1InKVxuLy8gVE9ETzogdW5leHBvcnRcbmV4cG9ydCBmdW5jdGlvbiBtYXJrQXNzZXRFcnJvcihlcnI6IEVycm9yKTogRXJyb3Ige1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgQVNTRVRfTE9BRF9FUlJPUiwge30pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fzc2V0RXJyb3IoZXJyPzogRXJyb3IpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGVyciAmJiBBU1NFVF9MT0FEX0VSUk9SIGluIGVyclxufVxuXG5mdW5jdGlvbiBhcHBlbmRTY3JpcHQoXG4gIHNyYzogc3RyaW5nLFxuICBzY3JpcHQ/OiBIVE1MU2NyaXB0RWxlbWVudFxuKTogUHJvbWlzZTx1bmtub3duPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcblxuICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWwuXG4gICAgLy8gMS4gU2V0dXAgc3VjY2Vzcy9mYWlsdXJlIGhvb2tzIGluIGNhc2UgdGhlIGJyb3dzZXIgc3luY2hyb25vdXNseVxuICAgIC8vICAgIGV4ZWN1dGVzIHdoZW4gYHNyY2AgaXMgc2V0LlxuICAgIHNjcmlwdC5vbmxvYWQgPSByZXNvbHZlXG4gICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PlxuICAgICAgcmVqZWN0KG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc2NyaXB0OiAke3NyY31gKSkpXG5cbiAgICAvLyAyLiBDb25maWd1cmUgdGhlIGNyb3NzLW9yaWdpbiBhdHRyaWJ1dGUgYmVmb3JlIHNldHRpbmcgYHNyY2AgaW4gY2FzZSB0aGVcbiAgICAvLyAgICBicm93c2VyIGJlZ2lucyB0byBmZXRjaC5cbiAgICBzY3JpcHQuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOIVxuXG4gICAgLy8gMy4gRmluYWxseSwgc2V0IHRoZSBzb3VyY2UgYW5kIGluamVjdCBpbnRvIHRoZSBET00gaW4gY2FzZSB0aGUgY2hpbGRcbiAgICAvLyAgICBtdXN0IGJlIGFwcGVuZGVkIGZvciBmZXRjaGluZyB0byBzdGFydC5cbiAgICBzY3JpcHQuc3JjID0gc3JjXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlkbGVUaW1lb3V0PFQ+KG1zOiBudW1iZXIsIGVycjogRXJyb3IpOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QoZXJyKSwgbXMpKVxuICApXG59XG5cbi8vIFRPRE86IHN0b3AgZXhwb3J0aW5nIG9yIGNhY2hlIHRoZSBmYWlsdXJlXG4vLyBJdCdkIGJlIGJlc3QgdG8gc3RvcCBleHBvcnRpbmcgdGhpcy4gSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIFdlJ3JlXG4vLyBvbmx5IGV4cG9ydGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWx0eSB3aXRoIHRoZSBgcGFnZS1sb2FkZXJgLlxuLy8gT25seSBjYWNoZSB0aGlzIHJlc3BvbnNlIGFzIGEgbGFzdCByZXNvcnQgaWYgd2UgY2Fubm90IGVsaW1pbmF0ZSBhbGwgb3RoZXJcbi8vIGNvZGUgYnJhbmNoZXMgdGhhdCB1c2UgdGhlIEJ1aWxkIE1hbmlmZXN0IENhbGxiYWNrIGFuZCBwdXNoIHRoZW0gdGhyb3VnaFxuLy8gdGhlIFJvdXRlIExvYWRlciBpbnRlcmZhY2UuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpOiBQcm9taXNlPENsaWVudEJ1aWxkTWFuaWZlc3Q+IHtcbiAgaWYgKHNlbGYuX19CVUlMRF9NQU5JRkVTVCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKVxuICB9XG5cbiAgY29uc3Qgb25CdWlsZE1hbmlmZXN0OiBQcm9taXNlPENsaWVudEJ1aWxkTWFuaWZlc3Q+ID0gbmV3IFByb21pc2U8XG4gICAgQ2xpZW50QnVpbGRNYW5pZmVzdFxuICA+KChyZXNvbHZlKSA9PiB7XG4gICAgLy8gTWFuZGF0b3J5IGJlY2F1c2UgdGhpcyBpcyBub3QgY29uY3VycmVudCBzYWZlOlxuICAgIGNvbnN0IGNiID0gc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCXG4gICAgc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpXG4gICAgICBjYiAmJiBjYigpXG4gICAgfVxuICB9KVxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICBvbkJ1aWxkTWFuaWZlc3QsXG4gICAgaWRsZVRpbWVvdXQ8Q2xpZW50QnVpbGRNYW5pZmVzdD4oXG4gICAgICBNU19NQVhfSURMRV9ERUxBWSxcbiAgICAgIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgY2xpZW50IGJ1aWxkIG1hbmlmZXN0JykpXG4gICAgKSxcbiAgXSlcbn1cblxuaW50ZXJmYWNlIFJvdXRlRmlsZXMge1xuICBzY3JpcHRzOiBzdHJpbmdbXVxuICBjc3M6IHN0cmluZ1tdXG59XG5mdW5jdGlvbiBnZXRGaWxlc0ZvclJvdXRlKFxuICBhc3NldFByZWZpeDogc3RyaW5nLFxuICByb3V0ZTogc3RyaW5nXG4pOiBQcm9taXNlPFJvdXRlRmlsZXM+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBzY3JpcHRzOiBbXG4gICAgICAgIGFzc2V0UHJlZml4ICtcbiAgICAgICAgICAnL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMnICtcbiAgICAgICAgICBlbmNvZGVVUkkoZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKHJvdXRlLCAnLmpzJykpLFxuICAgICAgXSxcbiAgICAgIC8vIFN0eWxlcyBhcmUgaGFuZGxlZCBieSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudDpcbiAgICAgIGNzczogW10sXG4gICAgfSlcbiAgfVxuICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KSA9PiB7XG4gICAgaWYgKCEocm91dGUgaW4gbWFuaWZlc3QpKSB7XG4gICAgICB0aHJvdyBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb29rdXAgcm91dGU6ICR7cm91dGV9YCkpXG4gICAgfVxuICAgIGNvbnN0IGFsbEZpbGVzID0gbWFuaWZlc3Rbcm91dGVdLm1hcChcbiAgICAgIChlbnRyeSkgPT4gYXNzZXRQcmVmaXggKyAnL19uZXh0LycgKyBlbmNvZGVVUkkoZW50cnkpXG4gICAgKVxuICAgIHJldHVybiB7XG4gICAgICBzY3JpcHRzOiBhbGxGaWxlcy5maWx0ZXIoKHYpID0+IHYuZW5kc1dpdGgoJy5qcycpKSxcbiAgICAgIGNzczogYWxsRmlsZXMuZmlsdGVyKCh2KSA9PiB2LmVuZHNXaXRoKCcuY3NzJykpLFxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVMb2FkZXIoYXNzZXRQcmVmaXg6IHN0cmluZyk6IFJvdXRlTG9hZGVyIHtcbiAgY29uc3QgZW50cnlwb2ludHM6IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgRnV0dXJlPFJvdXRlRW50cnlwb2ludD4gfCBSb3V0ZUVudHJ5cG9pbnRcbiAgPiA9IG5ldyBNYXAoKVxuICBjb25zdCBsb2FkZWRTY3JpcHRzOiBNYXA8c3RyaW5nLCBQcm9taXNlPHVua25vd24+PiA9IG5ldyBNYXAoKVxuICBjb25zdCBzdHlsZVNoZWV0czogTWFwPHN0cmluZywgUHJvbWlzZTxSb3V0ZVN0eWxlU2hlZXQ+PiA9IG5ldyBNYXAoKVxuICBjb25zdCByb3V0ZXM6IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgRnV0dXJlPFJvdXRlTG9hZGVyRW50cnk+IHwgUm91dGVMb2FkZXJFbnRyeVxuICA+ID0gbmV3IE1hcCgpXG5cbiAgZnVuY3Rpb24gbWF5YmVFeGVjdXRlU2NyaXB0KHNyYzogc3RyaW5nKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgbGV0IHByb206IFByb21pc2U8dW5rbm93bj4gfCB1bmRlZmluZWQgPSBsb2FkZWRTY3JpcHRzLmdldChzcmMpXG4gICAgaWYgKHByb20pIHtcbiAgICAgIHJldHVybiBwcm9tXG4gICAgfVxuXG4gICAgLy8gU2tpcCBleGVjdXRpbmcgc2NyaXB0IGlmIGl0J3MgYWxyZWFkeSBpbiB0aGUgRE9NOlxuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7c3JjfVwiXWApKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICBsb2FkZWRTY3JpcHRzLnNldChzcmMsIChwcm9tID0gYXBwZW5kU2NyaXB0KHNyYykpKVxuICAgIHJldHVybiBwcm9tXG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaFN0eWxlU2hlZXQoaHJlZjogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZVN0eWxlU2hlZXQ+IHtcbiAgICBsZXQgcHJvbTogUHJvbWlzZTxSb3V0ZVN0eWxlU2hlZXQ+IHwgdW5kZWZpbmVkID0gc3R5bGVTaGVldHMuZ2V0KGhyZWYpXG4gICAgaWYgKHByb20pIHtcbiAgICAgIHJldHVybiBwcm9tXG4gICAgfVxuXG4gICAgc3R5bGVTaGVldHMuc2V0KFxuICAgICAgaHJlZixcbiAgICAgIChwcm9tID0gZmV0Y2goaHJlZilcbiAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0eWxlc2hlZXQ6ICR7aHJlZn1gKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKCh0ZXh0KSA9PiAoeyBocmVmOiBocmVmLCBjb250ZW50OiB0ZXh0IH0pKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKGVycilcbiAgICAgICAgfSkpXG4gICAgKVxuICAgIHJldHVybiBwcm9tXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdoZW5FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiB3aXRoRnV0dXJlKHJvdXRlLCBlbnRyeXBvaW50cylcbiAgICB9LFxuICAgIG9uRW50cnlwb2ludChyb3V0ZTogc3RyaW5nLCBleGVjdXRlOiAoKSA9PiB1bmtub3duKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoZXhlY3V0ZSlcbiAgICAgICAgLnRoZW4oKGZuKSA9PiBmbigpKVxuICAgICAgICAudGhlbihcbiAgICAgICAgICAoZXhwb3J0czogYW55KSA9PiAoe1xuICAgICAgICAgICAgY29tcG9uZW50OiAoZXhwb3J0cyAmJiBleHBvcnRzLmRlZmF1bHQpIHx8IGV4cG9ydHMsXG4gICAgICAgICAgICBleHBvcnRzOiBleHBvcnRzLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIChlcnIpID0+ICh7IGVycm9yOiBlcnIgfSlcbiAgICAgICAgKVxuICAgICAgICAudGhlbigoaW5wdXQ6IFJvdXRlRW50cnlwb2ludCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZCA9IGVudHJ5cG9pbnRzLmdldChyb3V0ZSlcbiAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KVxuICAgICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkgb2xkLnJlc29sdmUoaW5wdXQpXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBsb2FkUm91dGUocm91dGU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmU8Um91dGVMb2FkZXJFbnRyeT4ocm91dGUsIHJvdXRlcywgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgc2NyaXB0cywgY3NzIH0gPSBhd2FpdCBnZXRGaWxlc0ZvclJvdXRlKGFzc2V0UHJlZml4LCByb3V0ZSlcbiAgICAgICAgICBjb25zdCBbLCBzdHlsZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgZW50cnlwb2ludHMuaGFzKHJvdXRlKVxuICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgIDogUHJvbWlzZS5hbGwoc2NyaXB0cy5tYXAobWF5YmVFeGVjdXRlU2NyaXB0KSksXG4gICAgICAgICAgICBQcm9taXNlLmFsbChjc3MubWFwKGZldGNoU3R5bGVTaGVldCkpLFxuICAgICAgICAgIF0gYXMgY29uc3QpXG5cbiAgICAgICAgICBjb25zdCBlbnRyeXBvaW50OiBSb3V0ZUVudHJ5cG9pbnQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgdGhpcy53aGVuRW50cnlwb2ludChyb3V0ZSksXG4gICAgICAgICAgICBpZGxlVGltZW91dDxSb3V0ZUxvYWRlckVudHJ5PihcbiAgICAgICAgICAgICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgICAgICAgICAgIG1hcmtBc3NldEVycm9yKFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcihgUm91dGUgZGlkIG5vdCBjb21wbGV0ZSBsb2FkaW5nOiAke3JvdXRlfWApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSlcbiAgICAgICAgICBjb25zdCByZXM6IFJvdXRlTG9hZGVyRW50cnkgPSBPYmplY3QuYXNzaWduPFxuICAgICAgICAgICAgeyBzdHlsZXM6IFJvdXRlU3R5bGVTaGVldFtdIH0sXG4gICAgICAgICAgICBSb3V0ZUVudHJ5cG9pbnRcbiAgICAgICAgICA+KHsgc3R5bGVzIH0sIGVudHJ5cG9pbnQpXG4gICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXNcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyciB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBwcmVmZXRjaChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9xdWlja2xpbmsvYmxvYi80NTNhNjYxZmExZmE5NDBlMmQyZTA0NDQ1MjM5OGUzOGM2N2E5OGZiL3NyYy9pbmRleC5tanMjTDExNS1MMTE4XG4gICAgICAvLyBMaWNlbnNlOiBBcGFjaGUgMi4wXG4gICAgICBsZXQgY25cbiAgICAgIGlmICgoY24gPSAobmF2aWdhdG9yIGFzIGFueSkuY29ubmVjdGlvbikpIHtcbiAgICAgICAgLy8gRG9uJ3QgcHJlZmV0Y2ggaWYgdXNpbmcgMkcgb3IgaWYgU2F2ZS1EYXRhIGlzIGVuYWJsZWQuXG4gICAgICAgIGlmIChjbi5zYXZlRGF0YSB8fCAvMmcvLnRlc3QoY24uZWZmZWN0aXZlVHlwZSkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAudGhlbigob3V0cHV0KSA9PlxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgY2FuUHJlZmV0Y2hcbiAgICAgICAgICAgICAgPyBvdXRwdXQuc2NyaXB0cy5tYXAoKHNjcmlwdCkgPT4gcHJlZmV0Y2hWaWFEb20oc2NyaXB0LCAnc2NyaXB0JykpXG4gICAgICAgICAgICAgIDogW11cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gdGhpcy5sb2FkUm91dGUocm91dGUpKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goXG4gICAgICAgICAgLy8gc3dhbGxvdyBwcmVmZXRjaCBlcnJvcnNcbiAgICAgICAgICAoKSA9PiB7fVxuICAgICAgICApXG4gICAgfSxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSb3V0ZUxvYWRlclxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJvdXRlciwgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0J1xuXG50eXBlIENsYXNzQXJndW1lbnRzPFQ+ID0gVCBleHRlbmRzIG5ldyAoLi4uYXJnczogaW5mZXIgVSkgPT4gYW55ID8gVSA6IGFueVxuXG50eXBlIFJvdXRlckFyZ3MgPSBDbGFzc0FyZ3VtZW50czx0eXBlb2YgUm91dGVyPlxuXG50eXBlIFNpbmdsZXRvblJvdXRlckJhc2UgPSB7XG4gIHJvdXRlcjogUm91dGVyIHwgbnVsbFxuICByZWFkeUNhbGxiYWNrczogQXJyYXk8KCkgPT4gYW55PlxuICByZWFkeShjYjogKCkgPT4gYW55KTogdm9pZFxufVxuXG5leHBvcnQgeyBSb3V0ZXIsIE5leHRSb3V0ZXIgfVxuXG5leHBvcnQgdHlwZSBTaW5nbGV0b25Sb3V0ZXIgPSBTaW5nbGV0b25Sb3V0ZXJCYXNlICYgTmV4dFJvdXRlclxuXG5jb25zdCBzaW5nbGV0b25Sb3V0ZXI6IFNpbmdsZXRvblJvdXRlckJhc2UgPSB7XG4gIHJvdXRlcjogbnVsbCwgLy8gaG9sZHMgdGhlIGFjdHVhbCByb3V0ZXIgaW5zdGFuY2VcbiAgcmVhZHlDYWxsYmFja3M6IFtdLFxuICByZWFkeShjYjogKCkgPT4gdm9pZCkge1xuICAgIGlmICh0aGlzLnJvdXRlcikgcmV0dXJuIGNiKClcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVhZHlDYWxsYmFja3MucHVzaChjYilcbiAgICB9XG4gIH0sXG59XG5cbi8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcbmNvbnN0IHVybFByb3BlcnR5RmllbGRzID0gW1xuICAncGF0aG5hbWUnLFxuICAncm91dGUnLFxuICAncXVlcnknLFxuICAnYXNQYXRoJyxcbiAgJ2NvbXBvbmVudHMnLFxuICAnaXNGYWxsYmFjaycsXG4gICdiYXNlUGF0aCcsXG4gICdsb2NhbGUnLFxuICAnbG9jYWxlcycsXG4gICdkZWZhdWx0TG9jYWxlJyxcbiAgJ2lzUmVhZHknLFxuXVxuY29uc3Qgcm91dGVyRXZlbnRzID0gW1xuICAncm91dGVDaGFuZ2VTdGFydCcsXG4gICdiZWZvcmVIaXN0b3J5Q2hhbmdlJyxcbiAgJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLFxuICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICdoYXNoQ2hhbmdlU3RhcnQnLFxuICAnaGFzaENoYW5nZUNvbXBsZXRlJyxcbl1cbmNvbnN0IGNvcmVNZXRob2RGaWVsZHMgPSBbXG4gICdwdXNoJyxcbiAgJ3JlcGxhY2UnLFxuICAncmVsb2FkJyxcbiAgJ2JhY2snLFxuICAncHJlZmV0Y2gnLFxuICAnYmVmb3JlUG9wU3RhdGUnLFxuXVxuXG4vLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCAnZXZlbnRzJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIFJvdXRlci5ldmVudHNcbiAgfSxcbn0pXG5cbnVybFByb3BlcnR5RmllbGRzLmZvckVhY2goKGZpZWxkOiBzdHJpbmcpID0+IHtcbiAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgYmVjYXVzZSwgd2UgbmVlZCB0byByZXR1cm5cbiAgLy8gdGhlIHByb3BlcnR5IGFzc2lnbmVkIHRvIHRoZSBhY3R1YWwgcm91dGVyXG4gIC8vIFRoZSB2YWx1ZSBtaWdodCBnZXQgY2hhbmdlZCBhcyB3ZSBjaGFuZ2Ugcm91dGVzIGFuZCB0aGlzIGlzIHRoZVxuICAvLyBwcm9wZXIgd2F5IHRvIGFjY2VzcyBpdFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCBmaWVsZCwge1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgICAgcmV0dXJuIHJvdXRlcltmaWVsZF0gYXMgc3RyaW5nXG4gICAgfSxcbiAgfSlcbn0pXG5cbmNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQ6IHN0cmluZykgPT4ge1xuICAvLyBXZSBkb24ndCByZWFsbHkga25vdyB0aGUgdHlwZXMgaGVyZSwgc28gd2UgYWRkIHRoZW0gbGF0ZXIgaW5zdGVhZFxuICA7KHNpbmdsZXRvblJvdXRlciBhcyBhbnkpW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gIH1cbn0pXG5cbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudDogc3RyaW5nKSA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeSgoKSA9PiB7XG4gICAgUm91dGVyLmV2ZW50cy5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50RmllbGQgPSBgb24ke2V2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7ZXZlbnQuc3Vic3RyaW5nKFxuICAgICAgICAxXG4gICAgICApfWBcbiAgICAgIGNvbnN0IF9zaW5nbGV0b25Sb3V0ZXIgPSBzaW5nbGV0b25Sb3V0ZXIgYXMgYW55XG4gICAgICBpZiAoX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0oLi4uYXJncylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBnZXRSb3V0ZXIoKTogUm91dGVyIHtcbiAgaWYgKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAnTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicgK1xuICAgICAgJ1lvdSBzaG91bGQgb25seSB1c2UgXCJuZXh0L3JvdXRlclwiIGluc2lkZSB0aGUgY2xpZW50IHNpZGUgb2YgeW91ciBhcHAuXFxuJ1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG4gIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyXG59XG5cbi8vIEV4cG9ydCB0aGUgc2luZ2xldG9uUm91dGVyIGFuZCB0aGlzIGlzIHRoZSBwdWJsaWMgQVBJLlxuZXhwb3J0IGRlZmF1bHQgc2luZ2xldG9uUm91dGVyIGFzIFNpbmdsZXRvblJvdXRlclxuXG4vLyBSZWV4cG9ydCB0aGUgd2l0aFJvdXRlIEhPQ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aXRoUm91dGVyIH0gZnJvbSAnLi93aXRoLXJvdXRlcidcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcigpOiBOZXh0Um91dGVyIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUm91dGVyQ29udGV4dClcbn1cblxuLy8gSU5URVJOQUwgQVBJU1xuLy8gLS0tLS0tLS0tLS0tLVxuLy8gKGRvIG5vdCB1c2UgZm9sbG93aW5nIGV4cG9ydHMgaW5zaWRlIHRoZSBhcHApXG5cbi8vIENyZWF0ZSBhIHJvdXRlciBhbmQgYXNzaWduIGl0IGFzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuXG4vLyBUaGlzIGlzIHVzZWQgaW4gY2xpZW50IHNpZGUgd2hlbiB3ZSBhcmUgaW5pdGlsaXppbmcgdGhlIGFwcC5cbi8vIFRoaXMgc2hvdWxkICoqbm90KiogdXNlIGluc2lkZSB0aGUgc2VydmVyLlxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdXRlciA9ICguLi5hcmdzOiBSb3V0ZXJBcmdzKTogUm91dGVyID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJvdXRlciA9IG5ldyBSb3V0ZXIoLi4uYXJncylcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MgPSBbXVxuXG4gIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgdGhlIGB3aXRoUm91dGVyYCByb3V0ZXIgaW5zdGFuY2VcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyOiBSb3V0ZXIpOiBOZXh0Um91dGVyIHtcbiAgY29uc3QgX3JvdXRlciA9IHJvdXRlciBhcyBhbnlcbiAgY29uc3QgaW5zdGFuY2UgPSB7fSBhcyBhbnlcblxuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHVybFByb3BlcnR5RmllbGRzKSB7XG4gICAgaWYgKHR5cGVvZiBfcm91dGVyW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIEFycmF5LmlzQXJyYXkoX3JvdXRlcltwcm9wZXJ0eV0pID8gW10gOiB7fSxcbiAgICAgICAgX3JvdXRlcltwcm9wZXJ0eV1cbiAgICAgICkgLy8gbWFrZXMgc3VyZSBxdWVyeSBpcyBub3Qgc3RhdGVmdWxcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaW5zdGFuY2VbcHJvcGVydHldID0gX3JvdXRlcltwcm9wZXJ0eV1cbiAgfVxuXG4gIC8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbiAgaW5zdGFuY2UuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gIGNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICBpbnN0YW5jZVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgIHJldHVybiBfcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gaW5zdGFuY2Vcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCByZXF1ZXN0SWRsZUNhbGxiYWNrIGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuXG50eXBlIFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdCA9IFBpY2s8SW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0LCAncm9vdE1hcmdpbic+XG50eXBlIFVzZUludGVyc2VjdGlvbiA9IHsgZGlzYWJsZWQ/OiBib29sZWFuIH0gJiBVc2VJbnRlcnNlY3Rpb25PYnNlcnZlckluaXRcbnR5cGUgT2JzZXJ2ZUNhbGxiYWNrID0gKGlzVmlzaWJsZTogYm9vbGVhbikgPT4gdm9pZFxudHlwZSBPYnNlcnZlciA9IHtcbiAgaWQ6IHN0cmluZ1xuICBvYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgZWxlbWVudHM6IE1hcDxFbGVtZW50LCBPYnNlcnZlQ2FsbGJhY2s+XG59XG5cbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uPFQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gIHJvb3RNYXJnaW4sXG4gIGRpc2FibGVkLFxufTogVXNlSW50ZXJzZWN0aW9uKTogWyhlbGVtZW50OiBUIHwgbnVsbCkgPT4gdm9pZCwgYm9vbGVhbl0ge1xuICBjb25zdCBpc0Rpc2FibGVkOiBib29sZWFuID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyXG5cbiAgY29uc3QgdW5vYnNlcnZlID0gdXNlUmVmPEZ1bmN0aW9uPigpXG4gIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIGNvbnN0IHNldFJlZiA9IHVzZUNhbGxiYWNrKFxuICAgIChlbDogVCB8IG51bGwpID0+IHtcbiAgICAgIGlmICh1bm9ic2VydmUuY3VycmVudCkge1xuICAgICAgICB1bm9ic2VydmUuY3VycmVudCgpXG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVyblxuXG4gICAgICBpZiAoZWwgJiYgZWwudGFnTmFtZSkge1xuICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IG9ic2VydmUoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgKGlzVmlzaWJsZSkgPT4gaXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSxcbiAgICAgICAgICB7IHJvb3RNYXJnaW4gfVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSxcbiAgICBbaXNEaXNhYmxlZCwgcm9vdE1hcmdpbiwgdmlzaWJsZV1cbiAgKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgaWYgKCF2aXNpYmxlKSByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHNldFZpc2libGUodHJ1ZSkpXG4gICAgfVxuICB9LCBbdmlzaWJsZV0pXG5cbiAgcmV0dXJuIFtzZXRSZWYsIHZpc2libGVdXG59XG5cbmZ1bmN0aW9uIG9ic2VydmUoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGNhbGxiYWNrOiBPYnNlcnZlQ2FsbGJhY2ssXG4gIG9wdGlvbnM6IFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdFxuKTogKCkgPT4gdm9pZCB7XG4gIGNvbnN0IHsgaWQsIG9ic2VydmVyLCBlbGVtZW50cyB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucylcbiAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrKVxuXG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpOiB2b2lkIHtcbiAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudClcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudClcblxuICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGlkKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgTWFwPHN0cmluZywgT2JzZXJ2ZXI+KClcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG9wdGlvbnM6IFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdCk6IE9ic2VydmVyIHtcbiAgY29uc3QgaWQgPSBvcHRpb25zLnJvb3RNYXJnaW4gfHwgJydcbiAgbGV0IGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChpZClcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlXG4gIH1cblxuICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXA8RWxlbWVudCwgT2JzZXJ2ZUNhbGxiYWNrPigpXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KVxuICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgaXNWaXNpYmxlKSB7XG4gICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LCBvcHRpb25zKVxuXG4gIG9ic2VydmVycy5zZXQoXG4gICAgaWQsXG4gICAgKGluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBvYnNlcnZlcixcbiAgICAgIGVsZW1lbnRzLFxuICAgIH0pXG4gIClcbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Q29tcG9uZW50VHlwZSwgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciwgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5cbmV4cG9ydCB0eXBlIFdpdGhSb3V0ZXJQcm9wcyA9IHtcbiAgcm91dGVyOiBOZXh0Um91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPiA9IFBpY2s8XG4gIFAsXG4gIEV4Y2x1ZGU8a2V5b2YgUCwga2V5b2YgV2l0aFJvdXRlclByb3BzPlxuPlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoUm91dGVyPFxuICBQIGV4dGVuZHMgV2l0aFJvdXRlclByb3BzLFxuICBDID0gTmV4dFBhZ2VDb250ZXh0XG4+KFxuICBDb21wb3NlZENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8QywgYW55LCBQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxFeGNsdWRlUm91dGVyUHJvcHM8UD4+IHtcbiAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHM6IGFueSk6IEpTWC5FbGVtZW50IHtcbiAgICByZXR1cm4gPENvbXBvc2VkQ29tcG9uZW50IHJvdXRlcj17dXNlUm91dGVyKCl9IHsuLi5wcm9wc30gLz5cbiAgfVxuXG4gIFdpdGhSb3V0ZXJXcmFwcGVyLmdldEluaXRpYWxQcm9wcyA9IENvbXBvc2VkQ29tcG9uZW50LmdldEluaXRpYWxQcm9wc1xuICAvLyBUaGlzIGlzIG5lZWRlZCB0byBhbGxvdyBjaGVja2luZyBmb3IgY3VzdG9tIGdldEluaXRpYWxQcm9wcyBpbiBfYXBwXG4gIDsoV2l0aFJvdXRlcldyYXBwZXIgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzID0gKENvbXBvc2VkQ29tcG9uZW50IGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wc1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IG5hbWUgPVxuICAgICAgQ29tcG9zZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9zZWRDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbiAgICBXaXRoUm91dGVyV3JhcHBlci5kaXNwbGF5TmFtZSA9IGB3aXRoUm91dGVyKCR7bmFtZX0pYFxuICB9XG5cbiAgcmV0dXJuIFdpdGhSb3V0ZXJXcmFwcGVyXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVG9rZW5pemUgaW5wdXQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBsZXhlcihzdHIpIHtcbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHN0cltpXTtcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKlwiIHx8IGNoYXIgPT09IFwiK1wiIHx8IGNoYXIgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiTU9ESUZJRVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVTQ0FQRURfQ0hBUlwiLCBpbmRleDogaSsrLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJPUEVOXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDTE9TRVwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gYDAtOWBcbiAgICAgICAgICAgICAgICAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgQS1aYFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgYS16YFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYF9gXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCBcIiArIGkpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk5BTUVcIiwgaW5kZXg6IGksIHZhbHVlOiBuYW1lIH0pO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0dGVybiBjYW5ub3Qgc3RhcnQgd2l0aCBcXFwiP1xcXCIgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK10gKyBzdHJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyW2pdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyW2ogKyAxXSAhPT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYXB0dXJpbmcgZ3JvdXBzIGFyZSBub3QgYWxsb3dlZCBhdCBcIiArIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuYmFsYW5jZWQgcGF0dGVybiBhdCBcIiArIGkpO1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJQQVRURVJOXCIsIGluZGV4OiBpLCB2YWx1ZTogcGF0dGVybiB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICB9XG4gICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVORFwiLCBpbmRleDogaSwgdmFsdWU6IFwiXCIgfSk7XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciB0b2tlbnMgPSBsZXhlcihzdHIpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMucHJlZml4ZXMsIHByZWZpeGVzID0gX2EgPT09IHZvaWQgMCA/IFwiLi9cIiA6IF9hO1xuICAgIHZhciBkZWZhdWx0UGF0dGVybiA9IFwiW15cIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXSs/XCI7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXkgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgdmFyIHRyeUNvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2ldLnR5cGUgPT09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW2krK10udmFsdWU7XG4gICAgfTtcbiAgICB2YXIgbXVzdENvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb25zdW1lKHR5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFyIF9hID0gdG9rZW5zW2ldLCBuZXh0VHlwZSA9IF9hLnR5cGUsIGluZGV4ID0gX2EuaW5kZXg7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgbmV4dFR5cGUgKyBcIiBhdCBcIiArIGluZGV4ICsgXCIsIGV4cGVjdGVkIFwiICsgdHlwZSk7XG4gICAgfTtcbiAgICB2YXIgY29uc3VtZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB3aGlsZSAoKHZhbHVlID0gdHJ5Q29uc3VtZShcIkNIQVJcIikgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgd2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdHJ5Q29uc3VtZShcIkNIQVJcIik7XG4gICAgICAgIHZhciBuYW1lID0gdHJ5Q29uc3VtZShcIk5BTUVcIik7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIik7XG4gICAgICAgIGlmIChuYW1lIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjaGFyIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAocHJlZml4ZXMuaW5kZXhPZihwcmVmaXgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4gfHwgZGVmYXVsdFBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGNoYXIgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBwYXRoICs9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZW4gPSB0cnlDb25zdW1lKFwiT1BFTlwiKTtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjb25zdW1lVGV4dCgpO1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgcGF0dGVybl8xID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIikgfHwgXCJcIjtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBjb25zdW1lVGV4dCgpO1xuICAgICAgICAgICAgbXVzdENvbnN1bWUoXCJDTE9TRVwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXzEgfHwgKHBhdHRlcm5fMSA/IGtleSsrIDogXCJcIiksXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbmFtZV8xICYmICFwYXR0ZXJuXzEgPyBkZWZhdWx0UGF0dGVybiA6IHBhdHRlcm5fMSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogdHJ5Q29uc3VtZShcIk1PRElGSUVSXCIpIHx8IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbXVzdENvbnN1bWUoXCJFTkRcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZUZsYWdzID0gZmxhZ3Mob3B0aW9ucyk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hLCBfYiA9IG9wdGlvbnMudmFsaWRhdGUsIHZhbGlkYXRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgICB2YXIgbWF0Y2hlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSRcIiwgcmVGbGFncyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHBhdGggPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhID8gZGF0YVt0b2tlbi5uYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbCA9IHRva2VuLm1vZGlmaWVyID09PSBcIj9cIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCI7XG4gICAgICAgICAgICB2YXIgcmVwZWF0ID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIitcIjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGFsbCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZShTdHJpbmcodmFsdWUpLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbWF0Y2ggXFxcIlwiICsgdG9rZW4ucGF0dGVybiArIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdHlwZU9mTWVzc2FnZSA9IHJlcGVhdCA/IFwiYW4gYXJyYXlcIiA6IFwiYSBzdHJpbmdcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIGJlIFwiICsgdHlwZU9mTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbn1cbmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb247XG4vKipcbiAqIENyZWF0ZSBwYXRoIG1hdGNoIGZ1bmN0aW9uIGZyb20gYHBhdGgtdG8tcmVnZXhwYCBzcGVjLlxuICovXG5mdW5jdGlvbiBtYXRjaChzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHZhciByZSA9IHBhdGhUb1JlZ2V4cChzdHIsIGtleXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbi8qKlxuICogQ3JlYXRlIGEgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgb3V0cHV0LlxuICovXG5mdW5jdGlvbiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLmRlY29kZSwgZGVjb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2E7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICB2YXIgbSA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBwYXRoID0gbVswXSwgaW5kZXggPSBtLmluZGV4O1xuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAobVtpXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG4gICAgICAgICAgICBpZiAoa2V5Lm1vZGlmaWVyID09PSBcIipcIiB8fCBrZXkubW9kaWZpZXIgPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IG1baV0uc3BsaXQoa2V5LnByZWZpeCArIGtleS5zdWZmaXgpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZSh2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBkZWNvZGUobVtpXSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHBhdGg6IHBhdGgsIGluZGV4OiBpbmRleCwgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5yZWdleHBUb0Z1bmN0aW9uID0gcmVnZXhwVG9GdW5jdGlvbjtcbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBmbGFncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG59XG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cykge1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG4gICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBpLFxuICAgICAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBzdWZmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwKHBhdGhzLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnRzID0gcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykuc291cmNlOyB9KTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlwiICsgcGFydHMuam9pbihcInxcIikgKyBcIilcIiwgZmxhZ3Mob3B0aW9ucykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb1JlZ2V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnZXhwKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5zdHJpY3QsIHN0cmljdCA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IG9wdGlvbnMuc3RhcnQsIHN0YXJ0ID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgX2MgPSBvcHRpb25zLmVuZCwgZW5kID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBvcHRpb25zLmVuY29kZSwgZW5jb2RlID0gX2QgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2Q7XG4gICAgdmFyIGVuZHNXaXRoID0gXCJbXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5lbmRzV2l0aCB8fCBcIlwiKSArIFwiXXwkXCI7XG4gICAgdmFyIGRlbGltaXRlciA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8IFwiLyM/XCIpICsgXCJdXCI7XG4gICAgdmFyIHJvdXRlID0gc3RhcnQgPyBcIl5cIiA6IFwiXCI7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgICBmb3IgKHZhciBfaSA9IDAsIHRva2Vuc18xID0gdG9rZW5zOyBfaSA8IHRva2Vuc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNfMVtfaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnByZWZpeCkpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4uc3VmZml4KSk7XG4gICAgICAgICAgICBpZiAodG9rZW4ucGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzKVxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggfHwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5tb2RpZmllciA9PT0gXCIrXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiID8gXCI/XCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIFwiKCg/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSg/OlwiICsgc3VmZml4ICsgcHJlZml4ICsgXCIoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikpKilcIiArIHN1ZmZpeCArIFwiKVwiICsgbW9kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgc3VmZml4ICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgc3VmZml4ICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIGlmICghc3RyaWN0KVxuICAgICAgICAgICAgcm91dGUgKz0gZGVsaW1pdGVyICsgXCI/XCI7XG4gICAgICAgIHJvdXRlICs9ICFvcHRpb25zLmVuZHNXaXRoID8gXCIkXCIgOiBcIig/PVwiICsgZW5kc1dpdGggKyBcIilcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlbmRUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBpc0VuZERlbGltaXRlZCA9IHR5cGVvZiBlbmRUb2tlbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBkZWxpbWl0ZXIuaW5kZXhPZihlbmRUb2tlbltlbmRUb2tlbi5sZW5ndGggLSAxXSkgPiAtMVxuICAgICAgICAgICAgOiAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBlbmRUb2tlbiA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIGRlbGltaXRlciArIFwiKD89XCIgKyBlbmRzV2l0aCArIFwiKSk/XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VuZERlbGltaXRlZCkge1xuICAgICAgICAgICAgcm91dGUgKz0gXCIoPz1cIiArIGRlbGltaXRlciArIFwifFwiICsgZW5kc1dpdGggKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyb3V0ZSwgZmxhZ3Mob3B0aW9ucykpO1xufVxuZXhwb3J0cy50b2tlbnNUb1JlZ2V4cCA9IHRva2Vuc1RvUmVnZXhwO1xuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpXG4gICAgICAgIHJldHVybiBhcnJheVRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzdHJpbmdUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucGF0aFRvUmVnZXhwID0gcGF0aFRvUmVnZXhwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgQW1wU3RhdGVDb250ZXh0OiBSZWFjdC5Db250ZXh0PGFueT4gPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBBbXBTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnQW1wU3RhdGVDb250ZXh0J1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQW1wU3RhdGVDb250ZXh0IH0gZnJvbSAnLi9hbXAtY29udGV4dCdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5BbXBNb2RlKHtcbiAgYW1wRmlyc3QgPSBmYWxzZSxcbiAgaHlicmlkID0gZmFsc2UsXG4gIGhhc1F1ZXJ5ID0gZmFsc2UsXG59ID0ge30pOiBib29sZWFuIHtcbiAgcmV0dXJuIGFtcEZpcnN0IHx8IChoeWJyaWQgJiYgaGFzUXVlcnkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbXAoKTogYm9vbGVhbiB7XG4gIC8vIERvbid0IGFzc2lnbiB0aGUgY29udGV4dCB2YWx1ZSB0byBhIHZhcmlhYmxlIHRvIHNhdmUgYnl0ZXNcbiAgcmV0dXJuIGlzSW5BbXBNb2RlKFJlYWN0LnVzZUNvbnRleHQoQW1wU3RhdGVDb250ZXh0KSlcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEhlYWRNYW5hZ2VyQ29udGV4dDogUmVhY3QuQ29udGV4dDx7XG4gIHVwZGF0ZUhlYWQ/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBtb3VudGVkSW5zdGFuY2VzPzogYW55XG4gIHVwZGF0ZVNjcmlwdHM/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBzY3JpcHRzPzogYW55XG59PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEhlYWRNYW5hZ2VyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdIZWFkTWFuYWdlckNvbnRleHQnXG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IEVmZmVjdCBmcm9tICcuL3NpZGUtZWZmZWN0J1xuaW1wb3J0IHsgQW1wU3RhdGVDb250ZXh0IH0gZnJvbSAnLi9hbXAtY29udGV4dCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4vaGVhZC1tYW5hZ2VyLWNvbnRleHQnXG5pbXBvcnQgeyBpc0luQW1wTW9kZSB9IGZyb20gJy4vYW1wJ1xuXG50eXBlIFdpdGhJbkFtcE1vZGUgPSB7XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRIZWFkKGluQW1wTW9kZSA9IGZhbHNlKTogSlNYLkVsZW1lbnRbXSB7XG4gIGNvbnN0IGhlYWQgPSBbPG1ldGEgY2hhclNldD1cInV0Zi04XCIgLz5dXG4gIGlmICghaW5BbXBNb2RlKSB7XG4gICAgaGVhZC5wdXNoKDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGhcIiAvPilcbiAgfVxuICByZXR1cm4gaGVhZFxufVxuXG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KFxuICBsaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGNoaWxkOiBSZWFjdC5SZWFjdENoaWxkXG4pOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4ge1xuICAvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gIGlmIChjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdChcbiAgICAgIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZShcbiAgICAgICAgKFxuICAgICAgICAgIGZyYWdtZW50TGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgICAgICAgIGZyYWdtZW50Q2hpbGQ6IFJlYWN0LlJlYWN0Q2hpbGRcbiAgICAgICAgKTogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+ID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKVxuICAgICAgICB9LFxuICAgICAgICBbXVxuICAgICAgKVxuICAgIClcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoY2hpbGQpXG59XG5cbmNvbnN0IE1FVEFUWVBFUyA9IFsnbmFtZScsICdodHRwRXF1aXYnLCAnY2hhclNldCcsICdpdGVtUHJvcCddXG5cbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qL1xuZnVuY3Rpb24gdW5pcXVlKCkge1xuICBjb25zdCBrZXlzID0gbmV3IFNldCgpXG4gIGNvbnN0IHRhZ3MgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YVR5cGVzID0gbmV3IFNldCgpXG4gIGNvbnN0IG1ldGFDYXRlZ29yaWVzOiB7IFttZXRhdHlwZTogc3RyaW5nXTogU2V0PHN0cmluZz4gfSA9IHt9XG5cbiAgcmV0dXJuIChoOiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PikgPT4ge1xuICAgIGxldCBpc1VuaXF1ZSA9IHRydWVcbiAgICBsZXQgaGFzS2V5ID0gZmFsc2VcblxuICAgIGlmIChoLmtleSAmJiB0eXBlb2YgaC5rZXkgIT09ICdudW1iZXInICYmIGgua2V5LmluZGV4T2YoJyQnKSA+IDApIHtcbiAgICAgIGhhc0tleSA9IHRydWVcbiAgICAgIGNvbnN0IGtleSA9IGgua2V5LnNsaWNlKGgua2V5LmluZGV4T2YoJyQnKSArIDEpXG4gICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLmFkZChrZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgIHN3aXRjaCAoaC50eXBlKSB7XG4gICAgICBjYXNlICd0aXRsZSc6XG4gICAgICBjYXNlICdiYXNlJzpcbiAgICAgICAgaWYgKHRhZ3MuaGFzKGgudHlwZSkpIHtcbiAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFncy5hZGQoaC50eXBlKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtZXRhJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1FVEFUWVBFUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IG1ldGF0eXBlID0gTUVUQVRZUEVTW2ldXG4gICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWVcblxuICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gJ2NoYXJTZXQnKSB7XG4gICAgICAgICAgICBpZiAobWV0YVR5cGVzLmhhcyhtZXRhdHlwZSkpIHtcbiAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWV0YVR5cGVzLmFkZChtZXRhdHlwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBoLnByb3BzW21ldGF0eXBlXVxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSB8fCBuZXcgU2V0KClcbiAgICAgICAgICAgIGlmICgobWV0YXR5cGUgIT09ICduYW1lJyB8fCAhaGFzS2V5KSAmJiBjYXRlZ29yaWVzLmhhcyhjYXRlZ29yeSkpIHtcbiAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnkpXG4gICAgICAgICAgICAgIG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSA9IGNhdGVnb3JpZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNVbmlxdWVcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZEVsZW1lbnRzIExpc3Qgb2YgbXVsdGlwbGUgPEhlYWQ+IGluc3RhbmNlc1xuICovXG5mdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzKFxuICBoZWFkRWxlbWVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgcHJvcHM6IFdpdGhJbkFtcE1vZGVcbikge1xuICByZXR1cm4gaGVhZEVsZW1lbnRzXG4gICAgLnJlZHVjZShcbiAgICAgIChsaXN0OiBSZWFjdC5SZWFjdENoaWxkW10sIGhlYWRFbGVtZW50OiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PikgPT4ge1xuICAgICAgICBjb25zdCBoZWFkRWxlbWVudENoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShcbiAgICAgICAgICBoZWFkRWxlbWVudC5wcm9wcy5jaGlsZHJlblxuICAgICAgICApXG4gICAgICAgIHJldHVybiBsaXN0LmNvbmNhdChoZWFkRWxlbWVudENoaWxkcmVuKVxuICAgICAgfSxcbiAgICAgIFtdXG4gICAgKVxuICAgIC5yZWR1Y2Uob25seVJlYWN0RWxlbWVudCwgW10pXG4gICAgLnJldmVyc2UoKVxuICAgIC5jb25jYXQoZGVmYXVsdEhlYWQocHJvcHMuaW5BbXBNb2RlKSlcbiAgICAuZmlsdGVyKHVuaXF1ZSgpKVxuICAgIC5yZXZlcnNlKClcbiAgICAubWFwKChjOiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PiwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBjLmtleSB8fCBpXG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlaRV9GT05UUyAmJlxuICAgICAgICAhcHJvcHMuaW5BbXBNb2RlXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGMudHlwZSA9PT0gJ2xpbmsnICYmXG4gICAgICAgICAgYy5wcm9wc1snaHJlZiddICYmXG4gICAgICAgICAgLy8gVE9ETyhwcmF0ZWVrYmhAKTogUmVwbGFjZSB0aGlzIHdpdGggY29uc3QgZnJvbSBgY29uc3RhbnRzYCB3aGVuIHRoZSB0cmVlIHNoYWtpbmcgd29ya3MuXG4gICAgICAgICAgWydodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzcyddLnNvbWUoKHVybCkgPT5cbiAgICAgICAgICAgIGMucHJvcHNbJ2hyZWYnXS5zdGFydHNXaXRoKHVybClcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0geyAuLi4oYy5wcm9wcyB8fCB7fSkgfVxuICAgICAgICAgIG5ld1Byb3BzWydkYXRhLWhyZWYnXSA9IG5ld1Byb3BzWydocmVmJ11cbiAgICAgICAgICBuZXdQcm9wc1snaHJlZiddID0gdW5kZWZpbmVkXG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCB7IGtleSB9KVxuICAgIH0pXG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIEhlYWQoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCBhbXBTdGF0ZSA9IHVzZUNvbnRleHQoQW1wU3RhdGVDb250ZXh0KVxuICBjb25zdCBoZWFkTWFuYWdlciA9IHVzZUNvbnRleHQoSGVhZE1hbmFnZXJDb250ZXh0KVxuICByZXR1cm4gKFxuICAgIDxFZmZlY3RcbiAgICAgIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlPXtyZWR1Y2VDb21wb25lbnRzfVxuICAgICAgaGVhZE1hbmFnZXI9e2hlYWRNYW5hZ2VyfVxuICAgICAgaW5BbXBNb2RlPXtpc0luQW1wTW9kZShhbXBTdGF0ZSl9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRWZmZWN0PlxuICApXG59XG5cbi8vIFRPRE86IFJlbW92ZSBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5IZWFkLnJld2luZCA9ICgpID0+IHt9XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRcbiIsImV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGVQYXRoKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBsb2NhbGVzPzogc3RyaW5nW11cbik6IHtcbiAgZGV0ZWN0ZWRMb2NhbGU/OiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xufSB7XG4gIGxldCBkZXRlY3RlZExvY2FsZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIC8vIGZpcnN0IGl0ZW0gd2lsbCBiZSBlbXB0eSBzdHJpbmcgZnJvbSBzcGxpdHRpbmcgYXQgZmlyc3QgY2hhclxuICBjb25zdCBwYXRobmFtZVBhcnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKVxuXG4gIDsobG9jYWxlcyB8fCBbXSkuc29tZSgobG9jYWxlKSA9PiB7XG4gICAgaWYgKHBhdGhuYW1lUGFydHNbMV0udG9Mb3dlckNhc2UoKSA9PT0gbG9jYWxlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGRldGVjdGVkTG9jYWxlID0gbG9jYWxlXG4gICAgICBwYXRobmFtZVBhcnRzLnNwbGljZSgxLCAxKVxuICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZVBhcnRzLmpvaW4oJy8nKSB8fCAnLydcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgZGV0ZWN0ZWRMb2NhbGUsXG4gIH1cbn1cbiIsIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIEphc29uIE1pbGxlciAoaHR0cHM6Ly9qYXNvbmZvcm1hdC5jb20vKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG4vLyBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9taXR0L2Jsb2IvdjEuMS4zL3NyYy9pbmRleC5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCBmb3IgdGhlIG5lZWRzIG9mIHRoaXMgc2NyaXB0XG4vLyBTZWUgdGhlIExJQ0VOU0UgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZVxuXG50eXBlIEhhbmRsZXIgPSAoLi4uZXZ0czogYW55W10pID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgTWl0dEVtaXR0ZXIgPSB7XG4gIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKTogdm9pZFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXR0KCk6IE1pdHRFbWl0dGVyIHtcbiAgY29uc3QgYWxsOiB7IFtzOiBzdHJpbmddOiBIYW5kbGVyW10gfSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICByZXR1cm4ge1xuICAgIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgOyhhbGxbdHlwZV0gfHwgKGFsbFt0eXBlXSA9IFtdKSkucHVzaChoYW5kbGVyKVxuICAgIH0sXG5cbiAgICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICBpZiAoYWxsW3R5cGVdKSB7XG4gICAgICAgIGFsbFt0eXBlXS5zcGxpY2UoYWxsW3R5cGVdLmluZGV4T2YoaGFuZGxlcikgPj4+IDAsIDEpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgOyhhbGxbdHlwZV0gfHwgW10pLnNsaWNlKCkubWFwKChoYW5kbGVyOiBIYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXIoLi4uZXZ0cylcbiAgICAgIH0pXG4gICAgfSxcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5leHRSb3V0ZXI+KG51bGwgYXMgYW55KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JvdXRlckNvbnRleHQnXG59XG4iLCIvKiBnbG9iYWwgX19ORVhUX0RBVEFfXyAqL1xuLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoLFxuICByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCxcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaCdcbmltcG9ydCB7IEdvb2RQYWdlQ2FjaGUsIFN0eWxlU2hlZXRUdXBsZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9wYWdlLWxvYWRlcidcbmltcG9ydCB7XG4gIGdldENsaWVudEJ1aWxkTWFuaWZlc3QsXG4gIGlzQXNzZXRFcnJvcixcbiAgbWFya0Fzc2V0RXJyb3IsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXInXG5pbXBvcnQgeyBEb21haW5Mb2NhbGVzIH0gZnJvbSAnLi4vLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB7IGRlbm9ybWFsaXplUGFnZVBhdGggfSBmcm9tICcuLi8uLi9zZXJ2ZXIvZGVub3JtYWxpemUtcGFnZS1wYXRoJ1xuaW1wb3J0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCB9IGZyb20gJy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJ1xuaW1wb3J0IG1pdHQsIHsgTWl0dEVtaXR0ZXIgfSBmcm9tICcuLi9taXR0J1xuaW1wb3J0IHtcbiAgQXBwQ29udGV4dFR5cGUsXG4gIGZvcm1hdFdpdGhWYWxpZGF0aW9uLFxuICBnZXRMb2NhdGlvbk9yaWdpbixcbiAgZ2V0VVJMLFxuICBsb2FkR2V0SW5pdGlhbFByb3BzLFxuICBOZXh0UGFnZUNvbnRleHQsXG4gIFNULFxuICBORVhUX0RBVEEsXG59IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi91dGlscy9xdWVyeXN0cmluZydcbmltcG9ydCByZXNvbHZlUmV3cml0ZXMgZnJvbSAnLi91dGlscy9yZXNvbHZlLXJld3JpdGVzJ1xuaW1wb3J0IHsgZ2V0Um91dGVNYXRjaGVyIH0gZnJvbSAnLi91dGlscy9yb3V0ZS1tYXRjaGVyJ1xuaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vdXRpbHMvcm91dGUtcmVnZXgnXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgLyogcHJvZCAqL1xuICAgIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICB9XG59XG5cbmludGVyZmFjZSBSb3V0ZVByb3BlcnRpZXMge1xuICBzaGFsbG93OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBUcmFuc2l0aW9uT3B0aW9ucyB7XG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4gIHNjcm9sbD86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE5leHRIaXN0b3J5U3RhdGUge1xuICB1cmw6IHN0cmluZ1xuICBhczogc3RyaW5nXG4gIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zXG59XG5cbnR5cGUgSGlzdG9yeVN0YXRlID1cbiAgfCBudWxsXG4gIHwgeyBfX046IGZhbHNlIH1cbiAgfCAoeyBfX046IHRydWU7IGlkeDogbnVtYmVyIH0gJiBOZXh0SGlzdG9yeVN0YXRlKVxuXG5sZXQgZGV0ZWN0RG9tYWluTG9jYWxlOiB0eXBlb2YgaW1wb3J0KCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJykuZGV0ZWN0RG9tYWluTG9jYWxlXG5cbmlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gIGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoJy4uL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKVxuICAgIC5kZXRlY3REb21haW5Mb2NhbGVcbn1cblxuY29uc3QgYmFzZVBhdGggPSAocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCBhcyBzdHJpbmcpIHx8ICcnXG5cbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICBjYW5jZWxsZWQ6IHRydWUsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHByZWZpeCAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKVxuICAgID8gcGF0aCA9PT0gJy8nXG4gICAgICA/IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKHByZWZpeClcbiAgICAgIDogYCR7cHJlZml4fSR7cGF0aE5vUXVlcnlIYXNoKHBhdGgpID09PSAnLycgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGh9YFxuICAgIDogcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKFxuICBwYXRoOiBzdHJpbmcsXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICBsb2NhbGVzPzogc3RyaW5nW10sXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBsb2NhbGUgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZVxuXG4gICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCBsb2NhbGUpXG5cbiAgICBpZiAoZGV0ZWN0ZWREb21haW4pIHtcbiAgICAgIHJldHVybiBgaHR0cCR7ZGV0ZWN0ZWREb21haW4uaHR0cCA/ICcnIDogJ3MnfTovLyR7ZGV0ZWN0ZWREb21haW4uZG9tYWlufSR7XG4gICAgICAgIGJhc2VQYXRoIHx8ICcnXG4gICAgICB9JHtsb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHtsb2NhbGV9YH0ke3BhdGh9YFxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9jYWxlKFxuICBwYXRoOiBzdHJpbmcsXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmXG4gICAgICBsb2NhbGUgIT09IGRlZmF1bHRMb2NhbGUgJiZcbiAgICAgICFwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlICsgJy8nKSAmJlxuICAgICAgcGF0aCAhPT0gJy8nICsgbG9jYWxlXG4gICAgICA/IGFkZFBhdGhQcmVmaXgocGF0aCwgJy8nICsgbG9jYWxlKVxuICAgICAgOiBwYXRoXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbExvY2FsZShwYXRoOiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZykge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIHJldHVybiBsb2NhbGUgJiZcbiAgICAgIChwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlICsgJy8nKSB8fCBwYXRoID09PSAnLycgKyBsb2NhbGUpXG4gICAgICA/IHBhdGguc3Vic3RyKGxvY2FsZS5sZW5ndGggKyAxKSB8fCAnLydcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmZ1bmN0aW9uIHBhdGhOb1F1ZXJ5SGFzaChwYXRoOiBzdHJpbmcpIHtcbiAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpXG4gIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpXG5cbiAgaWYgKHF1ZXJ5SW5kZXggPiAtMSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4KVxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcGF0aCA9IHBhdGhOb1F1ZXJ5SGFzaChwYXRoKVxuICByZXR1cm4gcGF0aCA9PT0gYmFzZVBhdGggfHwgcGF0aC5zdGFydHNXaXRoKGJhc2VQYXRoICsgJy8nKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gd2Ugb25seSBhZGQgdGhlIGJhc2VwYXRoIG9uIHJlbGF0aXZlIHVybHNcbiAgcmV0dXJuIGFkZFBhdGhQcmVmaXgocGF0aCwgYmFzZVBhdGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBwYXRoID0gcGF0aC5zbGljZShiYXNlUGF0aC5sZW5ndGgpXG4gIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHBhdGggPSBgLyR7cGF0aH1gXG4gIHJldHVybiBwYXRoXG59XG5cbi8qKlxuICogRGV0ZWN0cyB3aGV0aGVyIGEgZ2l2ZW4gdXJsIGlzIHJvdXRhYmxlIGJ5IHRoZSBOZXh0LmpzIHJvdXRlciAoYnJvd3NlciBvbmx5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiB0cnVlXG4gIHRyeSB7XG4gICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pXG4gICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG50eXBlIFVybCA9IFVybE9iamVjdCB8IHN0cmluZ1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhcbiAgcm91dGU6IHN0cmluZyxcbiAgYXNQYXRobmFtZTogc3RyaW5nLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbikge1xuICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSAnJ1xuXG4gIGNvbnN0IGR5bmFtaWNSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzXG4gIGNvbnN0IGR5bmFtaWNNYXRjaGVzID1cbiAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gZ2V0Um91dGVNYXRjaGVyKGR5bmFtaWNSZWdleCkoYXNQYXRobmFtZSkgOiAnJykgfHxcbiAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG4gICAgcXVlcnlcblxuICBpbnRlcnBvbGF0ZWRSb3V0ZSA9IHJvdXRlXG4gIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpXG5cbiAgaWYgKFxuICAgICFwYXJhbXMuZXZlcnkoKHBhcmFtKSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgJydcbiAgICAgIGNvbnN0IHsgcmVwZWF0LCBvcHRpb25hbCB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV1cblxuICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBoYW5kbGluZyBmb3IgdXNlci1lcnJvciAocGFzc2luZyBgL2ApXG4gICAgICBsZXQgcmVwbGFjZWQgPSBgWyR7cmVwZWF0ID8gJy4uLicgOiAnJ30ke3BhcmFtfV1gXG4gICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcmVwbGFjZWQgPSBgJHshdmFsdWUgPyAnLycgOiAnJ31bJHtyZXBsYWNlZH1dYFxuICAgICAgfVxuICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmXG4gICAgICAgIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPVxuICAgICAgICAgIGludGVycG9sYXRlZFJvdXRlIS5yZXBsYWNlKFxuICAgICAgICAgICAgcmVwbGFjZWQsXG4gICAgICAgICAgICByZXBlYXRcbiAgICAgICAgICAgICAgPyAodmFsdWUgYXMgc3RyaW5nW10pXG4gICAgICAgICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGZ1bGx5IGVuY29kZWQgaW5zdGVhZCBvZiBqdXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhdGggZGVsaW1pdGVyIGVzY2FwZWQgc2luY2UgdGhleSBhcmUgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byB0aGUgVVJMIGFuZCB3ZSBleHBlY3QgVVJMIGVuY29kZWQgc2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBwYXJzaW5nIGR5bmFtaWMgcm91dGUgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIChzZWdtZW50KSA9PiBlbmNvZGVVUklDb21wb25lbnQoc2VnbWVudClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIC5qb2luKCcvJylcbiAgICAgICAgICAgICAgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUgYXMgc3RyaW5nKVxuICAgICAgICAgICkgfHwgJy8nKVxuICAgICAgKVxuICAgIH0pXG4gICkge1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gJycgLy8gZGlkIG5vdCBzYXRpc2Z5IGFsbCByZXF1aXJlbWVudHNcblxuICAgIC8vIG4uYi4gV2UgaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSB3ZSBoYW5kbGUgd2FybmluZyBmb3IgdGhpcyBjYXNlIGluXG4gICAgLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbiAgfVxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICByZXN1bHQ6IGludGVycG9sYXRlZFJvdXRlLFxuICB9XG59XG5cbmZ1bmN0aW9uIG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeTogUGFyc2VkVXJsUXVlcnksIHBhcmFtczogc3RyaW5nW10pIHtcbiAgY29uc3QgZmlsdGVyZWRRdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuXG4gIE9iamVjdC5rZXlzKHF1ZXJ5KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXBhcmFtcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBmaWx0ZXJlZFF1ZXJ5W2tleV0gPSBxdWVyeVtrZXldXG4gICAgfVxuICB9KVxuICByZXR1cm4gZmlsdGVyZWRRdWVyeVxufVxuXG4vKipcbiAqIFJlc29sdmVzIGEgZ2l2ZW4gaHlwZXJsaW5rIHdpdGggYSBjZXJ0YWluIHJvdXRlciBzdGF0ZSAoYmFzZVBhdGggbm90IGluY2x1ZGVkKS5cbiAqIFByZXNlcnZlcyBhYnNvbHV0ZSB1cmxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUhyZWYoXG4gIGN1cnJlbnRQYXRoOiBzdHJpbmcsXG4gIGhyZWY6IFVybCxcbiAgcmVzb2x2ZUFzPzogYm9vbGVhblxuKTogc3RyaW5nIHtcbiAgLy8gd2UgdXNlIGEgZHVtbXkgYmFzZSB1cmwgZm9yIHJlbGF0aXZlIHVybHNcbiAgY29uc3QgYmFzZSA9IG5ldyBVUkwoY3VycmVudFBhdGgsICdodHRwOi8vbicpXG4gIGNvbnN0IHVybEFzU3RyaW5nID1cbiAgICB0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgPyBocmVmIDogZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZilcbiAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgaWYgKCFpc0xvY2FsVVJMKHVybEFzU3RyaW5nKSkge1xuICAgIHJldHVybiAocmVzb2x2ZUFzID8gW3VybEFzU3RyaW5nXSA6IHVybEFzU3RyaW5nKSBhcyBzdHJpbmdcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSlcbiAgICBmaW5hbFVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKVxuICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9ICcnXG5cbiAgICBpZiAoXG4gICAgICBpc0R5bmFtaWNSb3V0ZShmaW5hbFVybC5wYXRobmFtZSkgJiZcbiAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJlxuICAgICAgcmVzb2x2ZUFzXG4gICAgKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSBpbnRlcnBvbGF0ZUFzKFxuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSxcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5XG4gICAgICApXG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcyksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICBjb25zdCByZXNvbHZlZEhyZWYgPVxuICAgICAgZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpblxuICAgICAgICA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aClcbiAgICAgICAgOiBmaW5hbFVybC5ocmVmXG5cbiAgICByZXR1cm4gKHJlc29sdmVBc1xuICAgICAgPyBbcmVzb2x2ZWRIcmVmLCBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZdXG4gICAgICA6IHJlc29sdmVkSHJlZikgYXMgc3RyaW5nXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuXG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybFxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM/OiBVcmwpIHtcbiAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgdXJsLCB0cnVlKVxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIGNvbnN0IGhyZWZIYWRPcmlnaW4gPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pXG4gIGNvbnN0IGFzSGFkT3JpZ2luID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKVxuXG4gIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZilcbiAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXNcblxuICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZIYWRPcmlnaW4gPyByZXNvbHZlZEhyZWYgOiBhZGRCYXNlUGF0aChyZXNvbHZlZEhyZWYpXG4gIGNvbnN0IHByZXBhcmVkQXMgPSBhc1xuICAgID8gc3RyaXBPcmlnaW4ocmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCBhcykpXG4gICAgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuXG4gIHJldHVybiB7XG4gICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICBhczogYXNIYWRPcmlnaW4gPyBwcmVwYXJlZEFzIDogYWRkQmFzZVBhdGgocHJlcGFyZWRBcyksXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQmFzZVJvdXRlciA9IHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xufVxuXG5leHBvcnQgdHlwZSBOZXh0Um91dGVyID0gQmFzZVJvdXRlciAmXG4gIFBpY2s8XG4gICAgUm91dGVyLFxuICAgIHwgJ3B1c2gnXG4gICAgfCAncmVwbGFjZSdcbiAgICB8ICdyZWxvYWQnXG4gICAgfCAnYmFjaydcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgICB8ICdpc1JlYWR5J1xuICA+XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG5cbmV4cG9ydCB0eXBlIFByaXZhdGVSb3V0ZUluZm8gPVxuICB8IChPbWl0PENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ3N0eWxlU2hlZXRzJz4gJiB7IGluaXRpYWw6IHRydWUgfSlcbiAgfCBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm9cblxuZXhwb3J0IHR5cGUgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wcyA9IFBpY2s8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdlcnInPiAmIHtcbiAgcm91dGVyOiBSb3V0ZXJcbn0gJiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5leHBvcnQgdHlwZSBBcHBDb21wb25lbnQgPSBDb21wb25lbnRUeXBlPEFwcFByb3BzPlxuXG50eXBlIFN1YnNjcmlwdGlvbiA9IChcbiAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgQXBwOiBBcHBDb21wb25lbnQsXG4gIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4pID0+IFByb21pc2U8dm9pZD5cblxudHlwZSBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrID0gKHN0YXRlOiBOZXh0SGlzdG9yeVN0YXRlKSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiZcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJlxuICAhIShmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB2ID0gJ19fbmV4dCdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlXG4gICAgfSBjYXRjaCAobikge31cbiAgfSkoKVxuXG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woJ1NTR19EQVRBX05PVF9GT1VORCcpXG5cbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsOiBzdHJpbmcsIGF0dGVtcHRzOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgLy9cbiAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgLy8gPiBvcHRpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgIC8vXG4gICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICB9KS50aGVuKChyZXMpID0+IHtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSlcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5qc29uKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChkYXRhLm5vdEZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKGRhdGFIcmVmOiBzdHJpbmcsIGlzU2VydmVyUmVuZGVyOiBib29sZWFuKSB7XG4gIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxKS5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgLy8gbG9vcC5cblxuICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgIG1hcmtBc3NldEVycm9yKGVycilcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlciBpbXBsZW1lbnRzIEJhc2VSb3V0ZXIge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcblxuICAvKipcbiAgICogTWFwIG9mIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiBgUm91dGVyYFxuICAgKi9cbiAgY29tcG9uZW50czogeyBbcGF0aG5hbWU6IHN0cmluZ106IFByaXZhdGVSb3V0ZUluZm8gfVxuICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICBzZGM6IHsgW2FzUGF0aDogc3RyaW5nXTogb2JqZWN0IH0gPSB7fVxuICBzdWI6IFN1YnNjcmlwdGlvblxuICBjbGM6IENvbXBvbmVudExvYWRDYW5jZWxcbiAgcGFnZUxvYWRlcjogYW55XG4gIF9icHM6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgfCB1bmRlZmluZWRcbiAgZXZlbnRzOiBNaXR0RW1pdHRlclxuICBfd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgaXNTc3I6IGJvb2xlYW5cbiAgaXNGYWxsYmFjazogYm9vbGVhblxuICBfaW5GbGlnaHRSb3V0ZT86IHN0cmluZ1xuICBfc2hhbGxvdz86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG4gIGlzUmVhZHk6IGJvb2xlYW5cblxuICBwcml2YXRlIF9pZHg6IG51bWJlciA9IDBcblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlciA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbG9jYWxlLFxuICAgICAgbG9jYWxlcyxcbiAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgICBkb21haW5Mb2NhbGVzLFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQXBwQ29tcG9uZW50XG4gICAgICB3cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICAgICAgZXJyPzogRXJyb3JcbiAgICAgIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgICAgIGxvY2FsZT86IHN0cmluZ1xuICAgICAgbG9jYWxlcz86IHN0cmluZ1tdXG4gICAgICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gICAgICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuICAgIH1cbiAgKSB7XG4gICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgdGhpcy5yb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgdGhpcy5jb21wb25lbnRzID0ge31cbiAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgaWYgKHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSA9IHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICBlcnIsXG4gICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgIENvbXBvbmVudDogQXBwIGFzIENvbXBvbmVudFR5cGUsXG4gICAgICBzdHlsZVNoZWV0czogW1xuICAgICAgICAvKiAvX2FwcCBkb2VzIG5vdCBuZWVkIGl0cyBzdHlsZXNoZWV0cyBtYW5hZ2VkICovXG4gICAgICBdLFxuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXJcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPVxuICAgICAgaXNEeW5hbWljUm91dGUocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0XG5cbiAgICB0aGlzLmFzUGF0aCA9IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhc1xuICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aFxuICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uXG4gICAgdGhpcy5jbGMgPSBudWxsXG4gICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHBcbiAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICB0aGlzLmlzU3NyID0gdHJ1ZVxuXG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gaXNGYWxsYmFja1xuXG4gICAgdGhpcy5pc1JlYWR5ID0gISEoXG4gICAgICBzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fFxuICAgICAgKCFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2gpXG4gICAgKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlXG4gICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzXG4gICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlXG4gICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgIGlmIChhcy5zdWJzdHIoMCwgMikgIT09ICcvLycpIHtcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgICBnZXRVUkwoKSxcbiAgICAgICAgICB7IGxvY2FsZSB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKVxuXG4gICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblBvcFN0YXRlID0gKGU6IFBvcFN0YXRlRXZlbnQpOiB2b2lkID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGUgYXMgSGlzdG9yeVN0YXRlXG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgLy9cbiAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHRoaXNcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksIHF1ZXJ5IH0pLFxuICAgICAgICBnZXRVUkwoKVxuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBmb3JjZWRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IHsgdXJsLCBhcywgb3B0aW9ucywgaWR4IH0gPSBzdGF0ZVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX2lkeCAhPT0gaWR4KSB7XG4gICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAgICdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9pZHgsXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgeDogc2VsZi5wYWdlWE9mZnNldCwgeTogc2VsZi5wYWdlWU9mZnNldCB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gY2F0Y2gge31cblxuICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIGlkeClcbiAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IEpTT04ucGFyc2UodiEpXG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7IHg6IDAsIHk6IDAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pZHggPSBpZHhcblxuICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09IHRoaXMuYXNQYXRoICYmIHBhdGhuYW1lID09PSB0aGlzLnBhdGhuYW1lKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5nZShcbiAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgdXJsLFxuICAgICAgYXMsXG4gICAgICBPYmplY3QuYXNzaWduPHt9LCBUcmFuc2l0aW9uT3B0aW9ucywgVHJhbnNpdGlvbk9wdGlvbnM+KHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgIH0pLFxuICAgICAgZm9yY2VkU2Nyb2xsXG4gICAgKVxuICB9XG5cbiAgcmVsb2FkKCk6IHZvaWQge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmw6IFVybCwgYXM/OiBVcmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9pZHgsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHJlcGxhY2UodXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNoYW5nZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyxcbiAgICBmb3JjZWRTY3JvbGw/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybCkpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICBpZiAoKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gc2Nyb2xsIHJlc2V0IGJlaGF2aW9yIHVubGVzcyBleHBsaWNpdGx5IHNwZWNpZmllZCB0byBiZVxuICAgIC8vIGBmYWxzZWAhIFRoaXMgbWFrZXMgdGhlIGJlaGF2aW9yIGJldHdlZW4gdXNpbmcgYFJvdXRlciNwdXNoYCBhbmQgYVxuICAgIC8vIGA8TGluayAvPmAgY29uc2lzdGVudC5cbiAgICBvcHRpb25zLnNjcm9sbCA9ICEhKG9wdGlvbnMuc2Nyb2xsID8/IHRydWUpXG5cbiAgICBsZXQgbG9jYWxlQ2hhbmdlID0gb3B0aW9ucy5sb2NhbGUgIT09IHRoaXMubG9jYWxlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2VcbiAgICAgICAgICA/IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgIDogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5sb2NhbGVcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSB0aGlzLmxvY2FsZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMpXG4gICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuXG4gICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGVcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXJzZWRBcy5wYXRobmFtZSlcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgoXG4gICAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgICAgIGhhc0Jhc2VQYXRoKHVybCkgPyBkZWxCYXNlUGF0aCh1cmwpIDogdXJsLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgICAgKS5wYXRobmFtZVxuICAgICAgICApXG4gICAgICB9XG4gICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICBpZiAoIXRoaXMubG9jYWxlcz8uaW5jbHVkZXModGhpcy5sb2NhbGUhKSkge1xuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZSlcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMubG9jYWxlXG4gICAgICApXG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWRpZE5hdmlnYXRlICYmXG4gICAgICAgICAgZGV0ZWN0ZWREb21haW4gJiZcbiAgICAgICAgICBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gZGVsQmFzZVBhdGgoYXMpXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgaHR0cCR7ZGV0ZWN0ZWREb21haW4uaHR0cCA/ICcnIDogJ3MnfTovLyR7XG4gICAgICAgICAgICBkZXRlY3RlZERvbWFpbi5kb21haW5cbiAgICAgICAgICB9JHthZGRCYXNlUGF0aChcbiAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICB0aGlzLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICA6IGAvJHt0aGlzLmxvY2FsZX1gXG4gICAgICAgICAgICB9JHthc05vQmFzZVBhdGggPT09ICcvJyA/ICcnIDogYXNOb0Jhc2VQYXRofWAgfHwgJy8nXG4gICAgICAgICAgKX1gXG4gICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucyBhcyBhbnkpLl9oKSB7XG4gICAgICB0aGlzLmlzU3NyID0gZmFsc2VcbiAgICB9XG4gICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgIGlmIChTVCkge1xuICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2hhbGxvdyA9IGZhbHNlIH0gPSBvcHRpb25zXG4gICAgY29uc3Qgcm91dGVQcm9wcyA9IHsgc2hhbGxvdyB9XG5cbiAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSkge1xuICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQodGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcylcbiAgICB9XG5cbiAgICBhcyA9IGFkZEJhc2VQYXRoKFxuICAgICAgYWRkTG9jYWxlKFxuICAgICAgICBoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUsXG4gICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgKVxuICAgIClcbiAgICBjb25zdCBjbGVhbmVkQXMgPSBkZWxMb2NhbGUoXG4gICAgICBoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgIHRoaXMubG9jYWxlXG4gICAgKVxuICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhc1xuXG4gICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG5cbiAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpKSB7XG4gICAgICB0aGlzLmFzUGF0aCA9IGNsZWFuZWRBc1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcbiAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcylcbiAgICAgIHRoaXMubm90aWZ5KHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSwgbnVsbClcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcbiAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFxuXG4gICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgbGV0IHBhZ2VzOiBhbnksIHJld3JpdGVzOiBhbnlcbiAgICB0cnkge1xuICAgICAgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuICAgICAgOyh7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH0gPSBhd2FpdCBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHBhcnNlZCA9IHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZCwgcGFnZXMpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGRlbEJhc2VQYXRoKHBhdGhuYW1lKSlcbiAgICAgIDogcGF0aG5hbWVcblxuICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnXG4gICAgfVxuXG4gICAgbGV0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIHJlc29sdmVkQXMgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgIGFkZEJhc2VQYXRoKFxuICAgICAgICAgIGFkZExvY2FsZShkZWxCYXNlUGF0aChwYXJzZVJlbGF0aXZlVXJsKGFzKS5wYXRobmFtZSksIHRoaXMubG9jYWxlKVxuICAgICAgICApLFxuICAgICAgICBwYWdlcyxcbiAgICAgICAgcmV3cml0ZXMsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICAocDogc3RyaW5nKSA9PiB0aGlzLl9yZXNvbHZlSHJlZih7IHBhdGhuYW1lOiBwIH0sIHBhZ2VzKS5wYXRobmFtZSEsXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuXG4gICAgICBpZiAocmVzb2x2ZWRBcyAhPT0gYXMpIHtcbiAgICAgICAgY29uc3QgcG90ZW50aWFsSHJlZiA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgICAgICAgIHRoaXMuX3Jlc29sdmVIcmVmKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkLCB7XG4gICAgICAgICAgICAgIHBhdGhuYW1lOiBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICAgICAgICAgIGhhc0Jhc2VQYXRoKHJlc29sdmVkQXMpID8gZGVsQmFzZVBhdGgocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICAgICAgICApLnBhdGhuYW1lLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKS5wYXRobmFtZSFcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHBvdGVudGlhbEhyZWYpKSB7XG4gICAgICAgICAgcm91dGUgPSBwb3RlbnRpYWxIcmVmXG4gICAgICAgICAgcGF0aG5hbWUgPSBwb3RlbnRpYWxIcmVmXG4gICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzTG9jYWxVUkwoYXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgaHJlZjogXCIke3VybH1cIiBhbmQgYXM6IFwiJHthc31cIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXNgICtcbiAgICAgICAgICAgIGBcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL2Vyci5zaC9uZXh0LmpzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmVzb2x2ZWRBcyksIHRoaXMubG9jYWxlKVxuXG4gICAgaWYgKGlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpXG4gICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWVcblxuICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gICAgICBjb25zdCByb3V0ZU1hdGNoID0gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpXG4gICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lXG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlXG4gICAgICAgID8gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpXG4gICAgICAgIDogKHt9IGFzIHsgcmVzdWx0OiB1bmRlZmluZWQ7IHBhcmFtczogdW5kZWZpbmVkIH0pXG5cbiAgICAgIGlmICghcm91dGVNYXRjaCB8fCAoc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoXG4gICAgICAgICAgKHBhcmFtKSA9PiAhcXVlcnlbcGFyYW1dXG4gICAgICAgIClcblxuICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gYEludGVycG9sYXRpbmcgaHJlZmBcbiAgICAgICAgICAgICAgICAgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYFxuICAgICAgICAgICAgICB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgK1xuICAgICAgICAgICAgICAgIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIChzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICA/IGBUaGUgcHJvdmlkZWQgXFxgaHJlZlxcYCAoJHt1cmx9KSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0pIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gYFxuICAgICAgICAgICAgICA6IGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGApICtcbiAgICAgICAgICAgICAgYFJlYWQgbW9yZTogaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyAnaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZCdcbiAgICAgICAgICAgICAgICAgIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ1xuICAgICAgICAgICAgICB9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICBhcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgcXVlcnk6IG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zISksXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcylcblxuICAgIHRyeSB7XG4gICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oXG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShyZXNvbHZlZEFzLCB0aGlzLmxvY2FsZSkpLFxuICAgICAgICByb3V0ZVByb3BzXG4gICAgICApXG4gICAgICBsZXQgeyBlcnJvciwgcHJvcHMsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgIGlmICgoX19OX1NTRyB8fCBfX05fU1NQKSAmJiBwcm9wcykge1xuICAgICAgICBpZiAoKHByb3BzIGFzIGFueSkucGFnZVByb3BzICYmIChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9IHBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWRIcmVmLCBwYWdlcywgZmFsc2UpXG5cbiAgICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwYXJzZWRIcmVmLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsLCBhczogbmV3QXMgfSA9IHByZXBhcmVVcmxBcyhcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGRlc3RpbmF0aW9uXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlXG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudCgnLzQwNCcpXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy80MDQnXG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvX2Vycm9yJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKFxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgeyBzaGFsbG93OiBmYWxzZSB9XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFwcENvbXA6IGFueSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnRcbiAgICAgICAgOyh3aW5kb3cgYXMgYW55KS5uZXh0LmlzUHJlcmVuZGVyZWQgPVxuICAgICAgICAgIGFwcENvbXAuZ2V0SW5pdGlhbFByb3BzID09PSBhcHBDb21wLm9yaWdHZXRJbml0aWFsUHJvcHMgJiZcbiAgICAgICAgICAhKHJvdXRlSW5mby5Db21wb25lbnQgYXMgYW55KS5nZXRJbml0aWFsUHJvcHNcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5zZXQoXG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXRobmFtZSEsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBjbGVhbmVkQXMsXG4gICAgICAgIHJvdXRlSW5mbyxcbiAgICAgICAgZm9yY2VkU2Nyb2xsIHx8IChvcHRpb25zLnNjcm9sbCA/IHsgeDogMCwgeTogMCB9IDogbnVsbClcbiAgICAgICkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSBlcnJvciA9IGVycm9yIHx8IGVcbiAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcylcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSB0aGlzLmxvY2FsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fVxuICApOiB2b2lkIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8IGdldFVSTCgpICE9PSBhcykge1xuICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvd1xuICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXShcbiAgICAgICAge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBhcyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICBpZHg6IHRoaXMuX2lkeCA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9pZHggOiB0aGlzLl9pZHggKyAxLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICByb3V0ZVByb3BzOiBSb3V0ZVByb3BlcnRpZXMsXG4gICAgbG9hZEVycm9yRmFpbD86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmIChpc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcblxuICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG5cbiAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsZXQgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBsZXQgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gICAgICBsZXQgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWRcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgQ29tcG9uZW50ISA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHN0eWxlU2hlZXRzISA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICA7KHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgICAnL19lcnJvcidcbiAgICAgICAgKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gICAgICAgIHByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICBlcnIsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0gYXMgYW55KVxuICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICAgICAgcm91dGVJbmZvRXJyLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Um91dGVJbmZvKFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogYW55LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzXG4gICk6IFByb21pc2U8UHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBleGlzdGluZ1JvdXRlSW5mbzogUHJpdmF0ZVJvdXRlSW5mbyB8IHVuZGVmaW5lZCA9IHRoaXMuY29tcG9uZW50c1tcbiAgICAgICAgcm91dGVcbiAgICAgIF1cbiAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdSb3V0ZUluZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhY2hlZFJvdXRlSW5mbzogQ29tcGxldGVQcml2YXRlUm91dGVJbmZvIHwgdW5kZWZpbmVkID1cbiAgICAgICAgZXhpc3RpbmdSb3V0ZUluZm8gJiYgJ2luaXRpYWwnIGluIGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICBjb25zdCByb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IGNhY2hlZFJvdXRlSW5mb1xuICAgICAgICA/IGNhY2hlZFJvdXRlSW5mb1xuICAgICAgICA6IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcykgPT4gKHtcbiAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgIH0pKVxuXG4gICAgICBjb25zdCB7IENvbXBvbmVudCwgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhSHJlZjogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgIGlmIChfX05fU1NHIHx8IF9fTl9TU1ApIHtcbiAgICAgICAgZGF0YUhyZWYgPSB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgICAgZGVsQmFzZVBhdGgoYXMpLFxuICAgICAgICAgIF9fTl9TU0csXG4gICAgICAgICAgdGhpcy5sb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wcyA9IGF3YWl0IHRoaXMuX2dldERhdGE8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvPigoKSA9PlxuICAgICAgICBfX05fU1NHXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IF9fTl9TU1BcbiAgICAgICAgICA/IHRoaXMuX2dldFNlcnZlckRhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICApXG4gICAgICApXG5cbiAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpXG4gICAgfVxuICB9XG5cbiAgc2V0KFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICAgIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlXG5cbiAgICB0aGlzLnJvdXRlID0gcm91dGVcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEsIHJlc2V0U2Nyb2xsKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBiZWZvcmVQb3BTdGF0ZShjYjogQmVmb3JlUG9wU3RhdGVDYWxsYmFjaykge1xuICAgIHRoaXMuX2JwcyA9IGNiXG4gIH1cblxuICBvbmx5QUhhc2hDaGFuZ2UoYXM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKVxuICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKVxuXG4gICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaFxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbLCBoYXNoXSA9IGFzLnNwbGl0KCcjJylcbiAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWVcbiAgICBpZiAoaGFzaCA9PT0gJycpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaClcbiAgICBpZiAoaWRFbCkge1xuICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaClbMF1cbiAgICBpZiAobmFtZUVsKSB7XG4gICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cbiAgfVxuXG4gIHVybElzTmV3KGFzUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGhcbiAgfVxuXG4gIF9yZXNvbHZlSHJlZihwYXJzZWRIcmVmOiBVcmxPYmplY3QsIHBhZ2VzOiBzdHJpbmdbXSwgYXBwbHlCYXNlUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRIcmVmXG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgICAgZGVub3JtYWxpemVQYWdlUGF0aChhcHBseUJhc2VQYXRoID8gZGVsQmFzZVBhdGgocGF0aG5hbWUhKSA6IHBhdGhuYW1lISlcbiAgICApXG5cbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lISkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzRHluYW1pY1JvdXRlKHBhZ2UpICYmXG4gICAgICAgICAgZ2V0Um91dGVSZWdleChwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUhKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gYXBwbHlCYXNlUGF0aCA/IGFkZEJhc2VQYXRoKHBhZ2UpIDogcGFnZVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXJzZWRIcmVmLnBhdGhuYW1lISlcbiAgICByZXR1cm4gcGFyc2VkSHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi9cbiAgYXN5bmMgcHJlZmV0Y2goXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXNQYXRoOiBzdHJpbmcgPSB1cmwsXG4gICAgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgbGV0IHsgcGF0aG5hbWUgfSA9IHBhcnNlZFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBub3JtYWxpemVMb2NhbGVQYXRoIShwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZVxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG5cbiAgICAgICAgbGV0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpXG4gICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoIShcbiAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgKVxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWVcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICBhc1BhdGggPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG5cbiAgICBwYXJzZWQgPSB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWQsIHBhZ2VzLCBmYWxzZSkgYXMgdHlwZW9mIHBhcnNlZFxuXG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG4gICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgfVxuXG4gICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2codXJsKS50aGVuKChpc1NzZzogYm9vbGVhbikgPT4ge1xuICAgICAgICByZXR1cm4gaXNTc2dcbiAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoXG4gICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZihcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmxvY2FsZVxuICAgICAgICAgICAgICAgICAgOiB0aGlzLmxvY2FsZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBmYWxzZVxuICAgICAgfSksXG4gICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksXG4gICAgXSlcbiAgfVxuXG4gIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPEdvb2RQYWdlQ2FjaGU+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAodGhpcy5jbGMgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfSlcblxuICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSlcblxuICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgXG4gICAgICApXG4gICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0XG4gIH1cblxuICBfZ2V0RGF0YTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9XG4gICAgdGhpcy5jbGMgPSBjYW5jZWxcbiAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICBjb25zdCBlcnI6IGFueSA9IG5ldyBFcnJvcignTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZCcpXG4gICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U3RhdGljRGF0YShkYXRhSHJlZjogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+IHtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5IH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLnNkY1tjYWNoZUtleV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGNbY2FjaGVLZXldKVxuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcikudGhlbigoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5zZGNbY2FjaGVLZXldID0gZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFNlcnZlckRhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpXG4gIH1cblxuICBnZXRJbml0aWFsUHJvcHMoXG4gICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlLFxuICAgIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddXG4gICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwIGFzIEFwcENvbXBvbmVudClcbiAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWVcbiAgICByZXR1cm4gbG9hZEdldEluaXRpYWxQcm9wczxBcHBDb250ZXh0VHlwZTxSb3V0ZXI+PihBcHAsIHtcbiAgICAgIEFwcFRyZWUsXG4gICAgICBDb21wb25lbnQsXG4gICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICBjdHgsXG4gICAgfSlcbiAgfVxuXG4gIGFib3J0Q29tcG9uZW50TG9hZChhczogc3RyaW5nLCByb3V0ZVByb3BzOiBSb3V0ZVByb3BlcnRpZXMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGMpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcbiAgICAgICAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAgICAgICBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksXG4gICAgICAgIGFzLFxuICAgICAgICByb3V0ZVByb3BzXG4gICAgICApXG4gICAgICB0aGlzLmNsYygpXG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBub3RpZnkoXG4gICAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zdWIoXG4gICAgICBkYXRhLFxuICAgICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCBhcyBBcHBDb21wb25lbnQsXG4gICAgICByZXNldFNjcm9sbFxuICAgIClcbiAgfVxufVxuIiwiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJy4vcXVlcnlzdHJpbmcnXG5cbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS9cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmo6IFVybE9iamVjdCkge1xuICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqXG4gIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCAnJ1xuICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgJydcbiAgbGV0IGhhc2ggPSB1cmxPYmouaGFzaCB8fCAnJ1xuICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgJydcbiAgbGV0IGhvc3Q6IHN0cmluZyB8IGZhbHNlID0gZmFsc2VcblxuICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgJzonKSArICdAJyA6ICcnXG5cbiAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB1cmxPYmouaG9zdFxuICB9IGVsc2UgaWYgKGhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoJzonKSA/IGBbJHtob3N0bmFtZX1dYCA6IGhvc3RuYW1lKVxuICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB1cmxPYmoucG9ydFxuICAgIH1cbiAgfVxuXG4gIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgcXVlcnkgPSBTdHJpbmcocXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhxdWVyeSBhcyBQYXJzZWRVcmxRdWVyeSkpXG4gIH1cblxuICBsZXQgc2VhcmNoID0gdXJsT2JqLnNlYXJjaCB8fCAocXVlcnkgJiYgYD8ke3F1ZXJ5fWApIHx8ICcnXG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuIiwiLy8gVHJhbnNsYXRlcyBhIGxvZ2ljYWwgcm91dGUgaW50byBpdHMgcGFnZXMgYXNzZXQgcGF0aCAocmVsYXRpdmUgZnJvbSBhIGNvbW1vbiBwcmVmaXgpXG4vLyBcImFzc2V0IHBhdGhcIiBiZWluZyBpdHMgamF2YXNjcmlwdCBmaWxlLCBkYXRhIGZpbGUsIHByZXJlbmRlcmVkIGh0bWwsLi4uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBc3NldFBhdGhGcm9tUm91dGUoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4dDogc3RyaW5nID0gJydcbik6IHN0cmluZyB7XG4gIGNvbnN0IHBhdGggPVxuICAgIHJvdXRlID09PSAnLydcbiAgICAgID8gJy9pbmRleCdcbiAgICAgIDogL15cXC9pbmRleChcXC98JCkvLnRlc3Qocm91dGUpXG4gICAgICA/IGAvaW5kZXgke3JvdXRlfWBcbiAgICAgIDogYCR7cm91dGV9YFxuICByZXR1cm4gcGF0aCArIGV4dFxufVxuIiwiLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNSb3V0ZShyb3V0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBURVNUX1JPVVRFLnRlc3Qocm91dGUpXG59XG4iLCJpbXBvcnQgeyBnZXRMb2NhdGlvbk9yaWdpbiB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vcXVlcnlzdHJpbmcnXG5cbi8qKlxuICogUGFyc2VzIHBhdGgtcmVsYXRpdmUgdXJscyAoZS5nLiBgL2hlbGxvL3dvcmxkP2Zvbz1iYXJgKS4gSWYgdXJsIGlzbid0IHBhdGgtcmVsYXRpdmVcbiAqIChlLmcuIGAuL2hlbGxvYCkgdGhlbiBhdCBsZWFzdCBiYXNlIG11c3QgYmUuXG4gKiBBYnNvbHV0ZSB1cmxzIGFyZSByZWplY3RlZCB3aXRoIG9uZSBleGNlcHRpb24sIGluIHRoZSBicm93c2VyLCBhYnNvbHV0ZSB1cmxzIHRoYXQgYXJlIG9uXG4gKiB0aGUgY3VycmVudCBvcmlnaW4gd2lsbCBiZSBwYXJzZWQgYXMgcmVsYXRpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVsYXRpdmVVcmwodXJsOiBzdHJpbmcsIGJhc2U/OiBzdHJpbmcpIHtcbiAgY29uc3QgZ2xvYmFsQmFzZSA9IG5ldyBVUkwoXG4gICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogZ2V0TG9jYXRpb25PcmlnaW4oKVxuICApXG4gIGNvbnN0IHJlc29sdmVkQmFzZSA9IGJhc2UgPyBuZXcgVVJMKGJhc2UsIGdsb2JhbEJhc2UpIDogZ2xvYmFsQmFzZVxuICBjb25zdCB7IHBhdGhuYW1lLCBzZWFyY2hQYXJhbXMsIHNlYXJjaCwgaGFzaCwgaHJlZiwgb3JpZ2luIH0gPSBuZXcgVVJMKFxuICAgIHVybCxcbiAgICByZXNvbHZlZEJhc2VcbiAgKVxuICBpZiAob3JpZ2luICE9PSBnbG9iYWxCYXNlLm9yaWdpbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YXJpYW50OiBpbnZhbGlkIHJlbGF0aXZlIFVSTCwgcm91dGVyIHJlY2VpdmVkICR7dXJsfWApXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBxdWVyeTogc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoLFxuICAgIGhyZWY6IGhyZWYuc2xpY2UoZ2xvYmFsQmFzZS5vcmlnaW4ubGVuZ3RoKSxcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgcGF0aFRvUmVnZXhwIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cCdcblxuZXhwb3J0IHsgcGF0aFRvUmVnZXhwIH1cblxuZXhwb3J0IGNvbnN0IG1hdGNoZXJPcHRpb25zOiBwYXRoVG9SZWdleHAuVG9rZW5zVG9SZWdleHBPcHRpb25zICZcbiAgcGF0aFRvUmVnZXhwLlBhcnNlT3B0aW9ucyA9IHtcbiAgc2Vuc2l0aXZlOiBmYWxzZSxcbiAgZGVsaW1pdGVyOiAnLycsXG59XG5cbmV4cG9ydCBjb25zdCBjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zOiBwYXRoVG9SZWdleHAuVG9rZW5zVG9SZWdleHBPcHRpb25zICZcbiAgcGF0aFRvUmVnZXhwLlBhcnNlT3B0aW9ucyA9IHtcbiAgLi4ubWF0Y2hlck9wdGlvbnMsXG4gIHN0cmljdDogdHJ1ZSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGN1c3RvbVJvdXRlID0gZmFsc2UpID0+IHtcbiAgcmV0dXJuIChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBrZXlzOiBwYXRoVG9SZWdleHAuS2V5W10gPSBbXVxuICAgIGNvbnN0IG1hdGNoZXJSZWdleCA9IHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoXG4gICAgICBwYXRoLFxuICAgICAga2V5cyxcbiAgICAgIGN1c3RvbVJvdXRlID8gY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9ucyA6IG1hdGNoZXJPcHRpb25zXG4gICAgKVxuICAgIGNvbnN0IG1hdGNoZXIgPSBwYXRoVG9SZWdleHAucmVnZXhwVG9GdW5jdGlvbihtYXRjaGVyUmVnZXgsIGtleXMpXG5cbiAgICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJhbXM/OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHBhdGhuYW1lID09IG51bGwgPyBmYWxzZSA6IG1hdGNoZXIocGF0aG5hbWUpXG4gICAgICBpZiAoIXJlcykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGN1c3RvbVJvdXRlKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAvLyB1bm5hbWVkIHBhcmFtcyBzaG91bGQgYmUgcmVtb3ZlZCBhcyB0aGV5XG4gICAgICAgICAgLy8gYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gdGhlIGRlc3RpbmF0aW9uXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkubmFtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSAocmVzLnBhcmFtcyBhcyBhbnkpW2tleS5uYW1lXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5wYXJhbXMsIC4uLnJlcy5wYXJhbXMgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0ICogYXMgcGF0aFRvUmVnZXhwIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cCdcblxudHlwZSBQYXJhbXMgPSB7IFtwYXJhbTogc3RyaW5nXTogYW55IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVOb25QYXRoKHZhbHVlOiBzdHJpbmcsIHBhcmFtczogUGFyYW1zKTogc3RyaW5nIHtcbiAgaWYgKCF2YWx1ZS5pbmNsdWRlcygnOicpKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJhbXMpKSB7XG4gICAgaWYgKHZhbHVlLmluY2x1ZGVzKGA6JHtrZXl9YCkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgbmV3IFJlZ0V4cChgOiR7a2V5fVxcXFwqYCwgJ2cnKSxcbiAgICAgICAgICBgOiR7a2V5fS0tRVNDQVBFRF9QQVJBTV9BU1RFUklTS1NgXG4gICAgICAgIClcbiAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgbmV3IFJlZ0V4cChgOiR7a2V5fVxcXFw/YCwgJ2cnKSxcbiAgICAgICAgICBgOiR7a2V5fS0tRVNDQVBFRF9QQVJBTV9RVUVTVElPTmBcbiAgICAgICAgKVxuICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGA6JHtrZXl9XFxcXCtgLCAnZycpLCBgOiR7a2V5fS0tRVNDQVBFRF9QQVJBTV9QTFVTYClcbiAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgbmV3IFJlZ0V4cChgOiR7a2V5fSg/IVxcXFx3KWAsICdnJyksXG4gICAgICAgICAgYC0tRVNDQVBFRF9QQVJBTV9DT0xPTiR7a2V5fWBcbiAgICAgICAgKVxuICAgIH1cbiAgfVxuICB2YWx1ZSA9IHZhbHVlXG4gICAgLnJlcGxhY2UoLyg6fFxcKnxcXD98XFwrfFxcKHxcXCl8XFx7fFxcfSkvZywgJ1xcXFwkMScpXG4gICAgLnJlcGxhY2UoLy0tRVNDQVBFRF9QQVJBTV9QTFVTL2csICcrJylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX0NPTE9OL2csICc6JylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX1FVRVNUSU9OL2csICc/JylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX0FTVEVSSVNLUy9nLCAnKicpXG5cbiAgLy8gdGhlIHZhbHVlIG5lZWRzIHRvIHN0YXJ0IHdpdGggYSBmb3J3YXJkLXNsYXNoIHRvIGJlIGNvbXBpbGVkXG4gIC8vIGNvcnJlY3RseVxuICByZXR1cm4gcGF0aFRvUmVnZXhwXG4gICAgLmNvbXBpbGUoYC8ke3ZhbHVlfWAsIHsgdmFsaWRhdGU6IGZhbHNlIH0pKHBhcmFtcylcbiAgICAuc3Vic3RyKDEpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXBhcmVEZXN0aW5hdGlvbihcbiAgZGVzdGluYXRpb246IHN0cmluZyxcbiAgcGFyYW1zOiBQYXJhbXMsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgYXBwZW5kUGFyYW1zVG9RdWVyeTogYm9vbGVhblxuKSB7XG4gIGxldCBwYXJzZWREZXN0aW5hdGlvbjoge1xuICAgIHF1ZXJ5PzogUGFyc2VkVXJsUXVlcnlcbiAgICBwcm90b2NvbD86IHN0cmluZ1xuICAgIGhvc3RuYW1lPzogc3RyaW5nXG4gICAgcG9ydD86IHN0cmluZ1xuICB9ICYgUmV0dXJuVHlwZTx0eXBlb2YgcGFyc2VSZWxhdGl2ZVVybD4gPSB7fSBhcyBhbnlcblxuICAvLyBjbG9uZSBxdWVyeSBzbyB3ZSBkb24ndCBtb2RpZnkgdGhlIG9yaWdpbmFsXG4gIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcXVlcnkpXG4gIGNvbnN0IGhhZExvY2FsZSA9IHF1ZXJ5Ll9fbmV4dExvY2FsZVxuICBkZWxldGUgcXVlcnkuX19uZXh0TG9jYWxlXG4gIGRlbGV0ZSBxdWVyeS5fX25leHREZWZhdWx0TG9jYWxlXG5cbiAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIHBhcnNlZERlc3RpbmF0aW9uID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaFBhcmFtcyxcbiAgICAgIGhhc2gsXG4gICAgICBob3N0bmFtZSxcbiAgICAgIHBvcnQsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhyZWYsXG4gICAgfSA9IG5ldyBVUkwoZGVzdGluYXRpb24pXG5cbiAgICBwYXJzZWREZXN0aW5hdGlvbiA9IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICAgIGhhc2gsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcG9ydCxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhyZWYsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGVzdFF1ZXJ5ID0gcGFyc2VkRGVzdGluYXRpb24ucXVlcnlcbiAgY29uc3QgZGVzdFBhdGggPSBgJHtwYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSF9JHtcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5oYXNoIHx8ICcnXG4gIH1gXG4gIGNvbnN0IGRlc3RQYXRoUGFyYW1LZXlzOiBwYXRoVG9SZWdleHAuS2V5W10gPSBbXVxuICBwYXRoVG9SZWdleHAucGF0aFRvUmVnZXhwKGRlc3RQYXRoLCBkZXN0UGF0aFBhcmFtS2V5cylcblxuICBjb25zdCBkZXN0UGF0aFBhcmFtcyA9IGRlc3RQYXRoUGFyYW1LZXlzLm1hcCgoa2V5KSA9PiBrZXkubmFtZSlcblxuICBsZXQgZGVzdGluYXRpb25Db21waWxlciA9IHBhdGhUb1JlZ2V4cC5jb21waWxlKFxuICAgIGRlc3RQYXRoLFxuICAgIC8vIHdlIGRvbid0IHZhbGlkYXRlIHdoaWxlIGNvbXBpbGluZyB0aGUgZGVzdGluYXRpb24gc2luY2Ugd2Ugc2hvdWxkXG4gICAgLy8gaGF2ZSBhbHJlYWR5IHZhbGlkYXRlZCBiZWZvcmUgd2UgZ290IHRvIHRoaXMgcG9pbnQgYW5kIHZhbGlkYXRpbmdcbiAgICAvLyBicmVha3MgY29tcGlsaW5nIGRlc3RpbmF0aW9ucyB3aXRoIG5hbWVkIHBhdHRlcm4gcGFyYW1zIGZyb20gdGhlIHNvdXJjZVxuICAgIC8vIGUuZy4gL3NvbWV0aGluZzpoZWxsbyguKikgLT4gL2Fub3RoZXIvOmhlbGxvIGlzIGJyb2tlbiB3aXRoIHZhbGlkYXRpb25cbiAgICAvLyBzaW5jZSBjb21waWxlIHZhbGlkYXRpb24gaXMgbWVhbnQgZm9yIHJldmVyc2luZyBhbmQgbm90IGZvciBpbnNlcnRpbmdcbiAgICAvLyBwYXJhbXMgZnJvbSBhIHNlcGFyYXRlIHBhdGgtcmVnZXggaW50byBhbm90aGVyXG4gICAgeyB2YWxpZGF0ZTogZmFsc2UgfVxuICApXG4gIGxldCBuZXdVcmxcblxuICAvLyB1cGRhdGUgYW55IHBhcmFtcyBpbiBxdWVyeSB2YWx1ZXNcbiAgZm9yIChjb25zdCBba2V5LCBzdHJPckFycmF5XSBvZiBPYmplY3QuZW50cmllcyhkZXN0UXVlcnkpKSB7XG4gICAgbGV0IHZhbHVlID0gQXJyYXkuaXNBcnJheShzdHJPckFycmF5KSA/IHN0ck9yQXJyYXlbMF0gOiBzdHJPckFycmF5XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAvLyB0aGUgdmFsdWUgbmVlZHMgdG8gc3RhcnQgd2l0aCBhIGZvcndhcmQtc2xhc2ggdG8gYmUgY29tcGlsZWRcbiAgICAgIC8vIGNvcnJlY3RseVxuICAgICAgdmFsdWUgPSBjb21waWxlTm9uUGF0aCh2YWx1ZSwgcGFyYW1zKVxuICAgIH1cbiAgICBkZXN0UXVlcnlba2V5XSA9IHZhbHVlXG4gIH1cblxuICAvLyBhZGQgcGF0aCBwYXJhbXMgdG8gcXVlcnkgaWYgaXQncyBub3QgYSByZWRpcmVjdCBhbmQgbm90XG4gIC8vIGFscmVhZHkgZGVmaW5lZCBpbiBkZXN0aW5hdGlvbiBxdWVyeSBvciBwYXRoXG4gIGxldCBwYXJhbUtleXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpXG5cbiAgLy8gcmVtb3ZlIGludGVybmFsIHBhcmFtIGZvciBpMThuXG4gIGlmIChoYWRMb2NhbGUpIHtcbiAgICBwYXJhbUtleXMgPSBwYXJhbUtleXMuZmlsdGVyKChuYW1lKSA9PiBuYW1lICE9PSAnbmV4dEludGVybmFsTG9jYWxlJylcbiAgfVxuXG4gIGlmIChcbiAgICBhcHBlbmRQYXJhbXNUb1F1ZXJ5ICYmXG4gICAgIXBhcmFtS2V5cy5zb21lKChrZXkpID0+IGRlc3RQYXRoUGFyYW1zLmluY2x1ZGVzKGtleSkpXG4gICkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcmFtS2V5cykge1xuICAgICAgaWYgKCEoa2V5IGluIGRlc3RRdWVyeSkpIHtcbiAgICAgICAgZGVzdFF1ZXJ5W2tleV0gPSBwYXJhbXNba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgbmV3VXJsID0gZGVzdGluYXRpb25Db21waWxlcihwYXJhbXMpXG5cbiAgICBjb25zdCBbcGF0aG5hbWUsIGhhc2hdID0gbmV3VXJsLnNwbGl0KCcjJylcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgcGFyc2VkRGVzdGluYXRpb24uaGFzaCA9IGAke2hhc2ggPyAnIycgOiAnJ30ke2hhc2ggfHwgJyd9YFxuICAgIGRlbGV0ZSAocGFyc2VkRGVzdGluYXRpb24gYXMgYW55KS5zZWFyY2hcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLm1hdGNoKC9FeHBlY3RlZCAuKj8gdG8gbm90IHJlcGVhdCwgYnV0IGdvdCBhbiBhcnJheS8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUbyB1c2UgYSBtdWx0aS1tYXRjaCBpbiB0aGUgZGVzdGluYXRpb24geW91IG11c3QgYWRkIFxcYCpcXGAgYXQgdGhlIGVuZCBvZiB0aGUgcGFyYW0gbmFtZSB0byBzaWduaWZ5IGl0IHNob3VsZCByZXBlYXQuIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2ludmFsaWQtbXVsdGktbWF0Y2hgXG4gICAgICApXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gUXVlcnkgbWVyZ2Ugb3JkZXIgbG93ZXN0IHByaW9yaXR5IHRvIGhpZ2hlc3RcbiAgLy8gMS4gaW5pdGlhbCBVUkwgcXVlcnkgdmFsdWVzXG4gIC8vIDIuIHBhdGggc2VnbWVudCB2YWx1ZXNcbiAgLy8gMy4gZGVzdGluYXRpb24gc3BlY2lmaWVkIHF1ZXJ5IHZhbHVlc1xuICBwYXJzZWREZXN0aW5hdGlvbi5xdWVyeSA9IHtcbiAgICAuLi5xdWVyeSxcbiAgICAuLi5wYXJzZWREZXN0aW5hdGlvbi5xdWVyeSxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmV3VXJsLFxuICAgIHBhcnNlZERlc3RpbmF0aW9uLFxuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShcbiAgc2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNcbik6IFBhcnNlZFVybFF1ZXJ5IHtcbiAgY29uc3QgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cbiAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBxdWVyeVtrZXldID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlba2V5XSkpIHtcbiAgICAgIDsocXVlcnlba2V5XSBhcyBzdHJpbmdbXSkucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlba2V5XSA9IFtxdWVyeVtrZXldIGFzIHN0cmluZywgdmFsdWVdXG4gICAgfVxuICB9KVxuICByZXR1cm4gcXVlcnlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShwYXJhbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycgfHxcbiAgICAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocGFyYW0pKSB8fFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ2Jvb2xlYW4nXG4gICkge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW0pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMoXG4gIHVybFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIE9iamVjdC5lbnRyaWVzKHVybFF1ZXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHJlc3VsdC5hcHBlbmQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKGl0ZW0pKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnNldChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0odmFsdWUpKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKFxuICB0YXJnZXQ6IFVSTFNlYXJjaFBhcmFtcyxcbiAgLi4uc2VhcmNoUGFyYW1zTGlzdDogVVJMU2VhcmNoUGFyYW1zW11cbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIHNlYXJjaFBhcmFtc0xpc3QuZm9yRWFjaCgoc2VhcmNoUGFyYW1zKSA9PiB7XG4gICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpID0+IHRhcmdldC5kZWxldGUoa2V5KSlcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKSlcbiAgfSlcbiAgcmV0dXJuIHRhcmdldFxufVxuIiwiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCBwYXRoTWF0Y2ggZnJvbSAnLi9wYXRoLW1hdGNoJ1xuaW1wb3J0IHByZXBhcmVEZXN0aW5hdGlvbiBmcm9tICcuL3ByZXBhcmUtZGVzdGluYXRpb24nXG5pbXBvcnQgeyBSZXdyaXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL2xvYWQtY3VzdG9tLXJvdXRlcydcbmltcG9ydCB7IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoIH0gZnJvbSAnLi4vLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaCdcbmltcG9ydCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggfSBmcm9tICcuLi8uLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCdcblxuY29uc3QgY3VzdG9tUm91dGVNYXRjaGVyID0gcGF0aE1hdGNoKHRydWUpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc29sdmVSZXdyaXRlcyhcbiAgYXNQYXRoOiBzdHJpbmcsXG4gIHBhZ2VzOiBzdHJpbmdbXSxcbiAgcmV3cml0ZXM6IFJld3JpdGVbXSxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICByZXNvbHZlSHJlZjogKHBhdGg6IHN0cmluZykgPT4gc3RyaW5nLFxuICBsb2NhbGVzPzogc3RyaW5nW11cbikge1xuICBpZiAoIXBhZ2VzLmluY2x1ZGVzKG5vcm1hbGl6ZUxvY2FsZVBhdGgoYXNQYXRoLCBsb2NhbGVzKS5wYXRobmFtZSkpIHtcbiAgICBmb3IgKGNvbnN0IHJld3JpdGUgb2YgcmV3cml0ZXMpIHtcbiAgICAgIGNvbnN0IG1hdGNoZXIgPSBjdXN0b21Sb3V0ZU1hdGNoZXIocmV3cml0ZS5zb3VyY2UpXG4gICAgICBjb25zdCBwYXJhbXMgPSBtYXRjaGVyKGFzUGF0aClcblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBpZiAoIXJld3JpdGUuZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgcHJveGllZCByZXdyaXRlIHdoaWNoIGlzbid0IGhhbmRsZWQgb24gdGhlIGNsaWVudFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzdFJlcyA9IHByZXBhcmVEZXN0aW5hdGlvbihcbiAgICAgICAgICByZXdyaXRlLmRlc3RpbmF0aW9uLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgICAgYXNQYXRoID0gZGVzdFJlcy5wYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSFcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgZGVzdFJlcy5wYXJzZWREZXN0aW5hdGlvbi5xdWVyeSlcblxuICAgICAgICBjb25zdCBmc1BhdGhuYW1lID0gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgICByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChhc1BhdGgpLFxuICAgICAgICAgIGxvY2FsZXNcbiAgICAgICAgKS5wYXRobmFtZVxuXG4gICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgIGFzUGF0aCA9IGZzUGF0aG5hbWVcbiAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBub3cgbWF0Y2ggYSBwYWdlIGFzIHRoaXMgbWVhbnMgd2UgYXJlIGRvbmVcbiAgICAgICAgICAvLyByZXNvbHZpbmcgdGhlIHJld3JpdGVzXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG1hdGNoIGEgZHluYW1pYy1yb3V0ZSwgaWYgc28gd2UgYnJlYWsgdGhlIHJld3JpdGVzIGNoYWluXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IHJlc29sdmVIcmVmKGZzUGF0aG5hbWUpXG5cbiAgICAgICAgaWYgKHJlc29sdmVkSHJlZiAhPT0gYXNQYXRoICYmIHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICBhc1BhdGggPSBmc1BhdGhuYW1lXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXNQYXRoXG59XG4iLCJpbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi9yb3V0ZS1yZWdleCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4OiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRSb3V0ZVJlZ2V4Pikge1xuICBjb25zdCB7IHJlLCBncm91cHMgfSA9IHJvdXRlUmVnZXhcbiAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lISlcbiAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGRlY29kZSA9IChwYXJhbTogc3RyaW5nKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBjb25zdCBlcnI6IEVycm9yICYgeyBjb2RlPzogc3RyaW5nIH0gPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ZhaWxlZCB0byBkZWNvZGUgcGFyYW0nXG4gICAgICAgIClcbiAgICAgICAgZXJyLmNvZGUgPSAnREVDT0RFX0ZBSUxFRCdcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtczogeyBbcGFyYW1OYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXSB9ID0ge31cblxuICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgZyA9IGdyb3Vwc1tzbHVnTmFtZV1cbiAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXVxuICAgICAgaWYgKG0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZignLycpXG4gICAgICAgICAgPyBtLnNwbGl0KCcvJykubWFwKChlbnRyeSkgPT4gZGVjb2RlKGVudHJ5KSlcbiAgICAgICAgICA6IGcucmVwZWF0XG4gICAgICAgICAgPyBbZGVjb2RlKG0pXVxuICAgICAgICAgIDogZGVjb2RlKG0pXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgR3JvdXAge1xuICBwb3M6IG51bWJlclxuICByZXBlYXQ6IGJvb2xlYW5cbiAgb3B0aW9uYWw6IGJvb2xlYW5cbn1cblxuLy8gdGhpcyBpc24ndCBpbXBvcnRpbmcgdGhlIGVzY2FwZS1zdHJpbmctcmVnZXggbW9kdWxlXG4vLyB0byByZWR1Y2UgYnl0ZXNcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIocGFyYW06IHN0cmluZykge1xuICBjb25zdCBvcHRpb25hbCA9IHBhcmFtLnN0YXJ0c1dpdGgoJ1snKSAmJiBwYXJhbS5lbmRzV2l0aCgnXScpXG4gIGlmIChvcHRpb25hbCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpXG4gIH1cbiAgY29uc3QgcmVwZWF0ID0gcGFyYW0uc3RhcnRzV2l0aCgnLi4uJylcbiAgaWYgKHJlcGVhdCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMylcbiAgfVxuICByZXR1cm4geyBrZXk6IHBhcmFtLCByZXBlYXQsIG9wdGlvbmFsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlUmVnZXgoXG4gIG5vcm1hbGl6ZWRSb3V0ZTogc3RyaW5nXG4pOiB7XG4gIHJlOiBSZWdFeHBcbiAgbmFtZWRSZWdleD86IHN0cmluZ1xuICByb3V0ZUtleXM/OiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH1cbiAgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH1cbn0ge1xuICBjb25zdCBzZWdtZW50cyA9IChub3JtYWxpemVkUm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLycpXG4gICAgLnNsaWNlKDEpXG4gICAgLnNwbGl0KCcvJylcblxuICBjb25zdCBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogR3JvdXAgfSA9IHt9XG4gIGxldCBncm91cEluZGV4ID0gMVxuICBjb25zdCBwYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICBncm91cHNba2V5XSA9IHsgcG9zOiBncm91cEluZGV4KyssIHJlcGVhdCwgb3B0aW9uYWwgfVxuICAgICAgICByZXR1cm4gcmVwZWF0ID8gKG9wdGlvbmFsID8gJyg/Oi8oLis/KSk/JyA6ICcvKC4rPyknKSA6ICcvKFteL10rPyknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYC8ke2VzY2FwZVJlZ2V4KHNlZ21lbnQpfWBcbiAgICAgIH1cbiAgICB9KVxuICAgIC5qb2luKCcnKVxuXG4gIC8vIGRlYWQgY29kZSBlbGltaW5hdGUgZm9yIGJyb3dzZXIgc2luY2UgaXQncyBvbmx5IG5lZWRlZFxuICAvLyB3aGlsZSBnZW5lcmF0aW5nIHJvdXRlcy1tYW5pZmVzdFxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgcm91dGVLZXlDaGFyQ29kZSA9IDk3XG4gICAgbGV0IHJvdXRlS2V5Q2hhckxlbmd0aCA9IDFcblxuICAgIC8vIGJ1aWxkcyBhIG1pbmltYWwgcm91dGVLZXkgdXNpbmcgb25seSBhLXogYW5kIG1pbmltYWwgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICBjb25zdCBnZXRTYWZlUm91dGVLZXkgPSAoKSA9PiB7XG4gICAgICBsZXQgcm91dGVLZXkgPSAnJ1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlS2V5Q2hhckxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdXRlS2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocm91dGVLZXlDaGFyQ29kZSlcbiAgICAgICAgcm91dGVLZXlDaGFyQ29kZSsrXG5cbiAgICAgICAgaWYgKHJvdXRlS2V5Q2hhckNvZGUgPiAxMjIpIHtcbiAgICAgICAgICByb3V0ZUtleUNoYXJMZW5ndGgrK1xuICAgICAgICAgIHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVLZXlcbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZUtleXM6IHsgW25hbWVkOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG5cbiAgICBsZXQgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgICAgLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICAgIC8vIHJlcGxhY2UgYW55IG5vbi13b3JkIGNoYXJhY3RlcnMgc2luY2UgdGhleSBjYW4gYnJlYWtcbiAgICAgICAgICAvLyB0aGUgbmFtZWQgcmVnZXhcbiAgICAgICAgICBsZXQgY2xlYW5lZEtleSA9IGtleS5yZXBsYWNlKC9cXFcvZywgJycpXG4gICAgICAgICAgbGV0IGludmFsaWRLZXkgPSBmYWxzZVxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGtleSBpcyBzdGlsbCBpbnZhbGlkIGFuZCBmYWxsYmFjayB0byB1c2luZyBhIGtub3duXG4gICAgICAgICAgLy8gc2FmZSBrZXlcbiAgICAgICAgICBpZiAoY2xlYW5lZEtleS5sZW5ndGggPT09IDAgfHwgY2xlYW5lZEtleS5sZW5ndGggPiAzMCkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludChjbGVhbmVkS2V5LnN1YnN0cigwLCAxKSkpKSB7XG4gICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnZhbGlkS2V5KSB7XG4gICAgICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXlcbiAgICAgICAgICByZXR1cm4gcmVwZWF0XG4gICAgICAgICAgICA/IG9wdGlvbmFsXG4gICAgICAgICAgICAgID8gYCg/Oi8oPzwke2NsZWFuZWRLZXl9Pi4rPykpP2BcbiAgICAgICAgICAgICAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+Lis/KWBcbiAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9PlteL10rPylgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuam9pbignJylcblxuICAgIHJldHVybiB7XG4gICAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICAgIGdyb3VwcyxcbiAgICAgIHJvdXRlS2V5cyxcbiAgICAgIG5hbWVkUmVnZXg6IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgIGdyb3VwcyxcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5cbnR5cGUgU3RhdGUgPSBKU1guRWxlbWVudFtdIHwgdW5kZWZpbmVkXG5cbnR5cGUgU2lkZUVmZmVjdFByb3BzID0ge1xuICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogPFQ+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBoZWFkTWFuYWdlcjogYW55XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQ8U2lkZUVmZmVjdFByb3BzPiB7XG4gIHByaXZhdGUgX2hhc0hlYWRNYW5hZ2VyOiBib29sZWFuXG5cbiAgZW1pdENoYW5nZSA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAodGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIudXBkYXRlSGVhZChcbiAgICAgICAgdGhpcy5wcm9wcy5yZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShcbiAgICAgICAgICBbLi4udGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzXSxcbiAgICAgICAgICB0aGlzLnByb3BzXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wczogYW55KSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5faGFzSGVhZE1hbmFnZXIgPVxuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlciAmJiB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXNcblxuICAgIGlmIChpc1NlcnZlciAmJiB0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKVxuICAgICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMuYWRkKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMuZGVsZXRlKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgZm9ybWF0VXJsIH0gZnJvbSAnLi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCdcbmltcG9ydCB7IE1hbmlmZXN0SXRlbSB9IGZyb20gJy4uL3NlcnZlci9sb2FkLWNvbXBvbmVudHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHsgQnVpbGRNYW5pZmVzdCB9IGZyb20gJy4uL3NlcnZlci9nZXQtcGFnZS1maWxlcydcbmltcG9ydCB7IERvbWFpbkxvY2FsZXMgfSBmcm9tICcuLi9zZXJ2ZXIvY29uZmlnJ1xuXG4vKipcbiAqIFR5cGVzIHVzZWQgYnkgYm90aCBuZXh0IGFuZCBuZXh0LXNlcnZlclxuICovXG5cbmV4cG9ydCB0eXBlIE5leHRDb21wb25lbnRUeXBlPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPiA9IENvbXBvbmVudFR5cGU8UD4gJiB7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBpbml0aWFsIHBhZ2UgbG9hZCBkYXRhIHBvcHVsYXRpb24uIERhdGEgcmV0dXJuZWQgZnJvbSBgZ2V0SW5pdGlhbFByb3BzYCBpcyBzZXJpYWxpemVkIHdoZW4gc2VydmVyIHJlbmRlcmVkLlxuICAgKiBNYWtlIHN1cmUgdG8gcmV0dXJuIHBsYWluIGBPYmplY3RgIHdpdGhvdXQgdXNpbmcgYERhdGVgLCBgTWFwYCwgYFNldGAuXG4gICAqIEBwYXJhbSBjdHggQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQyk6IElQIHwgUHJvbWlzZTxJUD5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIERvY3VtZW50Q29udGV4dCxcbiAgRG9jdW1lbnRJbml0aWFsUHJvcHMsXG4gIERvY3VtZW50UHJvcHNcbj4gJiB7XG4gIHJlbmRlckRvY3VtZW50KFxuICAgIERvY3VtZW50OiBEb2N1bWVudFR5cGUsXG4gICAgcHJvcHM6IERvY3VtZW50UHJvcHNcbiAgKTogUmVhY3QuUmVhY3RFbGVtZW50XG59XG5cbmV4cG9ydCB0eXBlIEFwcFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIEFwcEluaXRpYWxQcm9wcyxcbiAgQXBwUHJvcHNUeXBlXG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dFdlYlZpdGFsc01ldHJpYyA9IHtcbiAgaWQ6IHN0cmluZ1xuICBsYWJlbDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBzdGFydFRpbWU6IG51bWJlclxuICB2YWx1ZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIEVuaGFuY2VyPEM+ID0gKENvbXBvbmVudDogQykgPT4gQ1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRzRW5oYW5jZXIgPVxuICB8IHtcbiAgICAgIGVuaGFuY2VBcHA/OiBFbmhhbmNlcjxBcHBUeXBlPlxuICAgICAgZW5oYW5jZUNvbXBvbmVudD86IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuICAgIH1cbiAgfCBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZVJlc3VsdCA9IHtcbiAgaHRtbDogc3RyaW5nXG4gIGhlYWQ/OiBBcnJheTxKU1guRWxlbWVudCB8IG51bGw+XG59XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2UgPSAoXG4gIG9wdGlvbnM/OiBDb21wb25lbnRzRW5oYW5jZXJcbikgPT4gUmVuZGVyUGFnZVJlc3VsdCB8IFByb21pc2U8UmVuZGVyUGFnZVJlc3VsdD5cblxuZXhwb3J0IHR5cGUgQmFzZUNvbnRleHQgPSB7XG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIFtrOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgTkVYVF9EQVRBID0ge1xuICBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PlxuICBwYWdlOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGJ1aWxkSWQ6IHN0cmluZ1xuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBydW50aW1lQ29uZmlnPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBuZXh0RXhwb3J0PzogYm9vbGVhblxuICBhdXRvRXhwb3J0PzogYm9vbGVhblxuICBpc0ZhbGxiYWNrPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogc3RyaW5nW11cbiAgZXJyPzogRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfVxuICBnc3A/OiBib29sZWFuXG4gIGdzc3A/OiBib29sZWFuXG4gIGN1c3RvbVNlcnZlcj86IGJvb2xlYW5cbiAgZ2lwPzogYm9vbGVhblxuICBhcHBHaXA/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xufVxuXG4vKipcbiAqIGBOZXh0YCBjb250ZXh0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFBhZ2VDb250ZXh0IHtcbiAgLyoqXG4gICAqIEVycm9yIG9iamVjdCBpZiBlbmNvdW50ZXJlZCBkdXJpbmcgcmVuZGVyaW5nXG4gICAqL1xuICBlcnI/OiAoRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfSkgfCBudWxsXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICByZXE/OiBJbmNvbWluZ01lc3NhZ2VcbiAgLyoqXG4gICAqIGBIVFRQYCByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICAvKipcbiAgICogUGF0aCBzZWN0aW9uIG9mIGBVUkxgLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZ1xuICAvKipcbiAgICogUXVlcnkgc3RyaW5nIHNlY3Rpb24gb2YgYFVSTGAgcGFyc2VkIGFzIGFuIG9iamVjdC5cbiAgICovXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAvKipcbiAgICogYFN0cmluZ2Agb2YgdGhlIGFjdHVhbCBwYXRoIGluY2x1ZGluZyBxdWVyeS5cbiAgICovXG4gIGFzUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogYENvbXBvbmVudGAgdGhlIHRyZWUgb2YgdGhlIEFwcCB0byB1c2UgaWYgbmVlZGluZyB0byByZW5kZXIgc2VwYXJhdGVseVxuICAgKi9cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbn1cblxuZXhwb3J0IHR5cGUgQXBwQ29udGV4dFR5cGU8UiBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyPiA9IHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQ+XG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG4gIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gIHJvdXRlcjogUlxufVxuXG5leHBvcnQgdHlwZSBBcHBJbml0aWFsUHJvcHMgPSB7XG4gIHBhZ2VQcm9wczogYW55XG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzVHlwZTxcbiAgUiBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyLFxuICBQID0ge31cbj4gPSBBcHBJbml0aWFsUHJvcHMgJiB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0LCBhbnksIFA+XG4gIHJvdXRlcjogUlxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudENvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQgJiB7XG4gIHJlbmRlclBhZ2U6IFJlbmRlclBhZ2Vcbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRJbml0aWFsUHJvcHMgPSBSZW5kZXJQYWdlUmVzdWx0ICYge1xuICBzdHlsZXM/OiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB8IFJlYWN0LlJlYWN0RnJhZ21lbnRcbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRQcm9wcyA9IERvY3VtZW50SW5pdGlhbFByb3BzICYge1xuICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgZGFuZ2Vyb3VzQXNQYXRoOiBzdHJpbmdcbiAgZG9jQ29tcG9uZW50c1JlbmRlcmVkOiB7XG4gICAgSHRtbD86IGJvb2xlYW5cbiAgICBNYWluPzogYm9vbGVhblxuICAgIEhlYWQ/OiBib29sZWFuXG4gICAgTmV4dFNjcmlwdD86IGJvb2xlYW5cbiAgfVxuICBidWlsZE1hbmlmZXN0OiBCdWlsZE1hbmlmZXN0XG4gIGFtcFBhdGg6IHN0cmluZ1xuICBpbkFtcE1vZGU6IGJvb2xlYW5cbiAgaHlicmlkQW1wOiBib29sZWFuXG4gIGlzRGV2ZWxvcG1lbnQ6IGJvb2xlYW5cbiAgZHluYW1pY0ltcG9ydHM6IE1hbmlmZXN0SXRlbVtdXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIGNhbm9uaWNhbEJhc2U6IHN0cmluZ1xuICBoZWFkVGFnczogYW55W11cbiAgdW5zdGFibGVfcnVudGltZUpTPzogZmFsc2VcbiAgZGV2T25seUNhY2hlQnVzdGVyUXVlcnlTdHJpbmc6IHN0cmluZ1xuICBzY3JpcHRMb2FkZXI6IHsgZGVmZXI/OiBzdHJpbmdbXTsgZWFnZXI/OiBhbnlbXSB9XG4gIGxvY2FsZT86IHN0cmluZ1xufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRBcGlSZXF1ZXN0IGV4dGVuZHMgSW5jb21pbmdNZXNzYWdlIHtcbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgcXVlcnlgIHZhbHVlcyBmcm9tIHVybFxuICAgKi9cbiAgcXVlcnk6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYGNvb2tpZXNgIGZyb20gaGVhZGVyXG4gICAqL1xuICBjb29raWVzOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cblxuICBib2R5OiBhbnlcblxuICBlbnY6IEVudlxuXG4gIHByZXZpZXc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQcmV2aWV3IGRhdGEgc2V0IG9uIHRoZSByZXF1ZXN0LCBpZiBhbnlcbiAgICogKi9cbiAgcHJldmlld0RhdGE/OiBhbnlcbn1cblxuLyoqXG4gKiBTZW5kIGJvZHkgb2YgcmVzcG9uc2VcbiAqL1xudHlwZSBTZW5kPFQ+ID0gKGJvZHk6IFQpID0+IHZvaWRcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlSZXNwb25zZTxUID0gYW55PiA9IFNlcnZlclJlc3BvbnNlICYge1xuICAvKipcbiAgICogU2VuZCBkYXRhIGBhbnlgIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIHNlbmQ6IFNlbmQ8VD5cbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBganNvbmAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAganNvbjogU2VuZDxUPlxuICBzdGF0dXM6IChzdGF0dXNDb2RlOiBudW1iZXIpID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdCh1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdChzdGF0dXM6IG51bWJlciwgdXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIGNsZWFyUHJldmlld0RhdGE6ICgpID0+IE5leHRBcGlSZXNwb25zZTxUPlxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgaGFuZGxlclxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpSGFuZGxlcjxUID0gYW55PiA9IChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8VD5cbikgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cblxuLyoqXG4gKiBVdGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY09uY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUmV0dXJuVHlwZTxUPj4oXG4gIGZuOiBUXG4pOiBUIHtcbiAgbGV0IHVzZWQgPSBmYWxzZVxuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPFQ+XG5cbiAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgIHVzZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBmbiguLi5hcmdzKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uXG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb25cbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lPFA+KENvbXBvbmVudDogQ29tcG9uZW50VHlwZTxQPikge1xuICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICA/IENvbXBvbmVudFxuICAgIDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNTZW50KHJlczogU2VydmVyUmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlcy5maW5pc2hlZCB8fCByZXMuaGVhZGVyc1NlbnRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRHZXRJbml0aWFsUHJvcHM8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAnYXV0aCcsXG4gICdoYXNoJyxcbiAgJ2hvc3QnLFxuICAnaG9zdG5hbWUnLFxuICAnaHJlZicsXG4gICdwYXRoJyxcbiAgJ3BhdGhuYW1lJyxcbiAgJ3BvcnQnLFxuICAncHJvdG9jb2wnLFxuICAncXVlcnknLFxuICAnc2VhcmNoJyxcbiAgJ3NsYXNoZXMnLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24odXJsOiBVcmxPYmplY3QpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAodXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybClcbn1cblxuZXhwb3J0IGNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJ1xuZXhwb3J0IGNvbnN0IFNUID1cbiAgU1AgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbidcbiIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMubm9ybWFsaXplUGF0aFNlcD1ub3JtYWxpemVQYXRoU2VwO2V4cG9ydHMuZGVub3JtYWxpemVQYWdlUGF0aD1kZW5vcm1hbGl6ZVBhZ2VQYXRoO2Z1bmN0aW9uIG5vcm1hbGl6ZVBhdGhTZXAocGF0aCl7cmV0dXJuIHBhdGgucmVwbGFjZSgvXFxcXC9nLCcvJyk7fWZ1bmN0aW9uIGRlbm9ybWFsaXplUGFnZVBhdGgocGFnZSl7cGFnZT1ub3JtYWxpemVQYXRoU2VwKHBhZ2UpO2lmKHBhZ2Uuc3RhcnRzV2l0aCgnL2luZGV4LycpKXtwYWdlPXBhZ2Uuc2xpY2UoNik7fWVsc2UgaWYocGFnZT09PScvaW5kZXgnKXtwYWdlPScvJzt9cmV0dXJuIHBhZ2U7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L25leHQtc2VydmVyL2xpYi9oZWFkJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9saW5rJylcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjFcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xuICB9KSgpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjFcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjEnO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDB4ZWFjYztcbmV4cG9ydHMuUHJvZmlsZXIgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbmV4cG9ydHMuU3VzcGVuc2UgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBleHBvcnRzLlN0cmljdE1vZGUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIGV4cG9ydHMuUHJvZmlsZXIgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBleHBvcnRzLlN1c3BlbnNlID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgZXhwb3J0cy5Qcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBleHBvcnRzLlN0cmljdE1vZGU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cbiAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cblxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChyZW5kZXIuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBleHBvcnRzLlN0cmljdE1vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnIDogJycpO1xuICAgIH0gLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG57XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUdvb2dsZUZvbnRMb2FkZXIgfSBmcm9tICdAL2xpYi9ob29rcy5qcyc7XG5cbmltcG9ydCBDb250YWluZXIgZnJvbSAnQC9jb21wb25lbnRzL0NvbnRhaW5lcic7XG5pbXBvcnQgeyBsaWNlbnNlSW5mbyB9IGZyb20gJ0AvY29tcG9uZW50cy9Db250YWluZXInO1xuaW1wb3J0IExpY2Vuc2VCYW5uZXIgZnJvbSAnQC9jb21wb25lbnRzL0xpY2Vuc2VCYW5uZXInO1xuXG5jb25zdCBIb21lID0gKCkgPT4ge1xuICBjb25zdCBbaXNNb3VudGVkLCBzZXRJc01vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBnb29nbGVMaWNlbnNlSW5mbyA9IGxpY2Vuc2VJbmZvO1xuXG4gIGlmIChpc01vdW50ZWQpIHtcbiAgICB1c2VHb29nbGVGb250TG9hZGVyKCk7XG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzTW91bnRlZCh0cnVlKTsgLy8gU2V0IHRvIHRydWUgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWRcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPENvbnRhaW5lcj5cbiAgICAgIDw+XG4gICAgICAgIDxMaWNlbnNlQmFubmVyIGxpY2Vuc2VJbmZvPXtnb29nbGVMaWNlbnNlSW5mb30gLz5cbiAgICAgICAgPGgxXG4gICAgICAgICAgcm9sZT1cImhlYWRpbmdcIlxuICAgICAgICAgIGFyaWEtbGV2ZWw9XCIxXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCIgcC0zIHRleHQtY2VudGVyIHRleHQtcmVkLTkwMCBmb250LWJsYWNrIHRleHQteGxcIlxuICAgICAgICA+XG4gICAgICAgICAgVGhlIFNhbXBsZSBGb250cyBmb2xsb3cuLi5cbiAgICAgICAgPC9oMT5cblxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPGgyIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjJcIiBjbGFzc05hbWU9XCIgcC0zIHRleHQtY2VudGVyIHRleHQtYmx1ZS05MDAgZm9udC1ib2xkXCI+XG4gICAgICAgICAgU2FucyBFeGFtcGxlc1xuICAgICAgICA8L2gyPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LXNhbnMgZm9udC1ub3JtYWwgcC0zIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDBcIj5cbiAgICAgICAgICBGb250IFNhbnMgU2VyaWYgLSBPc3dhbGQgKDQwMClcbiAgICAgICAgPC9wPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LXNhbnMgZm9udC1ib2xkIHAtMyB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwXCI+XG4gICAgICAgICAgRm9udCBTYW5zIFNlcmlmIC0gT3N3YWxkICg3MDApXG4gICAgICAgIDwvcD5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1zZXJpZiBmb250LW5vcm1hbCBwLTMgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMFwiPlxuICAgICAgICAgIEZvbnQgU2FucyAtIE1lcnJpd2VhdGhlciBSZWd1bGFyICg0MDApXG4gICAgICAgIDwvcD5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1zZXJpZiBmb250LWJvbGQgcC0zIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDBcIj5cbiAgICAgICAgICBGb250IFNhbnMgLSBNZXJyaXdlYXRoZXIgQm9sZCAoNzAwKVxuICAgICAgICA8L3A+XG4gICAgICAgIDxociAvPlxuXG4gICAgICAgIDxoMlxuICAgICAgICAgIHJvbGU9XCJoZWFkaW5nXCJcbiAgICAgICAgICBhcmlhLWxldmVsPVwiMlwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZm9udC1zYW5zIHAtMyB0ZXh0LWNlbnRlciB0ZXh0LWJsdWUtOTAwIHRleHQteGxcIlxuICAgICAgICA+XG4gICAgICAgICAgVmFyaWFibGUgRm9udHNcbiAgICAgICAgPC9oMj5cblxuICAgICAgICA8aDNcbiAgICAgICAgICByb2xlPVwiaGVhZGluZ1wiXG4gICAgICAgICAgYXJpYS1sZXZlbD1cIjNcIlxuICAgICAgICAgIGNsYXNzTmFtZT1cIml0YWxpYyBmb250LUdyYW5kc3RhbmRlci1WYXJpYWJsZUZvbnQgcC0zIHRleHQtY2VudGVyIHRleHQtYmx1ZS05MDAgZm9udC1ib2xkXCJcbiAgICAgICAgPlxuICAgICAgICAgIEdyYW5kc3RhbmRlciBGb250cyAxMDAtOTAwXG4gICAgICAgIDwvaDM+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LUdyYW5kc3RhbmRlci1WYXJpYWJsZUZvbnQgZm9udC10aGluXCI+R3JhbmRzdGFuZGVyIFYgMTAwPC9wPlxuICAgICAgICAgIDxiciAvPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtR3JhbmRzdGFuZGVyLVZhcmlhYmxlRm9udCBmb250LWV4dHJhIGxpZ2h0XCI+R3JhbmRzdGFuZGVyIFYgMjAwPC9wPlxuICAgICAgICAgIDxiciAvPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtR3JhbmRzdGFuZGVyLVZhcmlhYmxlRm9udCBmb250LWxpZ2h0XCI+R3JhbmRzdGFuZGVyIFYgMzAwPC9wPlxuICAgICAgICAgIDxiciAvPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtR3JhbmRzdGFuZGVyLVZhcmlhYmxlRm9udCBmb250LW5vcm1hbFwiPkdyYW5kc3RhbmRlciBWIDQwMDwvcD5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LUdyYW5kc3RhbmRlci1WYXJpYWJsZUZvbnQgZm9udC1tZWRpdW1cIj5HcmFuZHN0YW5kZXIgViA1MDA8L3A+XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1HcmFuZHN0YW5kZXItVmFyaWFibGVGb250IGZvbnQtc2VtaWJvbGRcIj5HcmFuZHN0YW5kZXIgViA2MDA8L3A+XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1HcmFuZHN0YW5kZXItVmFyaWFibGVGb250IGZvbnQtYm9sZFwiPkdyYW5kc3RhbmRlciBWIDcwMDwvcD5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LUdyYW5kc3RhbmRlci1WYXJpYWJsZUZvbnQgZm9udC1leHRyYWJvbGRcIj5HcmFuZHN0YW5kZXIgViA4MDA8L3A+XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1HcmFuZHN0YW5kZXItVmFyaWFibGVGb250IGZvbnQtYmxhY2tcIj5HcmFuZHN0YW5kZXIgViA5MDA8L3A+XG4gICAgICAgICAgPGJyIC8+XG5cbiAgICAgICAgICA8aDNcbiAgICAgICAgICAgIHJvbGU9XCJoZWFkaW5nXCJcbiAgICAgICAgICAgIGFyaWEtbGV2ZWw9XCIzXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvbnQtc2FucyBwLTMgdGV4dC1jZW50ZXIgdGV4dC1ibHVlLTkwMCBmb250LWJvbGRcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIE9zd2FsZCBGb250cyAxMDAtOTAwXG4gICAgICAgICAgPC9oMz5cblxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtc2FucyBmb250LXRoaW5cIj5Pc3dhbGQgViAxMDA8L3A+XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1zYW5zIGZvbnQtZXh0cmEgbGlnaHRcIj5Pc3dhbGQgViAyMDA8L3A+XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1zYW5zIGZvbnQtbGlnaHRcIj5Pc3dhbGQgViAzMDA8L3A+XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1zYW5zIGZvbnQtbm9ybWFsXCI+T3N3YWxkIFYgNDAwPC9wPlxuICAgICAgICAgIDxiciAvPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtc2FucyBmb250LW1lZGl1bVwiPk9zd2FsZCBWIDUwMDwvcD5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LXNhbnMgZm9udC1zZW1pYm9sZFwiPk9zd2FsZCBWIDYwMDwvcD5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LXNhbnMgZm9udC1ib2xkXCI+T3N3YWxkIFYgNzAwPC9wPlxuICAgICAgICAgIDxiciAvPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtc2FucyBmb250LWV4dHJhYm9sZFwiPk9zd2FsZCBWIDgwMDwvcD5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LXNhbnMgZm9udC1ibGFja1wiPk9zd2FsZCBWIDkwMDwvcD5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8Lz5cbiAgICA8L0NvbnRhaW5lcj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWU7XG4iXSwic291cmNlUm9vdCI6IiJ9